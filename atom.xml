<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WE ARE YOUNG</title>
  
  <subtitle>So let&#39;s set the world on fire</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zhangyongfa888.site/"/>
  <updated>2019-11-04T08:44:54.672Z</updated>
  <id>http://zhangyongfa888.site/</id>
  
  <author>
    <name>zhangyongfa</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TINKER 集成</title>
    <link href="http://zhangyongfa888.site/2019/11/04/Tinker%E9%9B%86%E6%88%90/"/>
    <id>http://zhangyongfa888.site/2019/11/04/Tinker集成/</id>
    <published>2019-11-04T08:44:36.000Z</published>
    <updated>2019-11-04T08:44:54.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="TINKER-集成"><a href="#TINKER-集成" class="headerlink" title="TINKER 集成"></a>TINKER 集成</h1><h2 id="Tinker是啥"><a href="#Tinker是啥" class="headerlink" title="Tinker是啥"></a>Tinker是啥</h2><p>Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。<a href https: github.com tencent tinker"">Tinker Github</a></p><h3 id="为什么使用Tinker"><a href="#为什么使用Tinker" class="headerlink" title="为什么使用Tinker"></a>为什么使用Tinker</h3><p>当前市面的热补丁方案有很多，其中比较出名的有阿里的AndFix、美团的Robust以及QZone的超级补丁方案。但它们都存在无法解决的问题，这也是正是我们推出Tinker的原因。如下，就可以知道Tinker的强大之处。</p><table><thead><tr><th align="center"></th><th align="center">Tinker</th><th align="center">QZone</th><th align="center">AndFix</th><th align="center">Robust</th></tr></thead><tbody><tr><td align="center">类替换</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">So替换</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">资源替换</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">全平台支持</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">yes</td></tr><tr><td align="center">即时生效</td><td align="center">no</td><td align="center">no</td><td align="center">yes</td><td align="center">yes</td></tr><tr><td align="center">性能损耗</td><td align="center">较小</td><td align="center">较大</td><td align="center">较小</td><td align="center">较小</td></tr><tr><td align="center">补丁包大小</td><td align="center">较小</td><td align="center">较大</td><td align="center">一般</td><td align="center">一般</td></tr><tr><td align="center">开发透明</td><td align="center">yes</td><td align="center">yes</td><td align="center">no</td><td align="center">no</td></tr><tr><td align="center">复杂度</td><td align="center">较低</td><td align="center">较低</td><td align="center">复杂</td><td align="center">复杂</td></tr><tr><td align="center">Rom体积</td><td align="center">Dalvik较大</td><td align="center">较小</td><td align="center">较小</td><td align="center">较小</td></tr><tr><td align="center">成功率</td><td align="center">较高</td><td align="center">较高</td><td align="center">一般</td><td align="center">最高</td></tr></tbody></table><h3 id="Tinker的已知问题"><a href="#Tinker的已知问题" class="headerlink" title="Tinker的已知问题"></a>Tinker的已知问题</h3><p>由于原理与系统限制，Tinker有以下已知问题：</p><p>Tinker不支持修改AndroidManifest.xml，Tinker不支持新增四大组件</p><p>由于Google Play的开发者条款限制，不建议在GP渠道动态更新代码；</p><p>在Android N上，补丁对应用启动时间有轻微的影响；</p><p>不支持部分三星android-21机型，加载补丁时会主动抛出”TinkerRuntimeException:checkDexInstall failed”；</p><p>对于资源替换，不支持修改remoteView。例如transition动画，notification icon以及桌面图标。</p><h2 id="Tinker集成过程（使用bugly集成）"><a href="#Tinker集成过程（使用bugly集成）" class="headerlink" title="Tinker集成过程（使用bugly集成）"></a>Tinker集成过程（使用bugly集成）</h2><p>项目工程的.gradle 中添加</p><pre><code>classpath &quot;com.tencent.bugly:tinker-support:1.2.0&quot;</code></pre><p>app的.gradle中添加</p><pre><code>implementation &apos;com.tencent.bugly:crashreport_upgrade:1.4.2&apos;implementation &apos;com.tencent.tinker:tinker-android-lib:1.9.14&apos;</code></pre><p>应用bugly配置好的gradle文件</p><pre><code>apply from: &apos;tinker-support.gradle&apos;</code></pre><p> <img src="http://res.zhangyongfa888.site/1572852444001uf3oaut6.png?imageslim" alt="app gradle 结构"></p><p>tinker-support.gradle 代码</p><pre><code>apply plugin: &apos;com.tencent.bugly.tinker-support&apos;def bakPath = file(&quot;${buildDir}/bakApk/&quot;)/** * 此处填写每次构建生成的基准包目录 */def baseApkDir = &quot;huozhu-1104-11-36-34&quot;/*** 对于插件各参数的详细解析请参考*/tinkerSupport {    // 开启tinker-support插件，默认值true    enable = true  // 指定归档目录，默认值当前module的子目录tinker   autoBackupApkDir = &quot;${bakPath}&quot;   // 是否启用覆盖tinkerPatch配置功能，默认值false   // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch  overrideTinkerPatchConfiguration = true   // 编译补丁包时，必需指定基线版本的apk，默认值为空   // 如果为空，则表示不是进行补丁包的编译   // @{link tinkerPatch.oldApk }    baseApk = &quot;${bakPath}/${baseApkDir}/huozhu-release.apk&quot;   // 对应tinker插件applyMapping   baseApkProguardMapping = &quot;${bakPath}/${baseApkDir}/huozhu-release-mapping.txt&quot;   // 对应tinker插件applyResourceMapping  baseApkResourceMapping = &quot;${bakPath}/${baseApkDir}/huozhu-release-R.txt&quot;  // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性   tinkerId = &quot;base_11.04.11.49&quot;  // 构建多渠道补丁时使用  // buildAllFlavorsDir = &quot;${bakPath}/${baseApkDir}&quot;  // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持） // isProtectedApp = true  // 是否开启反射Application模式  enableProxyApplication = false  // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件） supportHotplugComponent = true}/** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */tinkerPatch {//oldApk =&quot;${bakPath}/${appName}/app-release.apk&quot;     ignoreWarning = false     useSign = true     dex {         dexMode = &quot;jar&quot;         pattern = [&quot;classes*.dex&quot;]         loader = []     }     lib {         pattern = [&quot;lib/*/*.so&quot;]     }     res {          pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;]          ignoreChange = []          largeModSize = 100      }   packageConfig {   }  sevenZip {      zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot;    //        path = &quot;/usr/local/bin/7za&quot;    }   buildConfig {      keepDexApply = false      //tinkerId = &quot;1.0.1-base&quot;      //applyMapping = &quot;${bakPath}/${appName}/app-release-mapping.txt&quot; //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式    //applyResourceMapping = &quot;${bakPath}/${appName}/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配   }}</code></pre><p> 配置application</p><p> 新建SampleApplicationLike 继承自DefaultApplicationLike ,开启反射application模式</p><pre><code>enableProxyApplication = false   //tinker-support.gradle 中的配置</code></pre><p> 在onBaseContextAttached 添加MultiDex 和Tinker</p><pre><code>public void onBaseContextAttached(Context base) {    super.onBaseContextAttached(base);   // you must install multiDex whatever tinker is installed!   MultiDex.install(base);   // 安装tinker  TinkerManager.installTinker(this);}</code></pre><p>应用的Application 继承自TinkerApplication 并重写默认构造方法<br>    public MyApplication() {<br>        super(ShareConstants.TINKER_ENABLE_ALL, “xx.xx.SampleApplicationLike”,<br>                “com.tencent.tinker.loader.TinkerLoader”, false);<br>    }</p><h2 id="Tinker-生成插件包-可使用bugly中的tinker-support"><a href="#Tinker-生成插件包-可使用bugly中的tinker-support" class="headerlink" title="Tinker 生成插件包(可使用bugly中的tinker-support)"></a>Tinker 生成插件包(可使用bugly中的tinker-support)</h2><p>先生成基准包，也就是上线后有bug的包；默认在build/bakApk 中 assemble一次就会生成一次</p><p>基准包目录结构</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/15728533899301u1llzje.png?imageslim" alt="目录结构" title>                </div>                <div class="image-caption">目录结构</div>            </figure><p>huozhu-release.apk 因为是组件化的目录结构 所以是huozhu-release.apk 而不是app-release.apk 而且注意 tinker-support.gradle 配置的指定文件名称是否一致;</p><p>huozhu-release-mapping.txt :开启混淆后会生成mapping文件</p><p>基准包生成后将 地址 复制到配置中</p><pre><code>/*** 此处填写每次构建生成的基准包目录*/def baseApkDir = &quot;huozhu-1104-11-36-34&quot;</code></pre><p>同时指定一个唯一的tinkerId 可以理解为 每一次打补丁包都要指定一个tinkerId </p><p>修改部分代码 然后执行生成补丁</p><p> <img src="http://res.zhangyongfa888.site/1572853788363w411qfuz.png?imageslim" alt="生成补丁"></p><p>因为是bugly中的tinker 所以直接使用tinker-support中的buildTinkerPatchRelease ，在outputs根目录生的patch生成了可用补丁</p><p>如果是tinker中的tinkerPatchRelease 则在outputs/apk/tinkerPatch中生成了补丁</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/15728539817374saenorw.png?imageslim" alt="插件目录" title>                </div>                <div class="image-caption">插件目录</div>            </figure><h2 id="加载补丁包"><a href="#加载补丁包" class="headerlink" title="加载补丁包"></a>加载补丁包</h2><p>在app首页或者任意位置去加载补丁包</p><p>这里封装了一下下载补丁的方法 直接调用即可</p><pre><code>PatchUtils.getInstance().checkPatch(context);</code></pre><p>核心方法是</p><pre><code>TinkerInstaller.onReceiveUpgradePatch(context, file.getAbsolutePath());</code></pre><p>Tinker中已经有各种判断 补丁是否正确等判断，所以直接加载就可以。</p><p>加载监听：</p><pre><code>TinkerManager.getInstance().setTinkerListener(new TinkerManager.TinkerListener() {        @Override        public void onDownloadSuccess(String s) {            Log.d(&quot;onDownloadSuccess&quot;, s);        }        @Override        public void onDownloadFailure(String s) {            Log.d(&quot;onDownloadFailure&quot;, s);        }        @Override        public void onPatchStart() {        }        @Override        public void onApplySuccess(String s) {            Log.d(&quot;onApplySuccess&quot;, s);            Toast.makeText(context, &quot;更新完成 即将重启&quot;, Toast.LENGTH_SHORT).show();            new Handler().postDelayed(new Runnable() {                @Override                public void run() {                    PackageManager packageManager = context.getPackageManager();                    Intent intent = packageManager.getLaunchIntentForPackage(context.getPackageName());                    intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);                    context.startActivity(intent);                    AppUtils.exitApp(context);                    System.exit(0);                }            }, 2000);        }        @Override        public void onApplyFailure(String s) {            Log.d(&quot;onApplyFailure&quot;, s);        }        @Override        public void onPatchRollback() {        }    });</code></pre><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>1.当项目中含有第三方lib库时候，加载补丁会报错</p><pre><code>java.lang.UnsatisfiedLinkError: Shared library &quot;/data/app/***-3IhVXmnAlMEQk_hwO6_0Mg==/lib/arm/libc++_shared.so&quot; already opened by ClassLoader</code></pre><p>解决办法：第三方库加载前，有tinker加载</p><pre><code>TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduMapSDK_base_v6_0_0&quot;);TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduMapSDK_map_v6_0_0&quot;);TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduTraceSDK_v3_0_7&quot;);</code></pre><p>2.新添加的activity 找不到声明</p><pre><code>基础包必须设置supportComponent=true，并且新增Activity的Exported属性必须为false。</code></pre><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>如何对多渠道、加固包等做处理，以及<strong>少扣绩效</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;TINKER-集成&quot;&gt;&lt;a href=&quot;#TINKER-集成&quot; class=&quot;headerlink&quot; title=&quot;TINKER 集成&quot;&gt;&lt;/a&gt;TINKER 集成&lt;/h1&gt;&lt;h2 id=&quot;Tinker是啥&quot;&gt;&lt;a href=&quot;#Tinker是啥&quot; class=&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>隐私政策</title>
    <link href="http://zhangyongfa888.site/2019/09/17/%E9%9A%90%E7%A7%81%E6%94%BF%E7%AD%96/"/>
    <id>http://zhangyongfa888.site/2019/09/17/隐私政策/</id>
    <published>2019-09-17T07:05:17.000Z</published>
    <updated>2019-09-17T08:05:10.528Z</updated>
    
    <content type="html"><![CDATA[<h1 id="货运宝用户隐私权保护协议"><a href="#货运宝用户隐私权保护协议" class="headerlink" title="货运宝用户隐私权保护协议"></a>货运宝用户隐私权保护协议</h1><p>本《货运宝用户隐私权保护协议》（“本协议”）是河北网络技术有限公司旗下“货运宝”（“货运宝平台”）的运营者和服务提供者，与您（“您”或“用户”）就您使用货运宝平台涉及的您的隐私权保护问题所订立的有效合约。</p><p> </p><p>货运宝将按照本协议约定<strong>收集、使用、共享</strong>及<strong>保护</strong>您的用户信息。本协议包含了货运宝收集、存储、使用、共享和保护您的用户信息的条款，希望通过本协议向您清晰地介绍货运宝对您用户信息的处理方式，因此建议您完整地阅读本协议，以帮助您了解维护自己隐私权的方式。</p><p> </p><p><strong>您点击或勾选货运宝平台相关页面上的“同意”键或者以其他方式确认同意/接受本协议（如在相关页面上点击后续操作或已实际享有本协议项下的权益或已实际接受货运宝的服务或已实际执行本协议项下的部分约定等）（“确认”），即表示您与货运宝已达成协议并同意接受本协议全部约定内容的约束。</strong></p><p>在确认本协议之前，请您仔细阅读本协议的全部内容（特别是以<strong>粗体</strong>或_下划线_标注的内容）。如果您不同意本协议的任意内容，或者无法准确理解本协议任何条款的含义，请不要进行确认及后续操作，停止使用货运宝平台的服务。当您使用货运宝平台提供的任一服务时，即表示您已同意货运宝按照本协议来合法使用和保护您的用户信息。本协议构成您注册、使用货运宝平台之先决条件，您的使用行为将视为同意接受本协议各项条款的约束。</p><p>本协议属于《货运宝用户服务协议》不可分割的一部分，除本协议另有定义外，《货运宝用户服务协议》下的定义适用于本协议。</p><p>货运宝尊重并保护所有用户的隐私。为了给您提供更准确、更有个性化的服务，货运宝会按照本协议的规定保存、保护、使用和披露与您有关的信息（“隐私信息”）。</p><h3 id="一、-隐私信息的收集和内容"><a href="#一、-隐私信息的收集和内容" class="headerlink" title="一、       隐私信息的收集和内容"></a>一、       隐私信息的收集和内容</h3><h4 id="1-1"><a href="#1-1" class="headerlink" title="1.1"></a>1.1</h4><p>货运宝提供货运宝平台服务时，可能会收集、储存和使用您的隐私信息。如果您不提供相关隐私信息，将无法注册成为货运宝用户或无法享受货运宝平台提供的某些服务，或者无法达到相关服务拟达到的效果。</p><h4 id="1-2"><a href="#1-2" class="headerlink" title="1.2"></a>1.2</h4><p>隐私信息包括您的下列信息，且您同意授权货运宝按下述约定获取该等信息：</p><p>（1） 在您注册账号或开通、使用、接受货运宝平台的特定服务的过程中，您根据货运宝平台要求提供的用户注册信息（包括但不限于您的非公开的基本信息、您个人或您的法定代表人/负责人/经营者/代表的姓名、性别、出生年月日、证件号码、证件类型、住所地、电话号码、电子邮件地址、银行账户信息、生物特征信息及其他相关附加信息）、验证信息、验证信息凭证及/或其他信息；</p><p>（2） 在您使用货运宝平台服务，或访问货运宝平台及相关网页、移动设备客户端时，货运宝自动接收并记录的您操作的相关信息，包括但不限于您的计算机IP地址、浏览器的类型、使用的语言、访问日期和时间、软硬件特征信息（含设备标识符、硬件型号、操作系统版本等）及您需求的网页记录等与货运宝服务相关的数据；</p><p>（3） 您在开通、使用、接受货运宝平台的特定服务及/或货运宝的合作方通过货运宝平台提供的服务/商品时所提供及所形成的任何信息和数据；</p><p>（4） 您在访问货运宝平台移动设备客户端时，您授权货运宝访问、读取您的移动终端设备上的通讯信息（包括但不限于短信、手机通讯录、通话记录等）；</p><p>（5） 您通过货运宝平台服务向其他方提供的共享信息，以及您使用货运宝平台服务时所储存的信息；</p><p>（6） 您与货运宝的客户服务团队联系时您提供的相关信息，您参与问卷调查时发送的问卷答复信息，以及您接受货运宝及其合作机构提供的服务时，货运宝收集的相关信息；</p><p>（7） 有关您曾使用的移动应用（APP）和其他软件的信息，以及您曾经使用该等移动应用和软件的信息；您的网络使用习惯、您常用的软件信息等；</p><p>（8） 您通过货运宝平台服务进行通讯的信息，例如曾通讯的号码，以及通讯时间、数据和时长；</p><p>（9） 您向货运宝或货运宝的合作方提供及/或授权货运宝自行或通过第三方查询获得的财产信息，包括但不限于您的财税信息、房产信息、基金、保险、股票、信托、债券、P2P等投资理财信息和负债、担保信息；</p><p>（10）   位置信息，指您开启您的终端设备等其他GPS设备及其定位功能以及货运宝平台定位系统/功能并使用货运宝平台基于位置提供的相关服务时，收集的有关您位置的信息，包括：</p><pre><code>a) 您通过具有定位功能的终端设备等其他GPS设备使用货运宝平台服务时，货运宝通过GPS或WiFi等方式收集的您的地理位置信息；b) 您或其他用户提供的包含您所处地理位置的实时信息，例如您提供的账户信息中包含的您所在地区信息，您或其他人上传的显示您当前或曾经所处地理位置的共享信息，您或其他人共享的照片包含的地理标记信息。</code></pre><p>您可以通过关闭定位功能，停止货运宝对您的地理位置信息的收集。</p><p>（11）   您授权货运宝向第三方征信机构查询您及您个人或您的法定代表人/负责人/经营者/代表的相关信用信息和数据，包括但不限于关于您的任何信用状况、征信记录（包括您的收入、存款、有价证券、商业保险、不动产的信息和纳税数额信息等财产状况、身体健康状况、位置、行为记录、失信违约记录、违法违规记录等敏感信息等）、信用分、信用报告、能够联系到您的实体地址、电子邮件地址、电话号码等信息、数据；</p><p>（12）   您在货运宝的商业合作伙伴处留存和形成的任何信息和数据（包括但不限于您的支付账户、银行账户信息、任何协议及您在该等协议项下的履约情况、行为数据等）；</p><p>（13）   您在其他合法留存您信息的自然人、法人以及其他组织处留存的信息。</p><h4 id="1-3-您充分知晓，货运宝收集、使用以下信息无需征得您的授权同意："><a href="#1-3-您充分知晓，货运宝收集、使用以下信息无需征得您的授权同意：" class="headerlink" title="1.3    您充分知晓，货运宝收集、使用以下信息无需征得您的授权同意："></a>1.3    您充分知晓，货运宝收集、使用以下信息无需征得您的授权同意：</h4><p>（1） 与国家安全、国防安全有关的；</p><p>（2） 与公共安全、公共卫生、重大公共利益有关的；</p><p>（3） 与犯罪侦查、起诉、审判和判决执行等有关的；</p><p>（4） 出于维护您或其他用户的生命、财产等重大合法权益但又很难得到您本人同意的；</p><p>（5） 从合法公开披露的信息中收集的您的个人信息的，如合法的新闻报道、政府信息公开等渠道；</p><p>（6） 用于维护所提供的产品与/或服务的安全稳定运行所必需的，例如发现、处置产品与/或服务的故障；</p><p>（7） 为合法的新闻报道所必需的；</p><p>（8） 学术研究机构基于公共利益开展统计或学术研究所必要，且对外提供学术研究或描述的结果时，对结果中所包含的个人信息进行去标识化处理的；</p><p>（9） 您在使用货运宝平台服务时输入的其他用户或除本协议以外的第三方可在货运宝平台上看见或知悉的信息；</p><p>（10）            货运宝收集到的您在货运宝平台发布的有关信息数据，包括但不限于货源信息、参与活动、成交信息及评价详情；</p><p>（11）            您的信用评价信息、您违反法律规定、《货运宝用户服务协议》及/或货运宝平台的其他规则向货运宝平台提交的用户信息、实施的行为；</p><p>（12）            其他用户对您的投诉、举报信息；</p><p>（13）            因您发生本协议第1.3条第（11）、（12）项的情形，货运宝对您采取的措施；</p><p>（14）            货运宝基于您及其他用户的隐私信息进行的数据分析及得出的结论；</p><p>（15）            其他依法不属于隐私信息的信息。</p><h4 id="1-4-第三方提供服务时收集的信息，包括："><a href="#1-4-第三方提供服务时收集的信息，包括：" class="headerlink" title="1.4    第三方提供服务时收集的信息，包括："></a>1.4    第三方提供服务时收集的信息，包括：</h4><p>（1） 通过货运宝平台服务而接入的第三方服务（包括任何第三方网站）收集的信息。货运宝平台服务可能包括或链接至第三方提供的服务，货运宝通过广告或货运宝平台服务的其他方式向您提供链接，使您可以接入第三方的服务或网站。</p><p>（2） 在货运宝平台中提供广告服务的第三方所收集的信息。</p><p>本协议第1.4条所述第三方服务可能由相关的第三方或货运宝运营。您使用该等第三方服务（包括您向该等第三方提供的任何用户信息），须受该第三方的服务条款及隐私政策的约束，您需要仔细阅读其条款。除本协议另有约定以外，本协议仅适用于货运宝所收集的您的隐私信息，并不适用于任何第三方提供的服务或第三方的信息使用规则，货运宝对任何第三方使用由您提供的信息不承担任何责任。</p><h4 id="1-5"><a href="#1-5" class="headerlink" title="1.5"></a>1.5</h4><p>您有义务持续确保您在货运宝平台和运满满平台所填写及提供的手机号、用户信息、用户信息凭证、验证信息、验证信息凭证等资料、凭证、信息的真实性、准确性、完整性、对应一致性及有效性。若您注册运满满平台或货运宝平台账号的手机号所认证的身份证号、姓名并非手机通信运营商实名认证一致的身份证号、姓名（“实名身份信息”），则您应立即将认证的身份证号和姓名修改为实名身份信息，否则货运宝有权限制或停止向您提供部分或全部货运宝平台服务或限制您货运宝账户的部分或全部功能，货运宝对此不承担任何责任，您将承担因此而产生的全部直接或间接损失，同时，您还应当赔偿货运宝及/或任何其他第三方因此遭受的全部损失。若您使用同一个手机号同时注册了货运宝平台和运满满平台，且您在运满满平台或货运宝平台认证的身份证号和姓名并非实名身份信息，您在此不可撤销地授权货运宝将您在运满满平台或货运宝平台注册的手机号对应的身份证号和姓名修改为实名身份信息，货运宝自行决定是否为您作该等修改及修改的时间。</p><h3 id="二、-隐私信息的使用"><a href="#二、-隐私信息的使用" class="headerlink" title="二、       隐私信息的使用"></a>二、       隐私信息的使用</h3><h4 id="2-1-货运宝可能将隐私信息用作下列用途："><a href="#2-1-货运宝可能将隐私信息用作下列用途：" class="headerlink" title="2.1    货运宝可能将隐私信息用作下列用途："></a>2.1    货运宝可能将隐私信息用作下列用途：</h4><p>（1） 向您提供服务，并维护、改进这些服务；</p><p>（2） 在货运宝提供本服务时，用于身份验证、用户服务、安全防范、诈骗监测、存档和备份用途，以提高货运宝向您提供本服务的安全性；用于预防、发现、调查欺诈以及危害安全、非法或违反与货运宝签订的协议以及货运宝平台政策或规则的行为，以保护您、其他货运宝用户、货运宝及其他善意第三方的合法权益；</p><p>（3） 帮助货运宝设计新服务，改善货运宝平台现有服务；</p><p>（4） 使货运宝更加了解您如何接入和使用本服务，从而针对性地回应您的个性化需求，例如语言设定、位置设定、个性化的帮助服务和指示，或对您和其他用户作出其他方面的回应；</p><p>（5） 在与合作机构共同向您提供服务时，与合作机构共享信息以便他们向您发送有关其产品和服务的信息及/或提供产品和服务；</p><p>（6） 向您提供与您更加相关的广告以替代普遍投放的广告；</p><p>（7） 为使您知晓并了解货运宝的服务情况，向您发送服务状态的通知、营销活动及其他商业性电子信息；</p><p>（8） 记录并管理您访问和接受服务的状态、交易记录和历史记录；</p><p>（9） 向您推荐您可能感兴趣的内容，包括但不限于向您发出产品和服务信息，或通过系统向您展示个性化的第三方推广信息；</p><p>（10）   评估货运宝平台服务和其他促销及推广活动的效果，并加以改善；</p><p>（11）   货运宝平台系统认证或管理系统升级；</p><p>（12）   让您参与货运宝或其合作机构提供之服务的调查；</p><p>（13）   预防或禁止非法的活动；</p><p>（14）   根据相关法律法规以及国家有关行政主管机关、司法机关、仲裁机构的要求，分享并提供及使用隐私信息；</p><p>（15）   您许可的其他用途。</p><h4 id="2-2"><a href="#2-2" class="headerlink" title="2.2"></a>2.2</h4><p>为了让您有更好的体验、改善货运宝平台服务或您同意的其他隐私信息用途，在符合相关法律法规的前提下，货运宝可能将通过某一项货运宝平台服务所收集的信息，以汇集信息或者个性化的方式，用于货运宝的其他服务或者与货运宝平台合作伙伴共享信息以便他们向您发送有关其产品和服务的信息。例如，在您使用货运宝的一项服务时所收集的信息，可能在另一服务中用于向您提供特定内容，或向您展示与您相关的、非普遍推送的信息。如果货运宝在相关服务中提供了相应选项，您也可以授权货运宝将该服务所提供和储存的信息用于货运宝的其他服务。</p><h3 id="三、-隐私信息的分享"><a href="#三、-隐私信息的分享" class="headerlink" title="三、       隐私信息的分享"></a>三、       隐私信息的分享</h3><h4 id="3-1"><a href="#3-1" class="headerlink" title="3.1"></a>3.1</h4><p>除以下情形外和本协议另有约定外，未经您同意，货运宝不会与任何第三方分享您的隐私信息：</p><p>（1） 为向您提供货运宝平台服务，而必须和第三方分享您的隐私信息；</p><p>（2） 为了判断您的账户或交易是否安全；</p><p>（3） 货运宝可能将您的隐私信息与货运宝的关联公司（包括但不限于运满满平台及其运营主体以及该等运营主体的关联公司）、合作伙伴、第三方征信机构（包括但不限于芝麻信用及其运营主体）、第三方支付机构、电子签名认证机构及其他第三方服务供应商、承包商及代理（例如代表货运宝发出电子邮件或推送通知的通讯服务提供商、为货运宝提供位置数据的地图服务供应商）分享（他们可能并非位于您所在的法域），用作下列用途：</p><pre><code>a) 实现本协议第二条所述目的；b) 履行货运宝在《货运宝用户服务协议》或本协议中的义务和行使货运宝的权利；c) 理解、维护和改善货运宝平台服务；及/或d) 由第三方征信机构出于提供信用或风控服务的需要，用于验证您的信息的真实性及风险判断使用，并将上述分析结果提供给商户/货运宝的合作方。</code></pre><p>（4） 货运宝与第三方进行联合推广活动，货运宝可能与其共享活动过程中产生的、为完成活动所必要的隐私信息；</p><p>（5） 在货运宝平台上创建的某一交易中，如交易任何一方履行或部分履行了交易义务并提出信息披露请求的，货运宝有权决定向该用户提供其交易对方的联络方式等必要信息，以促成交易的完成或纠纷的解决；</p><p>（6） 处理您与他人的纠纷或争议；</p><p>（7） 为维护货运宝及其他货运宝用户的合法权益；</p><p>（8） 为维护和改善货运宝的服务；</p><p>（9） 您出现违反有关法律规定或者《货运宝用户服务协议》或相关规则的情况，需要向第三方披露您的隐私信息；</p><p>（10）   其他货运宝根据法律规定、《货运宝用户服务协议》及/或货运宝平台的其他规则认为有必要披露的情形。</p><h4 id="3-2-货运宝还有权为以下需要而保留、保存或披露您的隐私信息："><a href="#3-2-货运宝还有权为以下需要而保留、保存或披露您的隐私信息：" class="headerlink" title="3.2    货运宝还有权为以下需要而保留、保存或披露您的隐私信息："></a>3.2    货运宝还有权为以下需要而保留、保存或披露您的隐私信息：</h4><p>（1） 遵守适用的法律法规；</p><p>（2） 遵守法院、公安、检察院或其他有权机关的命令；</p><p>（3） 遵守相关政府机关的要求；</p><p>（4） 为遵守适用的法律法规、维护社会公共利益，或保护货运宝、货运宝的用户、雇员的人身、财产安全或其他合法权益所必须使用的合理用途。</p><h4 id="3-3"><a href="#3-3" class="headerlink" title="3.3"></a>3.3</h4><p>如货运宝与第三方分享您的隐私信息，货运宝将努力使该等第三方在使用您的隐私信息时遵守本协议及货运宝要求其遵守的其他适当的保密和安全措施。</p><h4 id="3-4"><a href="#3-4" class="headerlink" title="3.4"></a>3.4</h4><p>随着货运宝业务的持续发展，货运宝各个关联公司有可能进行合并、收购、资产转让或类似的交易，您同意授权货运宝有权将您的隐私信息作为此类交易的一部分而被转移。</p><h3 id="四、用户对用户信息的访问、更新"><a href="#四、用户对用户信息的访问、更新" class="headerlink" title="四、用户对用户信息的访问、更新"></a>四、用户对用户信息的访问、更新</h3><p>货运宝将尽一切可能采取适当的技术手段，保证您可以访问、更新和更正自己的注册信息或在使用货运宝的服务时基于交易需要访问其他用户信息。在访问、更新、更正和删除前述信息时，货运宝可能会要求您进行身份验证，以保障账号安全。</p><h3 id="五、信息安全及保密"><a href="#五、信息安全及保密" class="headerlink" title="五、信息安全及保密"></a>五、信息安全及保密</h3><h4 id="5-1"><a href="#5-1" class="headerlink" title="5.1"></a>5.1</h4><p>货运宝仅为实现本协议所述目的保留您的隐私信息。</p><h4 id="5-2"><a href="#5-2" class="headerlink" title="5.2"></a>5.2</h4><p>货运宝会采用符合业界标准的安全防护措施，按照现有技术使用相应的安全技术和程序，提供合理的安全保障，在任何时候尽力做到使您的隐私信息不被泄露、毁损、丢失、不当使用、未经授权阅览或披露。货运宝同时要求可能接触到您隐私信息的人员/合作伙伴履行相应的保密义务。如果未能履行这些义务，可能会被追究法律责任或被中止与货运宝的合作关系。但同时，您也同意并理解，即便竭尽所能加强安全措施，由于黑客攻击、技术限制、可能存在的各种恶意手段及/或其他因货运宝可控范围外的因素，货运宝所获得及保存的您的隐私信息有可能在未经您许可的情况下被其他第三方获得，在这种情况下，除非货运宝故意泄露您的该等信息，您不应当追究货运宝的任何责任。</p><h4 id="5-3"><a href="#5-3" class="headerlink" title="5.3"></a>5.3</h4><p>请妥善保管您的账号及其密码，并务必在安全的网络环境、设备设施上输入账户密码、使用货运宝服务。货运宝将通过对用户密码进行加密等安全措施来防止前述信息不丢失，不被滥用和变造。尽管有前述安全措施，但同时也请您注意在信息网络上不存在“完善的安全措施”。</p><h4 id="5-4"><a href="#5-4" class="headerlink" title="5.4"></a>5.4</h4><p>在使用货运宝用户网络服务进行网上交易时，您不可避免的要向交易对方或潜在的交易对方披露自己的隐私信息，如联络方式或者联系地址。请您妥善保护自己的隐私信息，仅在必要的情形下向他人提供，否则对因此而造成的您的隐私信息的泄露和损失，货运宝不承担任何责任。如您发现自己的隐私信息泄密，尤其是账户及/或其密码发生泄露，请您立即联络货运宝客服，以便货运宝采取相应措施。</p><h4 id="5-5-货运宝将根据法律法规规定及本协议约定对您的隐私信息予以保密，但下列情形除外："><a href="#5-5-货运宝将根据法律法规规定及本协议约定对您的隐私信息予以保密，但下列情形除外：" class="headerlink" title="5.5    货运宝将根据法律法规规定及本协议约定对您的隐私信息予以保密，但下列情形除外："></a>5.5    货运宝将根据法律法规规定及本协议约定对您的隐私信息予以保密，但下列情形除外：</h4><p>（1） 法律、法规、规章及其他规范性文件另有规定；</p><p>（2） 政府机关、司法机关及监管部门提出要求；</p><p>（3） 相关信息已成为公开信息；</p><p>（4） 您同意无须再严格保密；</p><p>（5） 本协议另有约定；</p><p>（6） 其他合法情形。</p><h3 id="六、其他"><a href="#六、其他" class="headerlink" title="六、其他"></a>六、其他</h3><h4 id="6-1"><a href="#6-1" class="headerlink" title="6.1"></a>6.1</h4><p>本协议未尽事宜以《货运宝用户服务协议》及所有货运宝已经发布的或将来可能发布的货运宝平台服务使用规则为准。</p><h4 id="6-2"><a href="#6-2" class="headerlink" title="6.2"></a>6.2</h4><p>您同意，本协议的签订、效力、履行、终止及其解释适用中华人民共和国（为本协议之目的，不包括香港特别行政区、澳门特别行政区及台湾地区）的法律。</p><h4 id="6-3"><a href="#6-3" class="headerlink" title="6.3"></a>6.3</h4><p>因货运宝与您就本协议的签订、履行或解释发生争议，双方应努力友好协商解决。如协商不成，货运宝和您均同意由贵阳货运宝科技有限公司住所地有管辖权的法院通过诉讼解决。</p><h4 id="6-4"><a href="#6-4" class="headerlink" title="6.4"></a>6.4</h4><p>双方确认，为更好地为您提供货运宝平台服务，货运宝有权随时修改或变更本协议，并将通过货运宝平台公布最新的协议内容，货运宝将不另作个别通知，您自愿接受本协议及货运宝不时发布的新规则的约束。若您在本协议的内容发生修改、变更后，继续使用货运宝平台服务的，视为您已阅读、了解并同意最新修订的本协议内容。</p><h4 id="6-5"><a href="#6-5" class="headerlink" title="6.5"></a>6.5</h4><p>本协议所有条款的标题仅为阅读方便，本身并无实际涵义，不能作为本协议涵义解释的依据。</p><h4 id="6-6"><a href="#6-6" class="headerlink" title="6.6"></a>6.6</h4><p>本协议条款无论因何种原因部分无效或不可执行，其余条款仍有效，对双方具有约束力。</p><h4 id="6-7"><a href="#6-7" class="headerlink" title="6.7"></a>6.7</h4><p>本协议以电子版本订立，自您确认之日起，对您与货运宝均有约束力。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;货运宝用户隐私权保护协议&quot;&gt;&lt;a href=&quot;#货运宝用户隐私权保护协议&quot; class=&quot;headerlink&quot; title=&quot;货运宝用户隐私权保护协议&quot;&gt;&lt;/a&gt;货运宝用户隐私权保护协议&lt;/h1&gt;&lt;p&gt;本《货运宝用户隐私权保护协议》（“本协议”）是河北网络技术有
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>测试点击事件</title>
    <link href="http://zhangyongfa888.site/2019/09/09/%E6%B5%8B%E8%AF%95%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6/"/>
    <id>http://zhangyongfa888.site/2019/09/09/测试点击事件/</id>
    <published>2019-09-09T07:51:17.000Z</published>
    <updated>2019-09-10T06:39:11.525Z</updated>
    
    <content type="html"><![CDATA[<h2 id="计算工具"><a href="#计算工具" class="headerlink" title="计算工具"></a>计算工具</h2><h3 id="——————————————————————"><a href="#——————————————————————" class="headerlink" title="——————————————————————"></a>——————————————————————</h3><h3 id="选择开始时间"><a href="#选择开始时间" class="headerlink" title="选择开始时间"></a>选择开始时间</h3><body><input type="date" name="date" id="date" min="2014-01-01" max="2099-01-01" value="2018-08-08"><br><br><button style="font-size:20px;padding-left:20px;padding-right:20px;" onclick="a()">计算</button><script>    function a() {        var current = new Date();        var currentYear = current.getFullYear();        var currentMonth = current.getMonth() + 1;        var currentDay = current.getDate();        var currentDate = currentYear + "-" + (currentMonth < 10 ? "0" + currentMonth : currentMonth + "") + "-" + (currentDay < 10 ? "0" + currentDay : currentDay + "");        var v = document.getElementById("date").value;        var choose = new Date(v);        var chooseYear = choose.getFullYear();        var chooseMonth = choose.getMonth() + 1;        var chooseDay = choose.getDate();        var cha = currentYear - chooseYear;        // var cha = (current.getTime() - choose.getTime()) / 1000 / 60 / 60 / 24 / 365;        // var cha=parseInt(cha);        // var lit = cha - intCha;        // alert(cha)        // if(intCha==3){        // }        var realYear = (current.getTime() - choose.getTime()) / 1000 / 60 / 60 / 24 / 365;        if (cha <= 0 ) {            alert("入职不满一年！")        } else if (cha == 1 || cha == 2) {//1-2年 3天年假            //计算天数            if(realYear < 1){                alert("入职不满一年：" + realYear )            }else{            alert("入职满" + cha + "年！有3天年假")            }        } else if (cha == 3) { //3年以上5天年假            if (realYear > 3) {//真满3年                var startDate = currentYear + "-01-01";                var endDate = currentYear + "-" + chooseMonth + "-" + chooseDay;                var chaDay = (new Date(endDate).getTime() - new Date(startDate).getTime()) / 1000 / 60 / 60 / 24;                var allDay = 3 * chaDay / 365 + 5 * (365 - chaDay) / 365;                alert("入职满" + cha + "年！" + allDay)            } else {                alert("入职满" + realYear + "年！有3天年假")            }        } else if (cha == 4 || cha == 5 || cha >= 6) {            alert("入职满" + cha + "年！有5天年假")        }        // alert(v + "\n" + currentDate);    }</script><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","model":{"scale":1,"hHeadPos":0.5,"vHeadPos":0.618,"jsonPath":"/live2dw/assets/shizuku.model.json"},"display":{"superSample":2,"width":150,"height":300,"position":"left","hOffset":0,"vOffset":-20},"mobile":{"show":false,"scale":0.5},"react":{"opacityDefault":0.7,"opacityOnHover":0.2},"log":false,"tagMode":false});</script></body>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;计算工具&quot;&gt;&lt;a href=&quot;#计算工具&quot; class=&quot;headerlink&quot; title=&quot;计算工具&quot;&gt;&lt;/a&gt;计算工具&lt;/h2&gt;&lt;h3 id=&quot;——————————————————————&quot;&gt;&lt;a href=&quot;#——————————————————————&quot;
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Android唯一识别码 获取</title>
    <link href="http://zhangyongfa888.site/2019/08/28/Android%E5%94%AF%E4%B8%80%E8%AF%86%E5%88%AB%E7%A0%81-%E8%8E%B7%E5%8F%96/"/>
    <id>http://zhangyongfa888.site/2019/08/28/Android唯一识别码-获取/</id>
    <published>2019-08-28T03:52:00.000Z</published>
    <updated>2019-09-03T00:21:58.737Z</updated>
    
    <content type="html"><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>目前有个需求，需要获取设备的唯一识别码 标记用户的手机,在android低版本上很好实现，imei或者deviceID之间能够拿到，但是android10已经不给此项权限了……于是开始找资料。</p><h3 id="不可重置的设备标识符-：官（墙）方（外）推荐方法"><a href="#不可重置的设备标识符-：官（墙）方（外）推荐方法" class="headerlink" title="不可重置的设备标识符 ：官（墙）方（外）推荐方法"></a>不可重置的设备标识符 ：官（墙）方（外）推荐方法</h3><p>从 Android Q 开始，应用必须具有 <strong>READ_PRIVILEGED_PHONE_STATE</strong> 特许权限才能访问设备的不可重置标识符（包含 IMEI 和序列号）。许多用例不需要不可重置的设备标识符。如果您的应用没有该权限，但您仍尝试查询标识符的相关信息，则平台的响应会因目标 SDK 版本而异：</p><p>如果应用以 <strong>Android Q</strong> 为目标平台，则会发生 <strong>SecurityException</strong>。<br>如果应用以 Android 9（API 级别 28）或更低版本为目标平台，则相应方法会返回 null 或占位符数据（如果应用具有 <strong>READ_PHONE_STATE</strong> 权限）。否则，会发生 <strong>SecurityException</strong>。<br>注意：如果您的应用是设备所有者或配置文件所有者应用，那么即使您的应用以 Android Q 为目标平台，您也只需 <strong>READ_PHONE_STATE</strong> 权限即可访问不可重置的设备标识符。此外，如果您的应用具有特殊运营商权限，则无需任何权限即可访问这些标识符。<br>如果您的应用将不可重置的设备标识符用于广告跟踪或用户分析目的，请为这些特定用例创建 Android 广告 ID。要了解详情，请参阅唯一标识符的最佳做法。<a href="https://developer.android.google.cn/training/articles/user-data-ids" target="_blank" rel="noopener">https://developer.android.google.cn/training/articles/user-data-ids</a></p><p>另一篇文章有讲解如何获取广告id :<a href="https://www.jianshu.com/p/33cfb817a077" target="_blank" rel="noopener">Google Advertising Id 获取</a></p><p>但是还需要注册谷歌开发者 申请谷歌广告的id</p><pre><code>The Google Mobile Ads SDK was initialized incorrectly. AdMob publishers    should follow the instructions here:                                   https://googlemobileadssdk.page.link/admob-android-update-manifest         to add a valid App ID inside the AndroidManifest.                         Google Ad Manager publishers should follow instructions here:              https://googlemobileadssdk.page.link/ad-manager-android-update-manifest.  </code></pre><p>最后放弃了~</p><h3 id="国内-设备获取设备标识符"><a href="#国内-设备获取设备标识符" class="headerlink" title="国内 设备获取设备标识符"></a>国内 设备获取设备标识符</h3><p><a href="https://www.tc260.org.cn" target="_blank" rel="noopener">全国信息安全标准化技术委员会</a>  有<a href="https://www.tc260.org.cn/front/postDetail.html?id=20190808111821" target="_blank" rel="noopener">《信息安全技术 移动互联网应用（App）收集个人信息基本规范（草案）》，</a> 规定了地图导航、网络约车、即时通讯、博客论坛、网络支付、新闻资讯、网上 购物等 21 种常用服务类型可收集的最少信息。</p><h5 id="App-收集个人信息基本要求"><a href="#App-收集个人信息基本要求" class="headerlink" title="App 收集个人信息基本要求"></a>App 收集个人信息基本要求</h5><h6 id="管理要求"><a href="#管理要求" class="headerlink" title="管理要求"></a>管理要求</h6><p>App收集个人信息应满足以下管理要求：</p><ul><li>a） App 运营者应履行个人信息保护义务，采取必要安全措施，保障用户个人信息安全。</li><li>b） 当用户同意 App 收集某服务类型的最少信息时，App 不得因用户拒绝提供最少信息 之外的个人信息而拒绝提供该类型服务。 注：附录 A 列举了 App 常见的服务类型以及服务类型对应的最少信息。 </li><li>c） App 不得收集与所提供的服务无关的个人信息。 </li><li>d） 对外共享、转让个人信息前，App 应事先征得用户明示同意。当用户不同意, 则不 得对外共享、转让用户个人信息。</li><li>e） App 不得收集不可变更的设备唯一标识（如 IMEI 号、MAC 地址等） ，用于保障网络 安全或运营安全的除外。</li><li>f） 用户明确拒绝使用某服务类型后，App 不得频繁（如每 48 小时超过一次）征求用 户同意使用该类型服务，并保证其他服务类型正常使用。</li><li>g） App 应对其使用的第三方代码、插件的个人信息收集行为负责。第三方代码、插件 收集个人信息视同 App 收集，App 应防止第三方代码、插件收集无关的个人信息。 注：如第三方代码、插件自行向用户明示其收集、使用个人信息的目的、方式、范围，并征得用户同意，则第三方代码、插件独立对其个人信息收集行为承担责任。</li></ul><h6 id="技术要求"><a href="#技术要求" class="headerlink" title="技术要求"></a>技术要求</h6><p>App收集个人信息应满足以下技术要求：</p><ul><li>a） 当收集的个人信息超出服务类型的最少信息时，超出部分的个人信息，App 应逐项 征得用户明示同意。</li><li>b） 当同一 App 有 2 种或 2 种以上服务类型时，App 应允许用户逐项开启和退出服务类 型，开启或退出的方式应易于操作。</li><li>c） 当用户退出某服务类型后，App 应终止该服务类型收集个人信息的活动，并对仅用 于该服务的个人信息进行删除或匿名化处理。</li><li>d） 当申请个人信息相关权限或要求用户输入个人信息时，App 应向用户同步明示申请 权限或收集信息的目的。</li><li>e） App 应向用户提供实时查询已收集个人信息类型的功能；查询结果应以独立界面展 示，且查询方式应易于操作。</li><li>f） 存在对外共享、转让个人信息的，App 应向用户提供查询数据接收方身份的功能； 查询结果应以独立界面展示，且查询方式应易于操作。 </li><li>g） 在技术可行且不影响终端和服务正常的情况下，App 应优先在用户终端中存储、使 用所收集的个人信息。 </li><li>h） App 应以实现服务所必需的最低合理频率向后台服务器发送个人信息。</li></ul><p><strong>所以这么严格，相关部门肯定会有一个规范来统一下发或者管理手机的唯一识别码，来达到“监管”用户的操作</strong></p><h2 id="规范来了"><a href="#规范来了" class="headerlink" title="规范来了~"></a>规范来了<del>~</del></h2><h1 id="移动智能终端补充设备标识体系"><a href="#移动智能终端补充设备标识体系" class="headerlink" title="移动智能终端补充设备标识体系"></a>移动智能终端补充设备标识体系</h1><h4 id="移动安全联盟"><a href="#移动安全联盟" class="headerlink" title="移动安全联盟"></a><a href="http://www.msa-alliance.cn/" target="_blank" rel="noopener">移动安全联盟</a></h4><h6 id="移动安全联盟-Mobile-Security-Alliance，简称MSA-于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。"><a href="#移动安全联盟-Mobile-Security-Alliance，简称MSA-于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。" class="headerlink" title="移动安全联盟(Mobile Security Alliance，简称MSA)于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。"></a>移动安全联盟(Mobile Security Alliance，简称MSA)于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。</h6><p>由各大手机厂商”共同维护”来进行统一、规范化唯一识别码，目前包括的手机厂商有</p><table><thead><tr><th>厂商</th><th>版本</th></tr></thead><tbody><tr><td>小米</td><td>MIUI10.2 及以上</td></tr><tr><td>vivo</td><td>FuntouchOS 9 及以上</td></tr><tr><td>华为</td><td>全版本</td></tr><tr><td>OPPO</td><td>Color OS 7.0 及以上（9 月份正式支持）</td></tr><tr><td>Lenovo</td><td>ZUI 11.4 及以上（9 月中旬正式支持）</td></tr></tbody></table><h4 id="体系说明"><a href="#体系说明" class="headerlink" title="体系说明"></a>体系说明</h4><p>移动智能终端补充设备标识体系架构共涉及四类实体，包括开发者、开发者开发的应用软件、移动智能终端设备的操作系统、用户及用户使用的设备。为保护用户用户的隐私和标识设备的唯一性，根据不同使用对象和不同用途，基于移动智能终端设备，分别生成设备唯一标识符、匿名设备标识符、开发者匿名设备标识符和应用匿名设备标识符，将这四个设备标识符构成补充设备标识体系。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/1566971512579e8ffjhsp.png?imageslim" alt="体系图" title>                </div>                <div class="image-caption">体系图</div>            </figure><p>唯一标识符作为普通用户仍然是拿不到，但是能够替代的，我们可以用其他的id,</p><ul><li>OAID 可与用户数据、账号绑定 用于个性化推荐、广告业务。</li><li>VAID 多应用之间能够共享的唯一标识，同一个开发者多个应用可以使用，举个例子：司机端和货主端 ，货主端发货刷单，司机端抢单时候可以用vaid判断，是否是同一台设备；缺点是必须是该手机平台的线上应用才能统计到是否是同一个开发者账号下的app,部分厂商，若应用未在其开发者平台后台上架，则认定未非法应用，无 法生成 VAID，手机 LOG 中将会有相关异常值输出。 </li><li>AAID 单个app用于用户统计等，没有VAID的需求情况下 可以使用。</li></ul><p>目前移动安全联盟 仍在免费注册阶段，还没有收费制服。作为旁观者，还是尽早注册，毕竟中国的手机市场很大，而且如上的通过谷歌广告的形式获取唯一识别码走不通，利润可想而知。</p><h5 id="相关连接"><a href="#相关连接" class="headerlink" title="相关连接"></a>相关连接</h5><p><a href="http://www.msa-alliance.cn/" target="_blank" rel="noopener">移动安全联盟</a></p><p><a href="https://www.tc260.org.cn" target="_blank" rel="noopener">全国信息安全标准化技术委员会</a></p><p><a href="https://developer.android.google.cn/preview/privacy/data-identifiers#device-ids" target="_blank" rel="noopener">谷歌官方文档</a></p><p><a href="https://dev.mi.com/console/doc/detail?pId=1821" target="_blank" rel="noopener">小米设备标识体系的说明</a></p><p><a href="https://www.jianshu.com/p/33cfb817a077" target="_blank" rel="noopener">Google Advertising Id 获取</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;目前有个需求，需要获取设备的唯一识别码 标记用户的手机,在android低版本上很好实现，imei或者deviceID之间能够拿到，但是an
      
    
    </summary>
    
      <category term="Android" scheme="http://zhangyongfa888.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhangyongfa888.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Awesome-android-tips</title>
    <link href="http://zhangyongfa888.site/2019/08/23/Awesome-android-tips/"/>
    <id>http://zhangyongfa888.site/2019/08/23/Awesome-android-tips/</id>
    <published>2019-08-23T07:20:00.000Z</published>
    <updated>2019-09-03T00:22:08.973Z</updated>
    
    <content type="html"><![CDATA[<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/title.png" alt title>                </div>                <div class="image-caption"></div>            </figure> <br><br><p><a href="https://github.com/jiang111/awesome-android-tips" target="_blank" rel="noopener"><img src="https://jiang111.github.io/images/awesome.svg" alt="jiang111/image"></a>   <a href="https://juejin.im/entry/57ad3f87c4c9710054687895/detail" target="_blank" rel="noopener"><img src="https://badge.juejin.im/entry/57ad3f87c4c9710054687895/likes.svg?style=plastic" alt></a><br><br></p><p>EnglishVersion -&gt;_-&gt;:<a href="https://github.com/jiang111/awesome-android-tips/blob/master/README-en.md" target="_blank" rel="noopener">https://github.com/jiang111/awesome-android-tips/blob/master/README-en.md</a></p><p>值得收藏的AS插件 -&gt;_-&gt;:<a href="https://github.com/jiang111/awesome-androidstudio-plugins" target="_blank" rel="noopener">https://github.com/jiang111/awesome-androidstudio-plugins</a> <br></p><p>这里收集了大家常用的一些Android代码,持续更新中,内容来自自己的平时积累和网络上看到的文章，部分原文地址在最下方。如有错误欢迎指正,如有侵权,请联系我删除。里面可能会有重复内容,请忽略或者提醒我删除。<br><br></p><h1 id><a href="#" class="headerlink" title></a><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/toc.png" alt="Table of Contents" title>                </div>                <div class="image-caption">Table of Contents</div>            </figure></h1><ul><li><p>setBackgroundResource(0) 可以移除 View 的背景色</p></li><li><p>Resources.getSystem().getDisplayMetrics().density 可以不用 Context 也能获取屏幕密度哦</p></li><li><p>通过重载 ViewGroup 的 dispatchDraw 可以实现一个简单的蒙版效果。 例如下拉刷新时，可以在 contentView 上加一层遮罩。 canvas.drawRect(0, mContentView.getTranslationY(), getWidth(), getHeight(), mMaskPaint);</p></li><li><p>new 出来的 View 可以用 View.generateViewId() （API 17 以上可用）   生成 id，系统保证唯一</p></li><li><p>使用 GridView时 android:padding 和 android:clipToPadding=”false” 配合使用效果更好哦。</p></li><li><p>在布局文件中，如果只是为了占位，可以用 Space 来取代 View。 最棒的一点是Space可以跳过 Draw 这个过程。</p></li><li><p>TypedValue.applyDimension(int unit, float value, DisplayMetrics metrics) 方便dp, px, sp 之间的转换。</p></li><li><p>Activity.startActivities() 这个方法最直接的理解就是使用intent开启多个Activity</p></li><li><p>TextUtils.isEmpty() 如果传入的String 为NULL或者Length为0的话就返回 true。</p></li><li><p>Html.fromHtml() 如果你对Html熟悉的话，可以很迅速通过这个方法处理一些富文本操作。比如超链接和图文排版等处理。</p></li><li><p>TextView.setError() 设置文本框错误提醒</p></li><li><p>Build.VERSION_CODES 有些时候我们的app需要根据不同的SDK版本进行执行不同的操作</p></li><li><p>PhoneNumberUtils.convertKeypadLettersToDigits 这个方法简单粗暴，会将输入的字母根据键盘上的映射转换为数字。</p></li><li><p>ArgbEvaluator ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。</p></li><li><p>ValueAnimator.reverse() 顺畅的取消动画效果</p></li><li><p>DateUtils.formatDateTime()) 这个方法可以输出相应格式化的时间或者日期</p></li></ul><ul><li><p>Pair 这个类 可以用来存储存储一”组”数据。但不是key和value的关系。</p></li><li><p>SparseArray 目前有很多地方从性能优化方说使用SparseArray来替换hashMap，来节省内存，提高性能。</p></li><li><p>Linkify.addLinks() 这个类可以更方便的为文本添加超链接。</p></li><li><p>android.media.ThumbnailUtils这个类主要是用来处理缩略图相关的工作,比如:用来获取媒体（图片、视频）的缩略图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">createVideoThumbnail(String filePath, int kind)</span><br><span class="line">extractThumbnail(Bitmap source, int width, int height)</span><br></pre></td></tr></table></figure></li><li><p>Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas和Paint可以动态的修改一个纯色Bitmap的颜色。</p></li><li><p>模块间有消息需要传递时，使用LocalBroadcastManager替代Listener进行模块解耦。除了解耦，这样发送消息和执行消息差一个线程循环，可以减小方法的调用链，我这就碰到一次方法调用链太长导致StackOverflow的问题。</p></li><li><p>静态变量不要直接或者间接引用Activity、Service等。这会使用Activity以及它所引用的所有对象无法释放，然后，用户操作时间一长，内存就会狂升。</p></li><li><p>Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，可能会造成内存泄露,所以可以在 onDestory() 的时候调用removeCallbacksAndMessages来移除这个Handler所对应等待执行的message。</p></li><li><p>不少人在子线程中更新View时喜欢使用Context.runOnUiThread，这个方法有个缺点，就是一但Context生命周期结束，比如Activity已经销毁时，一调用就会崩溃。</p></li><li><p>SharedPreferences.Editor.commit这个方法是同步的，一直到把数据同步到Flash上面之后才会返回，由IO操作的不可控，尽量使用apply方法代替。apply只在API Level&gt;=9才会支持，需要做兼容。不过，最新的 <code>support v4</code> 包已经为我们做好了处理，使用  <code>SharedPreferencesCompat.EditorCompat.getInstance().apply(editor)</code> 即可。</p></li><li><p>PackageManager.getInstalledPackages这个方法经常使用，你可能不知道，当获取的结果数量比较多的时候，在某些机型上面调用它花费的时间可能秒级的，所以尽量在子线程中使用。另外，如果结果太多，超过系统设置的Binder数据最大传输量的上限，则会发生TransactionException，如果你使用这个方法获取机器上的己安装应用列表，最好做一下预防。</p></li><li><p>如果使用Context.startActivity启动外部应用，最好做一下异常预防，因为寻找不到对应的应用时，会抛出异常。如果你要打开的是应用内的Activity，不防使用显式Intent，这样能提高系统搜索目标Activity的效率。</p></li><li><p>Application的生命周期就是进程的生命周期。只有进程被干掉时，Application才会销毁。哪怕是没有Activity、Service在运行，Application也会存在。所以，为了减少内存压力，尽量不要在Application里面引用大对象、Context等。</p></li><li><p>设置全屏方法有2种:1.通过代码设置，2通过manifest文件设置。用代码设置全屏时app在我们应用运行后，可能会看到短暂的状态栏，然后才全屏，而第二种方法是不会有这种情况的,所以推荐第二种。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//方法1: </span><br><span class="line">//无title   </span><br><span class="line">requestWindowFeature(Window.FEATURE_NO_TITLE);    </span><br><span class="line">getWindow().setFlags(WindowManager.LayoutParams. FLAG_FULLSCREEN,WindowManager.LayoutParams. FLAG_FULLSCREEN);   </span><br><span class="line">//必须在setContentView()之前调用</span><br><span class="line">setContentView(R.layout.main);  </span><br><span class="line">//方法2:</span><br><span class="line">&lt;activity android:name=&quot;.&quot; </span><br><span class="line">    android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; //全屏主题</span><br><span class="line">    android:label=&quot;@string/app_name&quot; /&gt;</span><br></pre></td></tr></table></figure></li><li><p>viewpager 的 setCurrentItem 一定要在 setAdapter 方法之后调用才会有效果.</p></li><li><p>判断手机是不是飞行模式  boolean isEnabled = Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) == 1;</p></li><li><p>TabLayout 修改字体的方法<br>官方的 TabLayout 没有提供修改 TextView size 的方法，可以新建一个 style CustomTabLayoutTextAppearance 继承 TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse ，然后增加 item ，设置 android:textAllCaps 为 true ，再设置 android:textSize 为你想设置的大小。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/custom_style1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><p>再在 TabLayout 的布局文件里设置 app:tabTextAppearance=”@style/CustomTabLayoutTextAppearance” 即可。</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/custom_style2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>遍历HashMap的最佳方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printMap</span><span class="params">(Map mp)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (Map.Entry m : mp.entrySet()) &#123;</span><br><span class="line">            System.out.println(m.getKey() + <span class="string">":"</span> + m.getValue());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用Java在一个区间内产生随机整数数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">randInt</span><span class="params">(<span class="keyword">int</span> min, <span class="keyword">int</span> max)</span> </span>&#123;</span><br><span class="line">    Random rand = <span class="keyword">new</span> Random();</span><br><span class="line">    <span class="keyword">int</span> randomNum = rand.nextInt((max - min) + <span class="number">1</span>) + min;</span><br><span class="line">    <span class="keyword">return</span> randomNum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。</p></li><li><p>transient关键字修饰变量可以限制序列化。</p></li><li><p>当使用JakeWharton的TabPageIndicator时，如果需要先做一些耗时的操作，然后再展示TabPageIndicator的话，需要先设置mIndirector.setVisibility(View.GONE);然后耗时任务结束以后再mIndirector.setVisibility(View.VISIBLE);否则会报错</p></li><li><p>类继承之间的调用顺序 父类static成员 -&gt; 子类static成员 -&gt; 父类普通成员初始化和初始化块 -&gt; 父类构造方法 -&gt; 子类普通成员初始化和初始化块 -&gt; 子类构造方法</p></li><li><p>华为手机无法显示log解决方案,.拨号界面输入(*#*#2846579#*#*) Service menu will appear.Go to “ProjectMenu” -&gt; “Background Setting” -&gt; “Log Setting”Open “Log switch” and set it to ON.Open “Log level setting” and set the log level you wish.</p></li><li><p>后台service经常因为重启之类的出现onStartCommand()中的Intent传递的参数为null， 通过在onStartCommand()中的返回值改成return super.onStartCommand(intent, Service.START_REDELIVER_INTENT, startId); 可以解决问题。下面介绍几个flag的意思<br></p></li><li><table><thead><tr><th>flag</th><th align="center">解释</th></tr></thead><tbody><tr><td>START_STICKY</td><td align="center">如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。</td></tr><tr><td>START_NOT_STICKY</td><td align="center">“非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。</td></tr><tr><td>START_REDELIVER_INTENT</td><td align="center">重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。</td></tr><tr><td>START_STICKY_COMPATIBILITY</td><td align="center">START_STICKY的兼容版本，但不保证服务被kill后一定能重启。</td></tr></tbody></table></li><li><p>不能在Activity没有完全显示时显示PopupWindow和Dialog</p></li><li><p>在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定</p></li><li><p>有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/context_usage.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li></ul><blockquote><p>*备注：大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释：</p><ol><li>数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task，一般情况不推荐；</li><li>数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用；</li><li>数字3：在Receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）；</li><li>ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。</li></ol></blockquote><ul><li><p>谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感</p></li><li><p>不要在非UI线程中初始化ViewStub，否则会返回null</p></li><li><p>尽量不要通过Application缓存数据，这不稳定</p></li><li><p>华为手机无法打开USB调试的问题，</p></li></ul><ol><li>插好数据线,拨号界面 输入 <em>#</em>#2846579#<em>#</em> 进入工程模式</li><li>projectmenu→3后台设置→4USB端口配置→Balong调试模式,点确定</li><li>不要拔线,退出工程模式,直接重启手机,电脑中显示可移动磁盘(若仍未出现,重复步骤1、2)</li><li>这个是关闭USB调试的情况下电脑中使用手机的可移动磁盘的方法，使用后下拉菜单中usb选项也回来了。</li></ol><ul><li><p>android listview中的消息被软键盘遮挡了,在设置listview的时候加上android:transcriptMode=”normal”就好了</p></li><li><p>TextUtils 是一个非常好用的工具类，把 List<string> 转成字符串，逗号分隔，逗号分隔的 String 字符串，切割成 List<string> ，分别可以用 TextUtils 的 join 和 split 方法。如果要对 List 去重，则可以用 Collection 的 frequency 方法。</string></string></p></li><li><p>在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。</p></li><li><p>activity中的runOnUiThrea(Runnable action)方法可以直接回到主线程</p></li><li><p>listview有个footerDividersEnabled和headerDividersEnabled方法可以设置listview的顶部和底部divide，但是必须保证你设置了headview和footview才会有效果</p></li><li><p>Throwable类中的getStackTrace()方法，根据这个方法可以得到函数的逐层调用地址，其返回值为StackTraceElement[]；</p></li><li><p>StackTraceElement类，其中四个方法getClassName()，getFileName()，getLineNumber()，getMethodName()在调试程序打印Log时非常有用；</p></li><li><p>UncaughtExceptionHandler接口，再好的代码异常难免，利用此接口可以对未捕获的异常善后</p></li><li><p>Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到；</p></li><li><p>view的isShown方法，只有当view本身以及它的所有祖先们都是visible时，isShown（）才返回TRUE。而平常我们调用if(view.getVisibility() == View.VISIBLE)只是对view本身而不对祖先的可见性进行判断。</p></li><li><p>Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等；Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等；</p></li><li><p>TextView类中的append(CharSequence)方法，添加文本。一些特殊文本直接用+连接会变成String；</p></li><li><p>System类中的arraycopy(src, srcPos, dest, destPos, length)方法，用来copy数组；</p></li><li><p>Fragment类中的onHiddenChanged(boolean)方法，使用FragmentTransaction中的hide()，show()时只会调用Fragment中的show和hidden状态,其他生命周期不会调用。</p></li><li><p>Activity类中的onWindowFocusChanged(boolean)，onNewIntent(intent)等回调方法；</p></li><li><p>TextView类中的setTransformationMethod(TransformationMethod)方法，可用来实现“显示密码”功能</p></li><li><p>PageTransformer接口，用来自定义ViewPager页面切换动画，用setPageTransformer(boolean, PageTransformer)方法来进行设置；</p></li><li><p>apache提供的一系列jar包：commons-lang.jar，commons-collections.jar，commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……；</p></li><li><p>ActivityLifecycleCallbacks接口，用于在Application类中监听各Activity的状态变化 <a href="http://mp.weixin.qq.com/s?__biz=MzA3ODkzNzM3NQ==&mid=401277907&idx=1&sn=0b2246f5178292596fc3a8295283359c#rd" target="_blank" rel="noopener">阅读地址点我</a></p></li><li><p>ActionBar.hide()/.show() 顾名思义，隐藏和显示ActionBar，可以优雅地在全屏和带Actionbar之间转换。</p></li><li><p>SystemClock.sleep() 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。</p></li><li><p>UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。</p></li><li><p>ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。</p></li><li><p>getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。</p></li><li><p>HandlerThread，代替不停new Thread开子线程的重复体力写法。</p></li><li><p>IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service</p></li><li><p>Executors. newSingleThreadExecutor();这个是java的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列 </p></li><li><p>android:animateLayoutChanges=”true”，LinearLayout中添加View的动画的办法，支持通过setLayoutTransition()自定义动画。</p></li><li><p>AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常..</p></li><li><p>ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。</p></li><li><p>android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value</p></li><li><p>android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants” </p></li><li><p>includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。</p></li><li><p>Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。 </p></li><li><p>EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿) </p></li><li><p>java8中新增的LocalDate和LocalTime接口，Date虽然是个万能接口，但是它真的不好用，有了这俩，终于可以愉快的处理日期时间了。</p></li><li><p>WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。</p></li><li><p>使用SnackBar的时候，不要使用view.getRootView()作为snackbar的view,华为荣耀7 会出问题。</p></li><li><p>设置TextView单行显示的时候不要用Lines=1,而要用singleLine=”true” ,因为魅族部分手机在设置Lines=1的时候，然后TextView的值全为数字的时候， 你就会懵逼了.</p></li><li><p>TouchDelegate可用于更改View的触摸区域。场景：比如在RecyclerView的ItemView里包含了CheckBox组件, 然后想实现点击ItemView的时候，也可以触发CheckBox，就可以使用此类</p></li><li><p>ArgbEvaluator可用于计算不同颜色值之间的插值，配合ValueAnimator.ofObject或者ViewPager.PageTransformer使用，可以实现不同颜色之间的平滑过渡。</p></li><li><p>Palette可用于提取一张图片的颜色。</p></li><li><p>ViewDragHelper,做过自定义ViewGroup的童鞋都应该知道这个东西吧，用来处理触摸事件的神器，妈妈再也不用担心我自定义控件了。</p></li><li><p>PageTransformer用于定义ViewPager页面切换时的动画效果（淡入淡出，放大缩小神马的…）官方有例子，直接看吧。</p></li><li><p>Formatter.formatFileSize() 这个方法会格式化数据的大小，根据输入的字节大小，返回 B KB MB GB 等等（最大支持到 PB）。当然要注意的是输入的最大值是 Long.MAX_VALUE.</p></li><li><p>Activity.recreate重新创建Activity。有什么用呢？可以在程序更换主题后，立马刷新当前Activity，而不会有明显的重启Activity的动画。</p></li><li><p>View.getContext顾名思义，就不用解释了吧…以前在写RecyclerView的Adapter的时候，为了使用LayoutInflater，经常傻乎乎地在构造函数中传入一个外部的context….是不是只有我不知道而已（笑cry脸）</p></li><li><p>View.post方便在非UI线程对界面进行修改，与Handler的作用类似。并且由于post的Runnable会保证在该View绘制完成的前提下才调用，所以一般也可以用于获取View的宽高。</p></li><li><p>Activity.runOnUiThread与View.post类似，方便在非UI线程中对界面进行修改。</p></li><li><p>Fragment在配合PagerAdapter使用的时候可以重写setUserVisibleHintFragment()方法，然后根据参数的布尔值（true的话表示当前Fragment对用户可见),来执行一些逻辑。</p></li><li><p>android:animateLayoutChanges 这是一个非常酷炫的属性。在父布局加上 android:animateLayoutChanges=”true” 后，如果触发了layout方法（比如它的子View设置为GONE），系统就会自动帮你加上布局改变时的动画特效！！</p></li><li><p>android:clipToPadding 设置父view是否允许其子view在它的padding（这里指的是父View的padding）中绘制。是不是有点绕？举个实际场景吧：假如有个ListView，我们想要在初始位置时，第一项Item离顶部有10dp的距离，就可以在ListView的布局中加入android:clipToPadding=”false” android:paddingTop=”10dp”即可。是不是很方便呢？</p></li><li><p>rv 的 Layoutmanager 可以直接申明在 xml 中,具体代码可查看RecyclerView.createLayoutManager 方法.</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/recycler_1.jpeg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/recycler_2.jpeg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>RecyclerView在23.2.+的版本中新增了自动测量的功能，由于新增了自动测量，那么它的item的根布局在需要测量的方向上就不能写match_parent了，需要改成wrap_content</p></li><li><p>getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。</p></li><li><p>Canvas中clipRect、clipPath和clipRegion剪切区域的API。</p></li><li><p>GradientDrawable 有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！</p></li><li><p>有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过&lt;application android:hardwareAccelerated=”false” …&gt;，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。</p></li><li><p>PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。</p></li><li><p>StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable来完成了，各种addState即可。</p></li><li><p>android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。</p></li><li><p>ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。</p></li><li><p>ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。</p></li><li><p>onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。</p></li><li><p>TextView.setCompoundDrawablePadding，代码设置TextView的drawable padding。</p></li><li><p>ImageSwitcher，可以用来做图片切换的一个类，类似于幻灯片。</p></li><li><p>在自定义控件的时候,能用drawable来绘制圆，或者其他样式的时候,尽量用drawable,因为drawable的效果要远胜于canvas.drawXXX().</p></li><li><p>如果想要自定义View支持SwipeRefreshLayout，只需要声明并实现ScrollingView接口即可，RecyclerView和NestedScrollView已经实现此接口。</p></li><li><p>AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。</p></li><li><p>DatabaseUtils——一个包含各种数据库操作的使用工具。</p></li><li><p>Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。</p></li><li><p>SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。</p></li><li><p>android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。</p></li><li><p>android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。</p></li><li><p>android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。</p></li><li><p>android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。</p></li><li><p>Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck!</p></li><li><p>使用RenderScript虚化图片效果。如果你的app的minSDK为16或者更低，你需要使用support模式，因为很多方法都是在API 17之后添加的。renderscriptTargetApi最高到23，但是你应该把它设置到能保持脚本中使用到的功能完整的最低API。如果你想在support模式下target API 21+你必须使用gradle-plugin 2.1.0 和 buildToolsVersion “23.0.3” 或者以上。需要在gradle中添加renderscriptTargetApi 18,renderscriptSupportModeEnabled true 这两句话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">blurBitmap</span><span class="params">(Context context, Bitmap src, <span class="keyword">int</span> radius)</span> </span>&#123;</span><br><span class="line">        Bitmap dest = src.copy(src.getConfig(), <span class="keyword">true</span>);</span><br><span class="line">        RenderScript rs = RenderScript.create(context);</span><br><span class="line">        Allocation allocation = Allocation.createFromBitmap(rs, src);</span><br><span class="line">        Type t = allocation.getType();</span><br><span class="line">        Allocation blurredAllocation = Allocation.createTyped(rs, t);</span><br><span class="line">        ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs));</span><br><span class="line">        blurScript.setRadius(radius);</span><br><span class="line">        blurScript.setInput(allocation);</span><br><span class="line">        blurScript.forEach(blurredAllocation);</span><br><span class="line">        blurredAllocation.copyTo(dest);</span><br><span class="line">        allocation.destroy();</span><br><span class="line">        blurredAllocation.destroy();</span><br><span class="line">        blurScript.destroy();</span><br><span class="line">        t.destroy();</span><br><span class="line">        rs.destroy();</span><br><span class="line">        <span class="keyword">return</span> dest;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>如果想把一个view保存为Bitmap，正常情况下用第一种方法就可以了，但是如果是ScrollView，则必须采用第二种方法。 <br></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/capture_view_1.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/capture_view_2.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>当Activity LauncherMode 为singleTask singleInstance时,使用startActivityForResult会立马返回，不能正常调用。具体请看<a href="http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml" target="_blank" rel="noopener">http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml</a></p></li><li><p>当PopupWindow中有EditText控件时,因为Popupwindow 默认没有获取到焦点，需要手动设置焦点，这样子view才能获取到事件的监听。所以你需要在创建完popwindow后设置他的焦点，popupWindow.setFocusable(true);就可以让EditText获取焦点。</p></li><li><p>PopupWindow默认点击外部的时候不消失，需要对PopupWindow 设置一个背景图popWindow.setBackgroundDrawable(new BitmapDrawable());要创建一个空对象，设置为null是不行的，或者就创建一个全透明的背景图。</p></li><li><p>android中的序列化官方推荐Parceble,其实Parceble最好用于内存之间数据的交换,如果要把数据写入硬盘的话,推荐实现Serializable</p></li><li><p>tools标签可以很好的帮助开发者实时预览xml的效果,通过tools:background可以预览控件所占的控件,tools:visibility可以把一个gone的控件在预览的时候展示出来,并且运行以后tools标签的内容不会展示出来.例如:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">TextView</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">"match_parent"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">"wrap_content"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:background</span>=<span class="string">"#FF00FF"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:visibility</span>=<span class="string">"visible"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">tools:text</span>=<span class="string">"这段话只在预览时能看到,运行以后就看不到了"</span> /&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>android studio 2.1起已经支持jdk8了,使用的时候要在gradle中加上,需要把buildToolsVersion更新到24以上的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">    ...</span><br><span class="line">            jackOptions &#123;</span><br><span class="line">                enabled true</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">   ...</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        targetCompatibility 1.8</span><br><span class="line">        sourceCompatibility 1.8</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>6.0之后getResources().getColor()方法被废弃了，大家可以用ContextCompat.getColor(context, R.color.color_name)替换，ContextCompat 是 v4 包里的，请放心使用，另外还有getDrawable()等方法</p></li><li><p>图片的资源文件官方推荐只把launcher放在mipmap文件夹下面，而app用到的资源文件建议放在drawable下面。</p></li><li><p>SharedPreference.Editor的apply是异步操作，不会返回成功的状态，而commit是同步操作，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后再操作下一个数据，从而降低了效率。</p></li><li><p>如果你在 manifest 中把一个 activity 设置成 android:windowSoftInputMode=”adjustResize”，那么 ScrollView（或者其它可伸缩的 ViewGroups）会缩小，从而为软键盘腾出空间。但是，如果你在 activity 的主题中设置了 android:windowFullscreen=”true”，那么 ScrollView 不会缩小。这是因为该属性强制 ScrollView 全屏显示。然而在主题中设置 android:fitsSystemWindows=”false” 也会导致 adjustResize 不起作用</p></li><li><p>在Android 4.0以后，在Manifest.xml中静态注册的广播，程序安装后必须启动一次才能接收到广播，比如你的应用监听开机启动的广播，必须要你的程序被运行过才能监听到</p></li><li><p>Activity的onDestory方法调用时机是不确定的（有时候离开界面很久之后才会调用onDestory方法），应该避免指望通过onDestory方法去释放与Activity相关的资源，否则会导致一些随机bug</p></li><li><p>2.X时代Bitmap对象虽然存储在堆内存中，但是用了一个byte数组存储其像素信息。通过计数器来记录该像素信息被引用的个数。有人认为这个byte数组在native堆中，但事实上它也在堆中。只有在使用者调用recycle()后，Bitmap对象才会释放像素信息，才会在失去引用后被垃圾回收机制销毁。再加上DVM的heap size有严格的阀值，所以在使用大量图片资源的时候，及其容易发生OOM。解决办法一般都是，用一个哈希表存储Bitmap对象的软引用，作为内存缓存，并在适当时机掉用其recycle()。3.0以上版本Bitmap对象可以通过垃圾回收机制完全销毁，理论上不用再调用recycle()。</p></li><li><p>.gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git rm -r --cached .</span><br><span class="line">git add .</span><br><span class="line">git commit -m &apos;update .gitignore&apos;</span><br></pre></td></tr></table></figure></li><li><p>时间戳请使用long或者String类型接收，遇到的坑,由于项目中的model好多都是通过GsonFormat生成的，服务器给的json中的时间戳都是10位的，导致了GsonFormat自动解析成了int, 当测试人员选择时间为2100年的时候时间戳是4开头的十位 用int类型接收越界了,导致报错</p></li><li><p>为你的app添加默认布局样式,比如:每一个控件都需要写width和height属性,然而很多的控件的宽高属性都是wrap_content,那么我们可以通过在style文件添加如下样式:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Theme.YourApp&quot; parent=&quot;android:style/Theme.Light&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ul><p>这样,控件的宽高默认都是wrap_content样式啦。</p><ul><li><p>在style中写的样式通过视同parent标签来扩展你的样式,这样更高效,这里官方的建议是，只有Android自带的style才用parent标签，如果是自定义的style，直接用.符号来连接就行。如Fill.Height。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;style name=&quot;Fill&quot;&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_width&quot;&gt;fill_parent&lt;/item&gt;</span><br><span class="line">    &lt;item name=&quot;android:layout_height&quot;&gt;fill_parent&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;style name=&quot;Fill.Height&quot; &gt;</span><br><span class="line">    &lt;item name=&quot;android:orientation&quot;&gt;vertical&lt;/item&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li><li><p>Android上的应用切换按钮列出的其实不是应用而是Task，所以你会看到有的应用在切换视图里有多个任务。如果你的应用中有逻辑上相互独立的部分，或者想在多窗口环境下并排显示应用的两个不同部分，这种情况就适合多任务了。使用manifest属性(静态)或者 intent flags(动态)可以实现这一点,详见视频: <a href="http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294" target="_blank" rel="noopener">http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294</a></p></li></ul><p><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/multy_task1.jpg" width="50%" height="300px"><img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/multy_task2.jpg" width="50%" height="300px"></p><ul><li><p>当app的theme用的是NoActionBar,但是在layout中仍然用到toolbar的时候,不要在style文件中加fitsSystemWindows属性,而是在用到toolbar的layout最外层加fitsSystemWindows,否则当你使用EditText,在小米手机上长按EditText调出系统粘贴功能的时候,粘贴的layout的布局会错位.</p></li><li><p>当WebView与ScrollView嵌套使用,并且WebView有字体放大缩小的功能时,当切换webview的字体后,webview的高度并不能很好的计算出来,这时候可以通过注入的方式,让js算出高度,经测试,这样是最可靠的,代码地址:<a href="http://blog.csdn.net/jys1115/article/details/43525979" target="_blank" rel="noopener">http://blog.csdn.net/jys1115/article/details/43525979</a></p></li><li><p>Context类中的createPackageContext(packageName, flags)方法，可用来获取指定包名应用程序的Context对象。</p></li><li><p>TextView类的setKeyListener(KeyListener)方法；<br>其中DigitsKeyListener类，使用getInstance(String accepted)方法即可指定EditText可输入字符集；</p></li><li><p>View类中的getLocationInWindow(int[])方法和getLocationOnScreen(int[])方法，获取View在窗口/屏幕中的位置；</p></li><li><p>Context.getCacheDir() - 可以获取到app默认的缓存路径。</p></li><li><p>StaticLayout 在自定义控件绘制文本的时候很有用。</p></li><li><p>Android中的四大组件千万不要通过new的方式创建出来。</p></li><li><p>测试app的时候,我们大都想要将debug和release版本同时安装到手机里,可以通过在gradle中修改applicationid来实现:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        debug &#123;</span><br><span class="line">            applicationIdSuffix &apos;.debug&apos;</span><br><span class="line">            versionNameSuffix &apos;-DEBUG&apos;</span><br><span class="line">        &#125;</span><br><span class="line">        release &#123;</span><br><span class="line">            //...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在大多数的登陆界面中，都提供了用户是否让密码可见的选项，Support Library 24.2.0 提供了官方的实现，TextInputLayout 中添加了 passwordToggleEnabled 属性来开启此功能，并且可以通过 passwordToggleDrawable 设置图标。(摘自:Android笔记的微博)</p></li><li><p>同样,在Support Library 24.2.0中增加RecyclerView 在快速滚动时的回调接口,SnapHelper是官方的一个实现OnFlingListener 的 一个抽象类,LinearSnapHelper 则是一个完整的实现.LinearSnapHelper默认实现的功能是类似ViewPager,在滚动结束后,会选择列表某一条居中展示(这里有开始位置展示,或者结束位置显示<a href="https://github.com/rubensousa/RecyclerViewSnap" target="_blank" rel="noopener">点我</a>).例如:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.HORIZONTAL, false);</span><br><span class="line">recyclerView.setLayoutManager(linearLayoutManager);</span><br><span class="line">LinearSnapHelper snapHelper = new LinearSnapHelper();</span><br><span class="line">snapHelper.attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure></li><li><p>Android中推荐使用的数据结构 :</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ArrayMap&lt;K,V&gt; in place of HashMap&lt;K,V&gt; </span><br><span class="line">ArraySet&lt;K,V&gt; in place of HashSet&lt;K,V&gt; </span><br><span class="line">SparseArray&lt;V&gt; in place of HashMap&lt;Integer,V&gt; </span><br><span class="line">SparseBooleanArray in place of HashMap&lt;Integer,Boolean&gt; </span><br><span class="line">SparseIntArray in place of HashMap&lt;Integer,Integer&gt;  </span><br><span class="line">SparseLongArray in place of HashMap&lt;Integer,Long&gt;  </span><br><span class="line">LongSparseArray&lt;V&gt; in place of HashMap&lt;Long,V&gt;</span><br></pre></td></tr></table></figure></li><li><p>生成GUID(由于java中只能生成UUID,所以这里要转换一下):</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">return UUID.randomUUID().toString().toUpperCase().replaceAll(&quot;-&quot;, &quot;&quot;);</span><br></pre></td></tr></table></figure></li><li><p>业务场景：需要定时后台扫描数据库，上传本地照片至云端，定时任务采用何种模式: </p></li></ul><p>1.Handler或者Timer定时一般为秒级别的任务,Timer会启动额外线程，而Handler可以不用。<br>2.无论是Handler还是Timer都需要依赖于进程存活<br>3.利用Handler实现定时任务的类:HandlerTimer<br>4.如果时间较长，则需要使用AlarmManager<br>5.另外，我们对于这种业务应该优先考虑是否可以基于事件通知。<br>6.如果是加入媒体库的文件，我们可以使用registerContentObserver监听媒体库文件变化。</p><ul><li>把Activity作为参数传给一个静态方法,会影响这个Activity的正常销毁吗?</li></ul><p>1.内存泄露与方法是否是静态与否无关，与内部的方法体实现有关系。<br>2.内存泄露可以简单理解成：生命周期长的对象不正确持有了持有了生命周期短的对象，导致生命周期短的对象无法回收。<br>3.比如Activity实例被Application对象持有，Activity实例被静态变量持有。</p><ul><li><p>在assets文件夹下存放单个文件的大小不能超过1M，如果读取超过1M的文件会报 “Data exceeds UNCOMPRESS_DATA_MAX (1314625 vs 1048576)” 的IOException。如果一定要存储，可以分割文件，再去合并文件</p></li><li><p>在Android library中不能使用switch-case语句访问资源ID，因为case分支后面跟的参数必须是常数，而library中的每一个资源ID都没有被声明为final。</p></li><li><p>当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率；</p></li><li><p>不要通过Bundle传递大块的数据，否则会报TransactionTooLargeException异常</p></li><li><p>（AnimationDrawable在Android5.0及以上的版本已有明显的优化）尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错；</p></li><li><p>.9图不能通过tinypng压缩，不然会有问题；</p></li><li><p>genymotion模拟器快是因为它是基于x86架构的，如果你的应用中用到了so，但没有x86架构的so，只能放弃使用它；Android Studio的模拟器也一样；</p></li><li><p>使用Toast时，建议定义一个全局的Toast对象，这样可以避免连续显示Toast时不能取消上一次Toast消息的情况（如果你有连续弹出Toast的情况，避免使用Toast.makeText）；</p></li><li><p>尽量避免给window和Activity同时都设置了背景，这样会造成过渡绘制，可以通过在给Activity设置主题时，去掉windowBackground背景的方式减少一层过渡绘制，有时候为了避免进入Activity时会黑屏或者白屏（和主题有关），会在给Activity设置主题的时候给window设置背景，如果这种情况下给Activity也设置了背景，是会增加一倍内存的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt;</span><br></pre></td></tr></table></figure></li><li><p>设置中更改字体为特大之类的会影响到app的字体样式，解决方法有: 1.将所有字体使用的单位换成dp，不再使用sp.这样不是很靠谱，并不是所有人都能做到。</p></li></ul><p>2.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Configuration configuration = getResources().getConfiguration();</span><br><span class="line"> configuration.fontScale = (float) 1; </span><br><span class="line"> //0.85 小, 1 标准大小, 1.15 大，1.3 超大 ，1.45 特大 </span><br><span class="line"> DisplayMetrics metrics = new DisplayMetrics();</span><br><span class="line"> getWindowManager().getDefaultDisplay().getMetrics(metrics); </span><br><span class="line"> metrics.scaledDensity = configuration.fontScale * metrics.density;</span><br><span class="line"> getBaseContext().getResources().updateConfiguration(configuration, metrics); </span><br><span class="line"> //（ps:dialog popupwindow 除外,这两种需要在控件中重新设置fontScale)</span><br></pre></td></tr></table></figure><ul><li><p>Android中新引入的替代枚举的注解有IntDef和StringDef,这里以IntDef做例子说明一下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Colors &#123;</span><br><span class="line">    @IntDef(&#123;RED, GREEN, YELLOW&#125;)</span><br><span class="line">    //声明必要的int常量,使用@IntDef修饰LightColors,参数设置为待枚举的集合</span><br><span class="line">    @Retention(RetentionPolicy.SOURCE)</span><br><span class="line">    //使用@Retention(RetentionPolicy.SOURCE)指定注解仅存在与源码中,不加入到class文件中</span><br><span class="line">    public @interface LightColors&#123;&#125;</span><br><span class="line">    //声明一个注解为LightColors</span><br><span class="line">    public static final int RED = 0;</span><br><span class="line">    public static final int GREEN = 1;</span><br><span class="line">    public static final int YELLOW = 2;</span><br><span class="line">&#125;</span><br><span class="line">//用法</span><br><span class="line">private void setColor(@Colors.LightColors int color) &#123;</span><br><span class="line">        Log.d(&quot;MainActivity&quot;, &quot;setColor color=&quot; + color);</span><br><span class="line">&#125;</span><br><span class="line">//调用的该方法的时候</span><br><span class="line">setColor(Colors.GREEN);</span><br></pre></td></tr></table></figure></li><li><p>PathInterpolatorCompat 很方便的使用它来创建各种插值曲线，举个非常简单的例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Path path = new Path();</span><br><span class="line">path.cubicTo(0.2f, 0f, 0.1f, 1f, 0.5f, 1f);</span><br><span class="line">path.lineTo(1f, 1f);</span><br><span class="line">ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 500);</span><br><span class="line">animator.setInterpolator(PathInterpolatorCompat.create(path));</span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></li><li><p>检测当前网络能否访问远程服务器(国内通过ping百度来检测)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static boolean isNetWorkAvailable(final Context context) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            Runtime runtime = Runtime.getRuntime();</span><br><span class="line">            Process pingProcess = runtime.exec(&quot;/system/bin/ping -c 1 www.baidu.com&quot;);</span><br><span class="line">            int exitCode = pingProcess.waitFor(); //0 代表连通，2代表不通</span><br><span class="line">            return (exitCode == 0);</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>拦截系统返回键(onBackPressed())，使App不退出，而是进入后台运行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line">  public void onBackPressed() &#123;</span><br><span class="line">    moveTaskToBack(false);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>view.performClick() 自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件，该方法可以由某些特殊条件触发模拟用户点击行为。类似的还有 performLongClick() 方法。</p></li><li><p>Linkify.addLinks() 通过 android:autoLink 属性可以为其添加诸如 web、phone 等固定模版的超链接点击事件。但毕竟系统模版有限，而利用 Linkify.addLinks() 方法可以添加一些应用内自定义模版，比如新浪微博中的 “@XXX” 格式的超链接跳转等，都可以通过自定义正则表达式来匹配处理。</p></li><li><p>getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE) 设置安全窗口，禁用系统截屏。防止 App 中的一些界面被截屏，并显示在其他设备中造成信息泄漏。（常见手机设备系统截屏操作方式为：同时按下电源键和音量键。）</p></li><li><p>activity生命周期(<a href="https://www.bignerdranch.com/blog/android-activity-lifecycle-onStop/" target="_blank" rel="noopener">Ref Link</a>)</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/activityStateDiagram.jpeg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://github.com/jiang111/awesome-android-tips/raw/master/img/complete_activity_fragment_lifecycle.png" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>RecyclerView 调用notifyItem()的时候会有默认的动画,可以通过调用((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);来去掉默认动画.以防止出现闪屏的问题</p></li><li><p>Toolbar 使用的主题如果 parent=”ThemeOverlay.AppCompat.Light”，只要改一下 <item name="colorControlNormal">@color/white</item> 就可以使 OverflowButton 变为白色，同时点击它展开的菜单背景也可以是白的</p></li><li><p>Android View的生命周期示例图样。来自G+ +Arpit Mathur</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="https://raw.githubusercontent.com/jiang111/awesome-android-tips/master/img/view_lifecycle.jpg" alt title>                </div>                <div class="image-caption"></div>            </figure></li><li><p>当需要从资源文件中获取 html 并展示时，使用 Resource#getText() 而不是 Resource#getString()。当需要动态显示 HTML 时，使用 Html.fromHtml() <a href="http://saket.me/html-tags-textview/" target="_blank" rel="noopener">请看这里</a></p></li><li><p>JAVA中时间String转Timestamp</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);</span><br><span class="line">format.setLenient(false);</span><br><span class="line">//要转换字符串 str_test  自定义的格式为 yyyy-mm-dd，可以改成你需要的格式</span><br><span class="line">String str_test =&quot;2011-04-24&quot;;</span><br><span class="line">Timestamp ts = new Timestamp(format.parse(str_test).getTime());</span><br><span class="line">System.out.println(ts.toString());</span><br><span class="line">&#125; catch (ParseException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>当Activity 继承 FragmentActivity的时候，调用startActivityForResult方法中传递的requestCode范围应该在0-65535范围内，否则会报”Can only use lower 16 bits for requestCode”异常。</p></li><li><p>Android有一个隐藏的类可以判断文本输入框内输入的是不是表情，这个类就是 android.text.Emoji类，它的isEmoji(int codePoint)方法可以直接判断出来是不是表情。这个类是隐藏的，如果要用到则需要将它拷贝出来。</p></li><li><p>布局中不得不使用ViewGroup 多重嵌套时，不要使用LinearLayout 嵌套，改用RelativeLayout，可以有效降低嵌套数。</p></li><li><p>不能使用ScrollView 包裹ListView/GridView/ExpandableListVIew;因为这样会把ListView 的所有Item 都加载到内存中，要消耗巨大的内存和cpu 去绘制图面。</p></li><li><p>不要通过Intent 在Android 基础组件之间传递大数据（binder transaction缓存为1MB），可能导致OOM。</p></li><li><p>在Application 的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。</p></li><li><p>将android:allowbackup 属性设置为false，防止adb backup 导出数据。</p></li><li><p>除非min API level &gt;=17，请注意addJavascriptInterface 的使用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">说明：</span><br><span class="line">API level&gt;=17，允许js 被调用的函数必须以@JavascriptInterface 进行注解，因此不受影响； 对于API level &lt; 17，尽量不要使用addJavascriptInterface，如果一定要用，那么：</span><br><span class="line">1) 使用https 协议加载URL，使用证书校验，防止访问的页面被篡改挂马；</span><br><span class="line">2) 对加载URL 做白名单过滤、完整性校验等防止访问的页面被篡改；</span><br><span class="line">3) 如果加载本地html,应该会HTML 内置在APK 中，以及对HTML 页面进行完整性校验。</span><br></pre></td></tr></table></figure></li><li><p>如何动态修改AlertDialog的Button样式,</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">//监听Dialog的setOnShowListener方法</span><br><span class="line">dialog.setOnShowListener(new DialogInterface.OnShowListener() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void onShow(final DialogInterface dialog) &#123;</span><br><span class="line">      Button negativeButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_NEGATIVE);</span><br><span class="line">      Button positiveButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_POSITIVE);</span><br><span class="line">      negativeButton.invalidate();</span><br><span class="line">      positiveButton.invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">dialog.show();</span><br></pre></td></tr></table></figure></li><li><p>升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可<a href="https://juejin.im/entry/58a3f4f62f301e0069908d8f" target="_blank" rel="noopener">参考 RecyclerView 数据预取</a>。</p></li><li><p>如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源；</p></li><li><p>如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提升效率。</p></li><li><p>通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。</p></li><li><p>如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。</p></li><li><p>对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。</p></li><li><p>通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new LinearLayoutManager(this) &#123;</span><br><span class="line">    @Override</span><br><span class="line">    protected int getExtraLayoutSpace(RecyclerView.State state) &#123;</span><br><span class="line">        return size;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>WebView 在 API 21之后,写Cookie的时候默认禁止了跨域写cookie,需要通过代码,来设置开启跨域请求</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">           CookieManager.getInstance().setAcceptThirdPartyCookies(WebView, true);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></li><li><p>使用IdleHandler,替代Handler.postDelay(),IdleHandler是在我们的onResume和measure, layout, draw这么message执行结束之后， 提供了他们执行完毕的回调. <a href="https://wetest.qq.com/lab/view/352.html" target="_blank" rel="noopener">看这里</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123;</span><br><span class="line">           @Override</span><br><span class="line">           public boolean queueIdle() &#123;</span><br><span class="line">               //TODO...</span><br><span class="line">               return false;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br></pre></td></tr></table></figure></li><li><p>在Multidex分包的时候,如果主dex过大, 5.0以下的机型可能会出现multidex installation failure错误,这时需要让主dex方法数小一点.,配置方法</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">配置正常的multiDex库之后,在主模块的gradle文件添加如下代码:</span><br><span class="line">Android&#123;</span><br><span class="line">     ...//其他代码</span><br><span class="line">    dexOptions &#123;</span><br><span class="line">        javaMaxHeapSize &quot;4g&quot;</span><br><span class="line">        preDexLibraries = false</span><br><span class="line">        additionalParameters += &apos;--multi-dex&apos;</span><br><span class="line">        additionalParameters += &apos;--set-max-idx-number=35000&apos;//(35000可根据自己的需求更改)来适配4.0-4.4一些低端机型，因为拆分的dex太大，这些低端机型加载不了dex</span><br><span class="line">        additionalParameters += &apos;--minimal-main-dex&apos;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意:在gradle版本3.1.0之后dex编译采用D8,可能会导致这种分包不成功。将gradle的版本降到3.0.0之后，分包成功。另外也可以采用gradle3.1.0或者以上的版本，然后将项目的gradle配置为android.enableD8=false //暂时关闭 即可</p><ul><li><p>高版本android中，可以使用Application启动Activity并且不设置FLAG，但在低版本中必须要设置FLAG,所以建议大家使用application的context去startActivity的时候添加FLAG_ACTIVITY_NEW_TASK</p></li><li><p>不要滥用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt;</span><br></pre></td></tr></table></figure></li></ul><p>属性,切勿为app设置该属性,而仅针对具体的activity进行设置.公司有位开发为整个app设置了该属性,我们有个签名的横屏页面,其他是强制竖屏页面,有个需求是进入该竖屏页面后某些特殊原因需要自动跳转到签名页面,而跳转到横屏页面后导致整个app的所有页面生命周期全部重新走了一遍,该签名页面无限循环打开.</p><ul><li>当你在多module中使用了多个三方库,而这些三方库使用了多个版本的Recyclerview,我们可以通过exclude group: ‘com.android.support’, module: ‘recyclerview-v7’ 来实现使用项目中的版本,但是这样造成的问题是每添加一个库就得写一下exclude,这样很不友好,而gradle为我们提供了依赖替换规则.<br>如下代码实现了全局替换recyclerview的版本<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt;</span><br><span class="line">        def requested = details.requested</span><br><span class="line">        if (requested.group == &apos;com.android.support&apos;) &#123;</span><br><span class="line">            if (requested.name.startsWith(&quot;recyclerview-v7&quot;)) &#123;</span><br><span class="line">                details.useVersion &quot;28.0.0&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>当然,依赖替换规则还允许我们在本地库和远程库之间进行切换.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">configurations.all &#123;</span><br><span class="line">    resolutionStrategy.dependencySubstitution &#123;</span><br><span class="line">        if (useLocal) &#123; //如果使用本地仓库,系统将会把org.utils:api依赖替换为本地api的project</span><br><span class="line">            substitute module(&quot;org.utils:api&quot;) because &quot;we work with the unreleased development version&quot; with project(&quot;:api&quot;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="摘自如下地址"><a href="#摘自如下地址" class="headerlink" title="摘自如下地址"></a>摘自<a href="https://github.com/jiang111/awesome-android-tips/blob/master/README.md" target="_blank" rel="noopener">如下地址</a></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lightbox&quot;&gt;
                    &lt;div class=&quot;overlay&quot;&gt;&lt;/div&gt;
                   
      
    
    </summary>
    
      <category term="Android" scheme="http://zhangyongfa888.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhangyongfa888.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>滴滴插件化实践</title>
    <link href="http://zhangyongfa888.site/2019/07/30/%E6%BB%B4%E6%BB%B4%E6%8F%92%E4%BB%B6%E5%8C%96%E5%AE%9E%E8%B7%B5/"/>
    <id>http://zhangyongfa888.site/2019/07/30/滴滴插件化实践/</id>
    <published>2019-07-30T11:05:00.000Z</published>
    <updated>2019-09-03T00:22:36.312Z</updated>
    
    <content type="html"><![CDATA[<h3 id="工程目录"><a href="#工程目录" class="headerlink" title="工程目录"></a>工程目录</h3><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/1564484754934e6w63xr3.png?imageslim" alt="paste image" title>                </div>                <div class="image-caption">paste image</div>            </figure><h4 id="宿主配置"><a href="#宿主配置" class="headerlink" title="宿主配置"></a>宿主配置</h4><pre><code>apply plugin: &apos;com.android.application&apos;apply plugin: &apos;com.didi.virtualapk.host&apos;//***dependencies{       implementation &apos;***.huozhu:core:&apos; + rootProject.ext.versions.core       implementation &apos;com.didi.virtualapk:core:0.9.8&apos;   }</code></pre><h4 id="公共库配置"><a href="#公共库配置" class="headerlink" title="公共库配置"></a>公共库配置</h4><p>因为涉及到插件的下载加载以及之间的跳转 所以封装一个下载加载的公共类</p><pre><code>dependencies{       implementation &apos;com.didi.virtualapk:core:0.9.8&apos;   }</code></pre><h4 id="插件配置"><a href="#插件配置" class="headerlink" title="插件配置"></a>插件配置</h4><pre><code>apply plugin: &apos;com.didi.virtualapk.plugin&apos;    virtualApk {    packageId = 0x75    targetHost = &apos;../app&apos;    applyHostMapping = true    forceUseHostDependences = true}</code></pre><p>插件中的gradle.properties </p><pre><code>android.useDexArchive=false</code></pre><h4 id="项目配置"><a href="#项目配置" class="headerlink" title="项目配置"></a>项目配置</h4><p>build.gradle中</p><pre><code>buildscript {repositories {    google()    jcenter()}dependencies {    classpath &apos;com.android.tools.build:gradle:3.1.0&apos;    classpath &apos;com.didi.virtualapk:gradle:0.9.8.6&apos;    }}</code></pre><h4 id="插件加载并跳转"><a href="#插件加载并跳转" class="headerlink" title="插件加载并跳转"></a>插件加载并跳转</h4><pre><code> loadPlugin(&quot;plugin_mywallet&quot;, new LoadPlugin() { @Override public void plugin(LoadedPlugin plugin) {   startActivity(plugin.getLaunchIntent());  }});</code></pre><h5 id="插件之间的跳转和传参"><a href="#插件之间的跳转和传参" class="headerlink" title="插件之间的跳转和传参"></a>插件之间的跳转和传参</h5><pre><code>loadPlugin(&quot;plugin_orderlist&quot;, new LoadPlugin() {@Overridepublic void plugin(LoadedPlugin loadedPlugin) {try {                 Intent intent = new Intent(context,Class.forName(&quot;***.plugin_orderlist.PluginOrderDetailsActivity&quot;));   intent.putExtra(&quot;extra_orderid&quot;, orderCode);    startActivity(intent);   } catch (Exception e) {       e.printStackTrace();     }}});</code></pre><h4 id="其他配置"><a href="#其他配置" class="headerlink" title="其他配置"></a>其他配置</h4><h5 id="基地址"><a href="#基地址" class="headerlink" title="基地址"></a>基地址</h5><p> 基地址封装在公共库 并能够在宿主中修改,插件中之间调用基地址即可区分正式和开发环境</p><pre><code>public static String BaseUrl = &quot;https://tess.cisdom.com.cn/public/index.php/apient/&quot;;public static String BaseDownload = &quot;http://192.168.50.7/wx/&quot;;public static void setBaseUrl(String baseUrl) {      BaseUrl = baseUrl; } public static void setBaseDownload(String baseDownload) {      BaseDownload = baseDownload; }</code></pre><h5 id="公共库打包aar"><a href="#公共库打包aar" class="headerlink" title="公共库打包aar"></a>公共库打包aar</h5><p>见 <a href="https://blog.csdn.net/u013325929/article/details/50563571" target="_blank" rel="noopener">https://blog.csdn.net/u013325929/article/details/50563571</a></p><h4 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h4><h5 id="插件包需要签名"><a href="#插件包需要签名" class="headerlink" title="插件包需要签名"></a>插件包需要签名</h5><h5 id="插件包生成插件找不到入口函数-gt-在清单文件加入application"><a href="#插件包生成插件找不到入口函数-gt-在清单文件加入application" class="headerlink" title="插件包生成插件找不到入口函数 -&gt;在清单文件加入application"></a>插件包生成插件找不到入口函数 -&gt;在清单文件加入application</h5>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;工程目录&quot;&gt;&lt;a href=&quot;#工程目录&quot; class=&quot;headerlink&quot; title=&quot;工程目录&quot;&gt;&lt;/a&gt;工程目录&lt;/h3&gt;&lt;figure class=&quot;image-bubble&quot;&gt;
                &lt;div class=&quot;img-lig
      
    
    </summary>
    
      <category term="Android" scheme="http://zhangyongfa888.site/categories/Android/"/>
    
      <category term="插件化" scheme="http://zhangyongfa888.site/categories/Android/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://zhangyongfa888.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>滴滴插件化</title>
    <link href="http://zhangyongfa888.site/2019/07/12/%E6%BB%B4%E6%BB%B4%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    <id>http://zhangyongfa888.site/2019/07/12/滴滴插件化/</id>
    <published>2019-07-12T00:56:00.000Z</published>
    <updated>2019-09-03T00:25:09.957Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插件开发规范-V1-0-1"><a href="#插件开发规范-V1-0-1" class="headerlink" title="插件开发规范 V1.0.1"></a>插件开发规范 V1.0.1</h1><p>由于VirtualAPK本身的特性，插件需要遵循以下规范：</p><h1 id="1-宿主配置"><a href="#1-宿主配置" class="headerlink" title="1.宿主配置"></a>1.宿主配置</h1><p>Project build.gradle</p><pre><code> classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos;`&lt;/pre&gt;Module build.gradle&lt;pre&gt;`apply plugin: &apos;com.didi.virtualapk.host&apos;compile &apos;com.didi.virtualapk:core:0.9.0&apos;`&lt;/pre&gt;</code></pre><h2 id="2-插件配置"><a href="#2-插件配置" class="headerlink" title="2.插件配置"></a>2.插件配置</h2><p>插件 Project  build.gradle 文件中，需要加入如下引用：</p><pre><code>classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos;</code></pre><p>注：版本号应与宿主版本号相同</p><p>插件 Module   build.gradle 文件中，需要加入如下引用：</p><pre><code>apply plugin: &apos;com.didi.virtualapk.plugin&apos;virtualApk     {     packageId = 0x6f // 插件资源id，避免资源id冲突     targetHost=&apos;../host/app&apos;// 宿主工程的路径     applyHostMapping = true // 插件编译时是否启用应用宿主的apply mapping 默认为true}</code></pre><h2 id="3-构建环境"><a href="#3-构建环境" class="headerlink" title="3.构建环境"></a>3.构建环境</h2><p>   官方构建环境建议：</p><p>   <strong>框架强依赖构建环境。如果更换构建环境，可能会出现问题</strong></p><pre><code>Gradle                   2.14.1com.android.tools.build  2.1.3即：插件 Project  build.gradle 文件中classpath &apos;com.android.tools.build:gradle:2.1.3&apos;插件gradle-wrapper.properties文件中：distributionUrl=https\://services.gradle.org/distributions/gradle-2.14.1-all.zip</code></pre><h2 id="4-打包"><a href="#4-打包" class="headerlink" title="4.打包"></a>4.打包</h2><p>  插件打包时，应当用命令<br>    <code>./gradlew clen assemblePlugin</code><br>    或者 <code>gradle clean assemblePlugin</code> 进行打包</p><p>   输出位置为：<strong>app\build\outputs\plugin\release</strong></p><p>   由于插件 Module   build.gradle 文件中设置了如下参数，<br>    targetHost=’../host/app’// 宿主工程的路径<br>    故，打包时的文件结构应为：<br>    <img src="https://i.imgur.com/XDBHTMS.png" alt></p><p>   即：HOST 应与插件在同一目录下编译</p><h1 id="插件调用宿主"><a href="#插件调用宿主" class="headerlink" title="插件调用宿主"></a>插件调用宿主</h1><p>   将宿主中需要被插件调用的 模块、类，下沉到公共组件库。</p><p>   即：以aar包的形式。分别被插件，组件依赖即可。</p><p>   aar 引入模板：</p><pre><code>compile(group:&apos;test&apos;, name: &apos;app-release&apos;, version:&apos;0.2&apos;, ext: &apos;aar&apos;)</code></pre><h1 id="插件中包含-so-包需特别注意"><a href="#插件中包含-so-包需特别注意" class="headerlink" title="插件中包含 so 包需特别注意"></a>插件中包含 so 包需特别注意</h1><p>如果插件中包含如百度地图等 so 包，由于部分第三方库存在的包名校验机制，需要注册一份新的 secretKey 写到宿主中,这个不难理解，因为运行时包名是宿主的包名，不能通过校验。</p><h1 id="资源链接"><a href="#资源链接" class="headerlink" title="资源链接"></a>资源链接</h1><p>我的踩坑记录 <a href="https://blog.csdn.net/a31081314/article/details/82661009" title="踩坑实录" target="_blank" rel="noopener">https://blog.csdn.net/a31081314/article/details/82661009</a></p><p>我的demo 地址 <a href="https://github.com/CD3108/VirtualAPK" target="_blank" rel="noopener">https://github.com/CD3108/VirtualAPK</a></p><p>源码地址 <a href="https://github.com/didi/VirtualAPK" title="源码地址" target="_blank" rel="noopener">https://github.com/didi/VirtualAPK</a></p><p>详细框架接入 <a href="https://www.jianshu.com/p/013510c19391" title="框架接入" target="_blank" rel="noopener">https://www.jianshu.com/p/013510c19391</a></p><p>四大组件加载过程 <a href="https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;mpshare=1&amp;scene=1&amp;srcid=0712oTUswGWi172UK0Azpg4i&amp;key=8652b956ca1971a47b1e263b435230c7469d30646ddbe6ce2fb781033d6eba5215c9fd7e5eaf0bd73dd5da279b32dd901261d5e55bf32997bc333ad8a059e095e2193a5baa805447fc49cd315fca4404&amp;ascene=0&amp;uin=MTI0NjM4NTEyMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=12010110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=mswE9bS3QeCxTOoepaUWh9VXHxeYMosdkHkAydyR09JHQkVe%2BAJHCCnPQrRpBfQN" title="四大组件" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;mpshare=1&amp;scene=1&amp;srcid=0712oTUswGWi172UK0Azpg4i&amp;key=8652b956ca1971a47b1e263b435230c7469d30646ddbe6ce2fb781033d6eba5215c9fd7e5eaf0bd73dd5da279b32dd901261d5e55bf32997bc333ad8a059e095e2193a5baa805447fc49cd315fca4404&amp;ascene=0&amp;uin=MTI0NjM4NTEyMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=12010110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=mswE9bS3QeCxTOoepaUWh9VXHxeYMosdkHkAydyR09JHQkVe%2BAJHCCnPQrRpBfQN</a></p><p>资源加载过程 <a href="https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537" title="资源加载过程" target="_blank" rel="noopener">https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537</a></p><h6 id="来自VirtualAPK开发群-点击链接加入群聊【VirtualAPK】："><a href="#来自VirtualAPK开发群-点击链接加入群聊【VirtualAPK】：" class="headerlink" title="来自VirtualAPK开发群 点击链接加入群聊【VirtualAPK】："></a><a href="https://jq.qq.com/?_wv=1027&k=5J39bhD" target="_blank" rel="noopener">来自VirtualAPK开发群 点击链接加入群聊【VirtualAPK】：</a></h6>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;插件开发规范-V1-0-1&quot;&gt;&lt;a href=&quot;#插件开发规范-V1-0-1&quot; class=&quot;headerlink&quot; title=&quot;插件开发规范 V1.0.1&quot;&gt;&lt;/a&gt;插件开发规范 V1.0.1&lt;/h1&gt;&lt;p&gt;由于VirtualAPK本身的特性，插件需要遵循以下
      
    
    </summary>
    
      <category term="插件化" scheme="http://zhangyongfa888.site/categories/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
    
      <category term="Android" scheme="http://zhangyongfa888.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Markdown基本语法</title>
    <link href="http://zhangyongfa888.site/2019/07/10/Markdown%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"/>
    <id>http://zhangyongfa888.site/2019/07/10/Markdown基本语法/</id>
    <published>2019-07-10T06:33:00.000Z</published>
    <updated>2019-09-03T00:24:38.958Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Markdown基本语法"><a href="#Markdown基本语法" class="headerlink" title="Markdown基本语法"></a>Markdown基本语法</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>Markdown 是一种_轻量级标记语言_，它允许人们使用易读易写的纯文本格式编写文档。<br>Markdown 语言在 2004 由<strong>约翰·格鲁伯（英语：John Gruber）</strong>创建。<br>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的<strong><em>文档</em></strong>。<br>Markdown 编写的文档后缀为<strong><em>.md</em></strong> , <strong>.markdown</strong>。</p><h3 id="Markdown-标题"><a href="#Markdown-标题" class="headerlink" title="Markdown 标题"></a>Markdown 标题</h3><h4 id="使用-号标记"><a href="#使用-号标记" class="headerlink" title="使用 # 号标记"></a>使用 # 号标记</h4><p>使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。<br>如下：</p><pre><code># 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题</code></pre><h4 id="显示效果"><a href="#显示效果" class="headerlink" title="显示效果"></a>显示效果</h4><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题"></a>六级标题</h6><h4 id="使用-标记"><a href="#使用-标记" class="headerlink" title="使用-/=标记"></a>使用-/=标记</h4><pre><code>我展示的是一级标题=================我展示的是二级标题-----------------</code></pre><h4 id="显示效果-1"><a href="#显示效果-1" class="headerlink" title="显示效果"></a>显示效果</h4><h1 id="我展示的是一级标题"><a href="#我展示的是一级标题" class="headerlink" title="我展示的是一级标题"></a>我展示的是一级标题</h1><h2 id="我展示的是二级标题"><a href="#我展示的是二级标题" class="headerlink" title="我展示的是二级标题"></a>我展示的是二级标题</h2><h3 id="Markdown-区块"><a href="#Markdown-区块" class="headerlink" title="Markdown 区块"></a>Markdown 区块</h3><pre><code>&gt; 最外层&gt; &gt; 第一层嵌套&gt; &gt; &gt; 第二层嵌套</code></pre><h4 id="显示效果-2"><a href="#显示效果-2" class="headerlink" title="显示效果"></a>显示效果</h4><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h3 id="Markdown-代码"><a href="#Markdown-代码" class="headerlink" title="Markdown 代码"></a>Markdown 代码</h3><ul><li><code>printf()</code> 函数</li><li>代码区块使用 4 个空格或者一个制表符（Tab 键）。<pre><code>printf() //tab键</code></pre></li></ul><h3 id="Markdown-链接"><a href="#Markdown-链接" class="headerlink" title="Markdown 链接"></a>Markdown 链接</h3><pre><code>[链接名称](http://www.baidu.com)       或者&lt;http://www.baidu.com&gt;</code></pre><p> <a href="http://www.baidu.com" target="_blank" rel="noopener">链接名称</a></p><p>或者</p><p><a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a></p><h3 id="Markdown-图片"><a href="#Markdown-图片" class="headerlink" title="Markdown 图片"></a>Markdown 图片</h3><p>Markdown 图片语法格式如下：</p><pre><code>  ![alt 属性文本](图片地址)  {% image 图片地址 'alt 属性文本' '可选标题' %}example:  ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png)  [RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;)</code></pre><p><img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标"></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://static.runoob.com/images/runoob-logo.png" alt="RUNOOB 图标" title="RUNOOB">                </div>                <div class="image-caption">RUNOOB</div>            </figure><h3 id="Markdown-表格"><a href="#Markdown-表格" class="headerlink" title="Markdown 表格"></a>Markdown 表格</h3><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。</p><p>语法格式如下：</p><pre><code>|  表头   | 表头  ||  ----  | ----  || 单元格  | 单元格 || 单元格  | 单元格 |</code></pre><p>   显示如下： </p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><p><strong>对齐方式</strong></p><ul><li>-: 设置内容和标题栏居右对齐</li><li>:- 设置内容和标题栏居左对齐</li><li>:-: 设置内容和标题栏居中对齐<pre><code>| 左对齐 | 右对齐 | 居中对齐 || :-----| ----: | :----: || 单元格 | 单元格 | 单元格 || 单元格 | 单元格 | 单元格 |</code></pre></li></ul><table><thead><tr><th align="left">左对齐</th><th align="right">右对齐</th><th align="center">居中对齐</th></tr></thead><tbody><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr><tr><td align="left">单元格</td><td align="right">单元格</td><td align="center">单元格</td></tr></tbody></table><p><strong>参考 <a href https: www.runoob.com markdown md-tutorial.html"">菜鸟教程</a> 整理</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Markdown基本语法&quot;&gt;&lt;a href=&quot;#Markdown基本语法&quot; class=&quot;headerlink&quot; title=&quot;Markdown基本语法&quot;&gt;&lt;/a&gt;Markdown基本语法&lt;/h2&gt;&lt;h3 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;
      
    
    </summary>
    
      <category term="MarkDown" scheme="http://zhangyongfa888.site/categories/MarkDown/"/>
    
    
      <category term="语言" scheme="http://zhangyongfa888.site/tags/%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>Android Q 功能和 API</title>
    <link href="http://zhangyongfa888.site/2019/07/10/Android-Q-%E5%8A%9F%E8%83%BD%E5%92%8C-API/"/>
    <id>http://zhangyongfa888.site/2019/07/10/Android-Q-功能和-API/</id>
    <published>2019-07-10T05:41:00.000Z</published>
    <updated>2019-07-10T05:47:15.705Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Android-Q-功能和-API"><a href="#Android-Q-功能和-API" class="headerlink" title="Android Q 功能和 API"></a>Android Q 功能和 API</h1><p>Android Q 为用户和开发者引入了强大的新功能。本文重点介绍面向开发者的新功能。</p><p>要了解新版 API，请阅读 API 差异报告或访问 Android API 参考文档。为醒目起见，将突出显示新版 API。此外，请务必查阅 Android Q 行为变更（针对以 Android Q 为目标平台的应用和所有应用）以及隐私权变更，以了解平台变更可能给您的应用带来哪些方面的影响。</p><p>安全增强功能<br>Android Q 引入了若干安全功能，详见以下各节摘要说明：</p><p>改进了生物识别身份验证对话框<br>Android Q 对 Android 9 中增加的统一生物识别身份验证对话框进行了以下改进：</p><p>指定用户确认要求<br>您现在可以提供一个提示，以告知系统在用户使用隐式生物识别模式完成身份验证后无需要求用户进行确认。例如，您可以告知系统，在用户使用面孔身份验证完成身份验证后无需进一步确认。</p><p>默认情况下，系统会要求用户进行确认。通常，用户希望确认敏感或高风险的操作（例如，购买商品）。但是，如果您的应用存在某些低风险操作，您可以将 false 传递到 setConfirmationRequired() 方法，以此来提供不要求用户确认的提示。由于此标记作为提示传递到系统，因此如果用户更改了针对生物识别身份验证的系统设置，则系统可能会忽略相应的值。</p><p>无需用户确认的面孔身份验证示例。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/15627373439255eibcyt9.png?imageslim" alt="paste image" title>                </div>                <div class="image-caption">paste image</div>            </figure><br>图 1. 无需用户确认的面孔身份验证</p><p>要求用户确认的面孔身份验证示例。<figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="http://res.zhangyongfa888.site/15627373517600itg5vh6.png?imageslim" alt="paste image" title>                </div>                <div class="image-caption">paste image</div>            </figure><br>图 2. 需要用户确认的面孔身份验证</p><p>改进了对设备凭据的回退支持<br>您现在可以告知系统，如果用户因某种原因而无法使用其生物识别输入设备进行身份验证，则可以使用设备 PIN 码、图案或密码来进行身份验证。要启用此回退支持，请使用 setDeviceCredentialAllowed() 方法。</p><p>如果您的应用目前使用 createConfirmDeviceCredentialIntent() 回退到设备凭据，请改为使用新方法。</p><p>检查设备的生物识别功能<br>现在，您可以先通过使用 BiometricManager 类中的 canAuthenticate() 方法，检查设备是否支持生物识别身份验证，然后再调用 BiometricPrompt。</p><p>直接从 APK 运行嵌入式 DEX 代码<br>您现在可以告知平台直接从应用的 APK 文件中运行嵌入式 DEX 代码。如果攻击者曾设法篡改了设备上本地编译的代码，则此选项有助于防止此类攻击。</p><p>注意：启用此功能可能会影响应用的性能，因为在应用启动时 ART 必须使用 JIT 编译器（而不是读取提前编译好的原生代码）。我们建议您先测试应用性能，然后再决定是否在已发布的应用中启用此功能。<br>要启用此功能，请在应用清单文件的 <application> 元素中将 android:useEmbeddedDex 属性的值设为 true。您还必须编译一个 APK，其中要包含 ART 可以直接访问的未压缩 DEX 代码。将以下选项添加到 Gradle 或 Bazel 配置文件，以编译包含未压缩 DEX 代码的 APK：</application></p><p>Gradle</p><p>aaptOptions {<br>       noCompress ‘dex’<br>    }</p><p>Bazel</p><pre><code>android_binary(   ...,   nocompress_extensions = [“.dex”],)</code></pre><p>TLS 1.3 支持<br>现在，平台的 TLS 实现支持 TLS 1.3。TLS 1.3 是 TLS 标准的主要修订版本，它提升了性能和安全性。我们的基准测试数据表明，与 TLS 1.2 相比，使用 TLS 1.3 可以将建立安全连接的速度提高 40%。</p><p>默认情况下，系统会为所有 TLS 连接启用 TLS 1.3。您可以通过调用 SSLContext.getInstance(“TLSv1.2”) 来获取已停用 TLS 1.3 的 SSLContext。您还可以对相关对象调用 setEnabledProtocols()，从而为每个连接启用或停用协议版本。</p><p>以下是有关 TLS 1.3 实现的一些重要的详细信息：</p><p>TLS 1.3 加密套件不可自定义。在启用 TLS 1.3 后，受支持的 TLS 1.3 加密套件会始终保持启用状态，并且系统会忽略所有试图通过调用 setEnabledCipherSuites() 将其停用的行为。<br>在协商 TLS 1.3 时，系统会在将会话添加到会话缓存之前调用 HandshakeCompletedListeners（这与 TLS 1.2 和之前的其他版本不同）。<br>SSLEngine 实例会在之前原本会抛出 SSLHandshakeException 的部分情况下抛出 SSLProtocolException。<br>不支持 0-RTT 模式。<br>公共 Conscrypt API<br>现在，Conscrypt 安全提供程序包含适用于 TLS 功能的公共 API。过去，用户可以通过反射来访问此功能。但是，由于在 Android P 中增加了关于调用非公共 API 的限制，因此这已在 Android Q 中加入了灰名单，并将在未来版本中进一步受限。</p><p>此更新在 android.net.ssl 下增加了一组类，这些类包含用于访问通用 javax.net.ssl API 不提供的功能的静态方法。这些类的名称为相关 javax.net.ssl 类的复数，用户可以由此推断是否为这些类。例如，在 javax.net.ssl.SSLSocket 实例中运行的代码可以使用新的 android.net.ssl.SSLSockets 类中的方法。</p><p>连接功能<br>Android Q 包含一些与网络和连接相关的改进。</p><p>WLAN 网络连接 API<br>Android Q 增加了对点对点连接的支持。借助此功能，应用可以使用 WifiNetworkSpecifier 描述所请求网络的属性，以此来提示用户更改设备连接到的接入点。点对点连接用于“非网络提供”目的，例如 Chromecast 和 Google Home 硬件等辅助设备的引导配置。</p><p>使用此 API 时，您需要遵循以下流程：</p><p>使用 WifiNetworkSpecifier.Builder 创建 WLAN 网络说明符。</p><p>设置网络过滤器以匹配要连接到的网络以及所需凭据。</p><p>在每个请求中确定 SSID、SSID pattern、BSSID 和 BSSID pattern 的组合以设置网络过滤器，但要遵循以下要求：</p><p>每个请求都应该至少提供 SSID、SSID pattern、BSSID 或 BSSID pattern 中的一个<br>每个请求都只能设置 SSID 或 SSID pattern 中的一个<br>每个请求都只能设置 BSSID 或 BSSID pattern 中的一个<br>将说明符以及一个 NetworkCallback 实例添加到该网络请求中，以跟踪该请求的状态。</p><p>如果用户接受该请求且成功连接到网络，则系统将对回调对象调用 NetworkCallback.onAvailable()。如果用户拒绝该请求或未成功连接到网络，则系统将对回调对象调用 NetworkCallback.onUnavailable()。</p><p>点对点连接不需要位置权限和 WLAN 权限。如果您发起连接到对等设备的请求，便会在同一设备上启动一个对话框，让相应设备的用户可以通过此对话框来接受连接请求。</p><p>绕过用户批准<br>用户应某个特定应用的请求批准连接到某个网络后，设备便会存储用户针对相应接入点的批准响应。如果该应用再次发出连接到此接入点的特定请求，则设备会跳过用户批准阶段，并自动连接到此网络。在连接到 API 请求的网络后，如果用户选择取消保存该网络，则系统会移除该应用和网络组合对应的已存储批准响应，相应应用将来发出的任何请求都需要由用户再次批准。如果应用发出非特定（例如使用 SSID 或 BSSID pattern）请求，则用户需要批准相应请求。</p><p>代码示例<br>以下代码示例显示了如何使用前缀为“test”的 SSID 和 OUI 为“10:03:23”的 BSSID 连接到开放网络。</p><h6 id="KOTLIN"><a href="#KOTLIN" class="headerlink" title="KOTLIN"></a>KOTLIN</h6><pre><code>val specifier = WifiNetworkSpecifier.Builder()    .setSsidPattern(PatternMatcher(&quot;test&quot;, PatternMatcher.PATTERN_PREFIX))    .setBssidPattern(MacAddress.fromString(&quot;10:03:23:00:00:00&quot;), MacAddress.fromString(&quot;ff:ff:ff:00:00:00&quot;))    .build()val request = NetworkRequest.Builder()    .addTransportType(NetworkCapabilities.TRANSPORT_WIFI)    .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)    .setNetworkSpecifier(specifier)    .build()val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManagerval networkCallback = object : ConnectivityManager.NetworkCallback() {    ...    override fun onAvailable(network: Network?) {        // do success processing here..    }    override fun onUnavailable() {        // do failure processing here..    }    ...}connectivityManager.requestNetwork(request, networkCallback)...// Release the request when done.connectivityManager.unregisterNetworkCallback(networkCallback)</code></pre><p>WLAN 网络建议 API<br>Android Q 扩大了支持范围，现在允许应用为设备添加网络凭据，以自动连接到 WLAN 接入点。您可以使用 WifiNetworkSuggestion 提供关于要连接到哪个网络的建议。平台最终会根据您的应用和其他应用的输入来选择要接受的接入点。</p><p>以下代码示例显示了如何为一个开放网络、一个 WPA2 网络和一个 WPA3 网络提供凭据：</p><h6 id="KOTLIN-1"><a href="#KOTLIN-1" class="headerlink" title="KOTLIN"></a>KOTLIN</h6><pre><code>val suggestion1 = WifiNetworkSuggestion.Builder()        .setSsid(&quot;test111111&quot;)        .setIsAppInteractionRequired() // Optional (Needs location permission)        .build()val suggestion2 = WifiNetworkSuggestion.Builder()        .setSsid(&quot;test222222&quot;)        .setWpa2Passphrase(&quot;test123456&quot;)        .setIsAppInteractionRequired() // Optional (Needs location permission)        .build()val suggestion3 = WifiNetworkSuggestion.Builder()        .setSsid(&quot;test333333&quot;)        .setWpa3Passphrase(&quot;test6789&quot;)        .setIsAppInteractionRequired() // Optional (Needs location permission)        .build()val suggestionsList = listOf(suggestion1, suggestion2, suggestion3)val wifiManager = context.getSystemService(Context.WIFI_SERVICE) as WifiManagerval status = wifiManager.addNetworkSuggestions(suggestionsList);if (status != WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS) {    // do error handling here}// Optional (Wait for post connection broadcast to one of your suggestions)val intentFilter = IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION);val broadcastReceiver = object : BroadcastReceiver() {    override fun onReceive(context: Context, intent: Intent) {        if (!intent.action.equals(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) {            return;        }        // do post connect processing here    }};context.registerReceiver(broadcastReceiver, intentFilter);</code></pre><p>来自应用的建议必须先得到用户批准，然后平台才会发起到建议的网络的连接。当平台第一次在扫描结果中找到与应用提供的其中一个建议相匹配的网络时，将由用户响应通知进行批准。当平台连接到建议的其中某个网络时，设置会显示相关文本以将网络连接归因于提出建议的相应应用。</p><p>处理用户断开连接的行为<br>如果用户在应用连接到建议的某个网络时使用 WLAN 选择器明确断开与该网络的连接，则该网络会被列入黑名单 24 小时。在该网络被列入黑名单期间，即使应用移除并重新添加与该网络对应的网络建议，系统也不会考虑自动连接该网络。</p><p>更改应用的审批状态<br>用户拒绝接收网络建议通知时会从应用中移除 CHANGE_WIFI_STATE 权限。用户稍后可以通过转到 WLAN 控制菜单（依次转到设置 &gt; 应用和通知 &gt; 特殊应用权限 &gt; WLAN 控制 &gt; 应用名称）对此作出批准。</p><p>改进了 WLAN 高性能和低延迟模式<br>借助 Android Q，您可以为底层调制解调器提供提示，以最大限度地缩短延迟。</p><p>Android Q 扩展了 WLAN Lock API，以有效地支持高性能和低延迟模式。系统会针对高性能和低延迟模式停用 WLAN 节能模式，并且您可以在低延迟模式下启用进一步的延迟优化（具体取决于调制解调器支持）。</p><p>仅当获取锁的应用在前台运行且屏幕处于开启状态时才能启用低延迟模式。低延迟模式对实时移动游戏应用尤其有用。</p><p>DNS 解析器中的专用查找<br>Android Q 增加了对“通过传输层安全协议 (TLS) 执行 DNS”和进行专用 DNS 查找的支持。以前，平台 DNS 解析器支持 A 类解析，它可以根据域名来解析 IP 地址，而无需与通过此 IP 提供的服务有关的具体信息。经过此次更新，它现在还支持 SRV 和 NAPTR 查找。</p><p>Android Q 可以为开发者提供标准明文查找和“通过传输层安全协议 (TLS) 执行 DNS”模式。</p><p>WLAN Easy Connect<br>借助 Android Q，您可以利用 Easy Connect 为对等设备配置 WLAN 凭据，以替代已弃用的 WPS。应用可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 将 Easy Connect 集成到其设置和配置流程中。此 intent 需要 URI。调用应用可以通过各种方法来检索 URI，包括扫描贴纸或显示屏中的二维码，或扫描蓝牙 LE 或 NFC 广告。</p><p>URI 一经可用，您就可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 来配置对等设备的 WLAN 凭据。这样一来，用户就可以选择 WLAN 网络以共享并安全地传输相关凭据。</p><p>Easy Connect 不需要位置权限或 WLAN 权限。</p><p>注意：在使用此 intent 之前，应用必须先通过调用 WifiManager.isEasyConnectSupported() 验证设备是否支持 Easy Connect。<br>Wi-Fi Direct connection API<br>WifiP2pConfig 和 WifiP2pManager API 类在 Android Q 中有更新，以支持利用预先确定的信息快速与 WLAN 直连建立连接的功能。此信息通过边信道进行共享，例如蓝牙或 NFC。</p><p>以下代码示例显示了如何使用预先确定的信息来创建群组：</p><h6 id="KOTLIN-2"><a href="#KOTLIN-2" class="headerlink" title="KOTLIN"></a>KOTLIN</h6><pre><code>val manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManagerval channel = manager.initialize(this, mainLooper, null)// prefer 5G band for this groupval config = WifiP2pConfig.Builder()    .setNetworkName(&quot;networkName&quot;)    .setPassphrase(&quot;passphrase&quot;)    .enablePersistentMode(false)    .setGroupOperatingBand(WifiP2pConfig.GROUP_OWNER_BAND_5GHZ)    .build()// create a non-persistent group on 5GHzmanager.createGroup(channel, config, null)</code></pre><p>要使用凭据加入群组，请将 manager.createGroup() 替换为以下内容：</p><p>KOTLIN<br>    manager.connect(channel, config, null)</p><p>蓝牙 LE 连接导向型频道 (CoC)<br>借助 Android Q，您的应用可以使用 BLE CoC 连接在两个 BLE 设备之间传输较大的数据流。此接口抽象化处理了蓝牙和连接机制，以简化实现。</p><p>电话功能<br>Android Q 包含一些与电话相关的改进。</p><p>通话质量方面的改进<br>Android Q 增加了在支持相关功能的设备上收集进行中的 IP 多媒体子系统 (IMS) 通话质量相关信息的功能，包括通过网络接听和拨打电话的质量。</p><p>选接电话和来电显示<br>Android Q 让您的应用可以将用户通讯录中不存在号码的来电标识为潜在骚扰电话，以及代表用户拒接骚扰电话而不响铃。系统会在通话记录中将这些已屏蔽的来电的相关信息记录为已屏蔽的来电，以便用户更清楚地了解何时有过未接来电。使用此新版 API，不需要从用户那里获取 READ_CALL_LOG 权限就可以提供选接电话和来电显示功能。</p><p>Call Redirection Service API<br>Android Q 更改了来电 Intent 的处理方式。我们弃用了 NEW_OUTGOING_CALL 广播，并将其替换为 CallRedirectionService API。CallRedirectionService 提供了相关接口，以供您修改 Android 平台拨打的去电。例如，第三方应用可能会取消通话并通过 VoIP 对其进行重新路由。</p><p>在外部存储设备中创建文件的相关改进<br>除了引入分区存储隐私权行为变更之外，Android Q 还在写入文件方面提供了更大的灵活性，添加了可以帮助您影响这些文件在外部存储设备上的保存位置的功能。</p><p>新媒体文件的待处理状态<br>Android Q 引入了 IS_PENDING 标记，通过此标记，您的应用可以在媒体文件写入磁盘时进行独占访问。</p><p>以下代码段显示了在应用中创建新图片时如何使用 IS_PENDING 标记。</p><h6 id="KOTLIN-3"><a href="#KOTLIN-3" class="headerlink" title="KOTLIN"></a>KOTLIN</h6><pre><code>val values = ContentValues().apply {    put(MediaStore.Images.Media.DISPLAY_NAME, &quot;IMG1024.JPG&quot;)    put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;)    put(MediaStore.Images.Media.IS_PENDING, 1)}val resolver = context.getContentResolver()val collection = MediaStore.Images.Media        .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY)val item = resolver.insert(collection, values)resolver.openFileDescriptor(item, &quot;w&quot;, null).use { pfd -&gt;    // Write data into the pending image.}// Now that we&apos;re finished, release the &quot;pending&quot; status, and allow other apps// to view the image.values.clear()values.put(MediaStore.Images.Media.IS_PENDING, 0)resolver.update(item, values, null, null)</code></pre><p>对存储位置的影响<br>Android Q 引入了多种功能，可以帮助您整理您的应用存储在外部存储设备上的文件。</p><p>目录提示<br>当您的应用将媒体存储在搭载 Android Q 的设备上时，系统默认按照媒体的类型对其进行整理。例如，默认情况下，新图片文件会存储在“pictures”目录下。</p><p>如果您的应用知道应存储文件的具体位置（例如 Pictures/MyVacationPictures），您可以设置 MediaColumns.RELATIVE_PATH，以便提示系统在何处存储新写入的文件。同样，您可以在调用 update() 期间通过更改 MediaColumns.RELATIVE_PATH 或 MediaColumns.DISPLAY_NAME 来移动磁盘上的文件。</p><p>设备选择<br>在 Android 9（API 级别 28）及更低版本中，保存到外部存储设备上的所有文件都显示在名为 external 的单个卷下。但是，Android Q 为每个外部存储设备都提供唯一的卷名称。这一新的命名系统可帮助您高效地整理内容并将内容编入索引，还可让您控制新内容的存储位置。</p><p>主要共享存储设备始终称为 VOLUME_EXTERNAL_PRIMARY。您可以通过调用 MediaStore.getExternalVolumeNames() 发现其他卷。</p><p>要查询、插入、更新或删除特定卷，请将卷名称传递到 MediaStore API 中的任何 getContentUri() 方法，如以下代码段中所示：</p><pre><code>// Publish an audio file onto a specific external storage device.val values = ContentValues().apply {    put(MediaStore.Audio.Media.RELATIVE_PATH, &quot;Music/My Album/My Song&quot;)    put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Song.mp3&quot;)}// Assumes that the storage device of interest is the 2nd one// that your app recognizes.val volumeNames = MediaStore.getExternalVolumeNames(context)val selectedVolumeName = volumeNames[1]val collection = MediaStore.Audio.Media.getContentUri(selectedVolumeName)val item = resolver.insert(collection, values)</code></pre><p>注意：在 Android Q 中，StorageVolume 类中的 createAccessIntent() 方法已被弃用，因此您不应使用此方法浏览外部存储设备。如果您这么做，Android Q 设备的用户将无法在您的应用中查看保存在外部存储设备中的文件。<br>媒体和图形<br>Android Q 引入了以下媒体和图形方面的新功能和 API：</p><p>捕获播放的音频<br>Android Q 可让应用捕获其他应用播放的音频。要了解所有详情，请参阅捕获播放的音频。</p><p>原生 MIDI API<br>借助 Android Native MIDI API (AMidi)，应用开发者可以使用 C/C++ 代码发送和接收 MIDI 数据、与 C/C++ 音频/控制逻辑进行更紧密的集成以及最大限度地减少对 JNI 的需求。</p><p>有关详情，请参阅 Android Native MIDI API。</p><p>MediaCodecInfo 方面的改进<br>MediaCodecInfo 中有一些新方法可以显示有关编解码器的更多信息：</p><p>isSoftwareOnly()<br>如果编解码器仅在软件中运行，则返回 true。软件编解码器并不能保证渲染性能。<br>isHardwareAccelerated()<br>如果编解码器由硬件加速，则返回 true。<br>isVendor()<br>如果编解码器由设备供应商提供，则返回 true；如果由 Android 平台提供，则返回 false。<br>isAlias()<br>MediaCodecList 可能针对使用备用编解码器名称（别名）的同一底层编解码器包含额外的条目。如果此条目中的编解码器是另一个编解码器的别名，则此方法会返回 true。<br>此外，MediaCodec.getCanonicalName() 会针对通过别名创建的编解码器返回底层编解码器名称。</p><p>性能点<br>“性能点”表示编解码器以特定高度、宽度和帧速率渲染视频的能力。例如，UHD_60 性能点表示以每秒 60 帧的速度渲染超高清视频（3840x2160 像素）。</p><p>方法 MediaCodecInfo.VideoCapabilities.getSupportedPerformancePoints() 会返回编解码器可以渲染或捕获的 PerformancePoint 条目列表。</p><p>您可以通过调用 PerformancePoint.covers(PerformancePoint) 检查给定的 PerformancePoint 是否会覆盖另一个性能点。例如，UHD_60.covers(UHD_50) 会返回 true。</p><p>我们为所有硬件加速的编解码器都提供了性能点列表。如果编解码器连标准性能点的最低值都不能满足，则此列表可能为空。</p><p>请注意，已升级到 Android Q 但未更新供应商映像的设备是没有性能点数据的，因为此数据来自供应商 HAL。在这种情况下，getSupportedPerformancePoints() 会返回 null。</p><p>ANGLE<br>在 Android Q 发布后，Android 开发者和合作伙伴可以选择使用 ANGLE 运行应用；ANGLE 是 Chrome 组织中的一个项目，能够将 ES 置于 Vulkan 上层，而不必使用供应商提供的 ES 驱动程序。</p><p>有关详情，请参阅 ANGLE。</p><p>Thermal API<br>当设备过热时，它们可能会限制 CPU 和/或 GPU，而这可能会以意想不到的方式影响应用和游戏。使用复杂图形、大量计算或持续网络活动的应用更有可能遇到问题，并且问题可能因芯片组和核心频率、集成级别以及设备封装和设备类型而异。</p><p>现在，在 Android Q 中，应用和游戏可以使用 Thermal API 监控设备变化情况，并在设备过热时采取措施维持低电耗状态，使设备恢复到正常温度。应用在 PowerManager 中注册监听器，系统通过该监听器报告持续的热状态，热状态的范围从轻度和中度到重度、危急、紧急和关机。</p><p>当设备报告热应力时，各应用和游戏可以减少正在进行的活动，以此来帮助减少各个方面的耗电量。例如，影音在线播放应用可以降低分辨率/比特率或减少网络流量；相机应用可以停用闪光灯或密集型图像增强；游戏可以降低帧速率或减少多边形曲面细分；媒体应用可以降低扬声器音量；地图应用可以关闭 GPS。</p><p>Thermal API 需要新的设备 HAL 层，目前在搭载 Android Q 的 Pixel 设备上受支持。我们正在与设备制造商合作伙伴合作，以期尽快为生态系统提供广泛支持。</p><p>摄像头和图片<br>Android Q 引入了摄像头和图片方面的以下新功能：</p><p>单色摄像头支持<br>Android 9（API 等级 28）首次引入了单色摄像头功能。Android Q 为单色摄像头支持增加了几项增强功能：</p><p>新增了对 Y8 流格式的支持，以提高内存效率。<br>支持单色原始 DNG 捕获。<br>引入了 MONO 和 NIR CFA 枚举，以区分常规单色摄像头和近红外摄像头。<br>您可以使用此功能来捕捉原生单色图片。逻辑多摄像头设备可以使用单色摄像头作为物理子摄像头，以获取更出色的低光图片质量。</p><p>动态深度格式<br>从 Android Q 开始，摄像头可以使用名为“动态深度格式”(DDF) 的新架构将图片的深度数据存储在单独的文件中。应用可以请求 JPG 图片及其深度元数据，以便在后期处理中利用这些信息来应用所需的模糊处理，而无需修改原始图片数据。</p><p>要了解新格式的规范，请参阅动态深度格式。</p><p>高效率图片文件格式<br>高效率图片文件 (HEIF) 格式是一种标准的图片和视频格式，与其他文件格式相比，这种格式的编码质量更高，文件更小。</p><p>如需详细了解此文件格式，请参阅 HEIC。</p><p>多摄像头方面的改进<br>Android 9（API 级别 28）中引入了将多摄像头融合成单个逻辑摄像头的功能，Android Q 对此功能进行了改进。Camera2 API 中添加了以下内容：</p><p>isSessionConfigurationSupported(SessionConfiguration sessionConfig) - 使您能够查询传递的会话配置能否用于创建摄像头拍摄会话。</p><p>LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID - 使您能够确定支持逻辑摄像头设备的有效物理摄像头的 ID。您可以使用返回的 ID 来请求逻辑信息流和物理子摄像头信息流，以提高用电效率。</p><p>无障碍服务 API<br>Android Q 引入了以下新的无障碍服务功能和 API：</p><p>AccessibilityNodeInfo 输入键标记<br>在 Android Q 中，AccessibilityNodeInfo 得到了增强，现在增加了一个新标记，用于指示其是否代表文本输入键的。您可以使用 AccessibilityNodeInfo.isTextEntryKey() 方法来访问此标记。</p><p>无障碍对话框语音反馈<br>当无障碍服务要求用户重复按无障碍快捷方式以启动服务时，此对话框现在可以在服务请求时附带文字转语音提示。</p><p>物理键盘的无障碍快捷方式<br>在 Android Q 中，用户现在可以通过物理键盘来触发无障碍快捷方式，只需按 Control+Alt+Z 即可。</p><p>软键盘控制器增强功能<br>在 Android Q 中，无障碍服务现在可以请求显示软键盘，即使设备检测到连接了硬键盘也不例外。用户可以替换此行为。</p><p>用户定义的无障碍服务超时<br>Android Q 引入了 API 方法 AccessibilityManager.getRecommendedTimeoutMillis()，用于为用户针对互动式和非互动式的无障碍界面元素定义的超时提供支持。返回值受用户偏好设置和无障碍服务 API 的影响。</p><p>自动填充方面的改进<br>Android Q 包含对自动填充服务的以下改进。</p><p>与兼容性相关的自动填充请求<br>您现在可以使用 FillRequest.FLAG_COMPATIBILITY_MODE_REQUEST 标记确定是否通过兼容性模式生成了自动填充请求。</p><p>同时保存用户名和密码<br>借助 SaveInfo.FLAG_DELAY_SAVE 标记，应用现在可以使用多个 Activity 显示用户名、密码和其他字段。</p><p>用户与保存界面的互动<br>您现在可以在保存对话框中显示和隐藏密码字段，只需在此对话框中设置操作监听器，并更改相应密码远程视图的可见性即可。</p><p>支持更新数据集<br>现在，自动填充功能可以更新现有密码。例如，如果用户已经存储了一个密码，然后又保存了一个新密码，则自动填充功能现在会提示用户更新现有密码，而不是保存新密码。</p><p>字段分类方面的改进<br>Android Q 包含对 Field Classification API 的以下改进。</p><p>UserData.Builder 构造函数<br>我们更改了 UserData.Builder 构造函数，现在可以更好地契合 Builder 模式。</p><p>允许将一个值映射到多种类别 ID<br>在使用 Android Q 中的 UserData.Builder 时，您现在可以将一个值映射到多种类别 ID。在以前的版本中，如果一个值被添加多次，系统就会抛出异常。</p><p>改进了对信用卡号码的支持<br>现在，字段分类可以检测四位数字作为信用卡号码的最后四位数字。</p><p>支持特定于应用的字段分类<br>Android Q 增加了 FillResponse.setUserData()，让您能够在会话期间设置特定于应用的用户数据。这有助于自动填充服务检测包含特定于应用的内容的字段的类型。</p><p>界面和系统控件<br>Android Q 提供以下界面方面的改进：</p><p>支持 JVMTI PopFrame 功能<br>Android Q 增加了对 Android JVMTI 实现中的 can_pop_frames 功能的支持。在调试时，此功能让您能够在断点暂停并调整函数的局部变量、全局变量或实现，然后重新运行函数。有关详情，请参阅 Oracle 的 Pop Frame 参考页面。</p><p>Surface Control API<br>Android Q 提供了一个 SurfaceControl API，用于对系统合成器 (SurfaceFlinger) 进行底层访问。对于大多数用户而言，SurfaceView 是使用此合成器的正确方法。SurfaceControl API 在某些情况下很有用，例如：</p><p>同步多个表面<br>跨进程的表面嵌入<br>底层生命周期管理<br>SurfaceControl API 在 SDK 和 NDK 绑定中都可用。NDK 实现包含用于与合成器手动交换缓冲区的 API。这为遇到 BufferQueue 限制的用户提供了一种替代方案。</p><p>WebView 挂起渲染程序检测<br>Android Q 引入了一个新的 WebViewRenderProcessClient 抽象类，应用可以使用该抽象类检测 WebView 是否无响应。要使用此类，请执行以下操作：</p><p>定义您自己的子类，并实现其 onRenderProcessResponsive() 和 onRenderProcessUnresponsive() 方法。<br>将 WebViewRenderProcessClient 的实例附加到一个或多个 WebView 对象上。<br>如果 WebView 无响应，系统将调用客户端的 onRenderProcessUnresponsive() 方法，在调用时会传递 WebView 和 WebViewRenderProcess（如果 WebView 是单进程，WebViewRenderProcess 参数将为 null）。您的应用可以执行适当的操作，例如向用户显示一个对话框，以询问其是否要暂停渲染流程。<br>如果 WebView 仍然无响应，则系统会定期调用 onRenderProcessUnresponsive()（频率不高于每 5 秒一次），但不会执行其他任何操作。如果 WebView 再次无响应，系统只调用 onRenderProcessResponsive() 一次。</p><p>设置面板<br>Android Q 引入了“设置面板”，这是一种 API，让应用能够在自身环境中向用户显示设置。这可以避免用户转到设置更改 NFC 或移动数据等设置，以便使用此应用。</p><p>图 1. 用户尝试在设备未连接到网络时打开网页。Chrome 弹出互联网连接设置面板…</p><p>图 2. 用户可以开启 WLAN 并选择网络，而无需离开 Chrome 应用。<br>例如，假设用户打开了网络浏览器，而其设备已开启飞行模式。在 Android Q 之前的版本中，此应用只能显示一条通用消息，要求用户打开设置以恢复连接。而借助 Android Q，浏览器应用便可以显示一个内嵌面板，其中会显示各种主要连接设置，例如飞行模式、WLAN（包括附近的网络）和移动数据。借助此面板，用户无需离开应用即可恢复连接。</p><p>要显示设置面板，请发出具有某个新 Settings.Panel 操作的 intent：</p><h6 id="KOTLIN-4"><a href="#KOTLIN-4" class="headerlink" title="KOTLIN"></a>KOTLIN</h6><pre><code>val panelIntent = Intent(Settings.Panel.settings_panel_type)startActivityForResult(panelIntent)</code></pre><p>settings_panel_type 可以是下列项之一：</p><p>ACTION_INTERNET_CONNECTIVITY<br>显示与互联网连接相关的设置，例如飞行模式、WLAN 和移动数据。<br>ACTION_WIFI：<br>显示 WLAN 设置，但不显示其他连接设置。这对于需要 WLAN 连接以执行大容量上传或下载的应用非常有用。<br>ACTION_NFC<br>显示与近距离无线通信 (NFC) 相关的所有设置。<br>ACTION_VOLUME<br>显示所有音频流的音量设置。<br>我们计划针对此功能引入一个 AndroidX 封装容器。在搭载 Android 9（API 级别 28）或更低级别的设备上调用时，此封装容器会在设置应用中打开最合适的页面。</p><p>共享功能方面的改进<br>Android Q 为共享功能提供了多项改进。要了解所有详情，请参阅 Android Q 中共享功能方面的改进。</p><p>深色主题背景<br>Android Q 提供全新的深色主题背景，既会应用于 Android 系统界面，也会应用于设备上运行的应用。要了解所有详情，请参阅深色主题背景。</p><p>前台服务类型<br>Android Q 引入了一个新的 XML 清单属性 foregroundServiceType，您可以将其包含在多项特定服务的定义中。虽然很少适用，但您可以为一项特定服务分配多个前台服务类型。</p><p>下表显示了不同的前台服务类型，以及适合在其中声明特定类型的服务：</p><p>前台服务类型    应声明相应类型的服务的示例使用情形<br>connectedDevice    监控穿戴式设备健身跟踪器<br>dataSync    从网络下载文件<br>location    延续用户发起的操作<br>mediaPlayback    播放有声读物、播客或音乐<br>mediaProjection    简短地录屏<br>phoneCall    处理正在进行的通话<br>Kotlin<br>Android Q 对 Kotlin 开发进行了以下更新。</p><p>libcore API 的可空性注释<br>Android Q 改进了 SDK 中针对 libcore API 的可空性注释的覆盖范围。借助这些注释，在 Android Studio 中使用 Kotlin 或 Java 可空性分析的应用开发者可以在与这些 API 互动时获取非 Null 信息。</p><p>通常，Kotlin 中的为空性合同违规行为会导致编译错误。为确保与现有代码兼容，所有新注释都仅限于 @RecentlyNullable 和 @RecentlyNonNull。这意味着为空性违规行为会引发警告，而不是错误。</p><p>此外，Android 9 中添加的所有 @RecentlyNullable 或 @RecentlyNonNull 注释都会分别更改为 @Nullable 和 @NonNull。这意味着为空性违规行为现在会引发错误，而不是警告。</p><p>要详细了解注释方面的变更，请参阅 Android 开发者博客中的 Android Pie SDK 现已更适用于 Kotlin一文。</p><p>NDK<br>Android Q 包含以下 NDK 方面的变更。</p><p>改进了文件描述符所有权的调试<br>Android Q 增加了 fdsan，它可以帮助您更轻松地查找和修复文件描述符所有权方面的问题。</p><p>与错误处理文件描述符所有权相关的错误（通常表现为“use-after-close”和“double-close”）类似于内存分配“use-after-free”和“double-free”错误，但通常更难以诊断和修复。“fdsan”会尝试通过强制执行文件描述符所有权来检测和/或防止文件描述符误管理。</p><p>要详细了解与这些问题相关的崩溃，请参阅 fdsan 检测到的错误。要详细了解 fdsan，请参阅关于 fdsan 的 Googlesource 页面。</p><p>ELF TLS<br>使用 API 级别 29 及更高版本的 NDK 编译的应用无需再使用 emutls，但可以改为使用 ELF TLS。我们增加了对动态和静态链接器的支持，以支持处理线程局部变量的新方法。</p><p>对于针对 API 级别 28 及更低版本编译的应用，我们实现了针对 libgcc/compiler-rt 的改进，以便解决一些 emutls 问题。</p><p>有关详情，请参阅面向 NDK 开发者的 Android 变更。</p><p>运行时<br>Android Q 包含以下运行时方面的变更。</p><p>触发基于 Mallinfo 的垃圾回收<br>当小型平台 Java 对象引用 C++ 堆中的大型对象时，通常只有在系统已回收并（举例而言）最终确定 Java 对象后，才能回收 C++ 对象。在之前的版本中，平台会估算与 Java 对象相关联的许多 C++ 对象的大小。这种估算并不总是准确，并且偶尔会导致内存使用量大大增加，因为平台无法在应该进行垃圾回收时完成回收。</p><p>在 Android Q 中，垃圾回收器 (GC) 会跟踪系统 malloc() 分配的堆的总大小，以确保 malloc() 分配的大型堆始终包含在可触发 GC 的计算中。因此，与 Java 执行交错大量 C++ 分配的应用可能会出现垃圾回收频率提高的现象。其他应用的频率则可能会略有下降。</p><p>测试和调试<br>Android Q 包含以下测试和调试方面的改进。</p><p>改进了设备上系统跟踪功能<br>现在，您在执行设备上系统跟踪时可以指定跟踪的记录大小和持续时间限制。在您指定任一值后，系统便会执行长期跟踪，并在记录跟踪时定期将跟踪缓冲区复制到目标文件。在达到您指定的记录大小或持续时间限制后，跟踪便会完成。</p><p>请使用这些附加参数来测试除了您使用标准跟踪进行测试的用例之外的其他用例。例如，您可能正在诊断某个性能错误，而此错误仅在您的应用长时间运行后才会发生。在这种情况下，您可以记录为期一整天的长期跟踪，然后分析 CPU 调度程序、磁盘活动、应用线程以及报告中的其他数据，以帮助您确定造成此错误的原因。</p><p>TextClassifier 改进<br>Android Q 在 TextClassifier 接口中提供了其他文本分类功能。</p><p>语言检测<br>TextClassifier 现在具有 detectLanguage() 方法。此方法的工作方式与现有分类方法类似，即接收 TextLanguage.Request 对象并返回 TextLanguage 对象。</p><p>新的 TextLanguage 对象包含一系列有序对。每个有序对都包含所请求文本示例的语言区域和相应的置信度得分。</p><p>建议采取的对话操作<br>TextClassifier 现在具有 suggestConversationActions() 方法。此方法的工作方式与现有分类方法类似，即接收 ConversationActions.Request 对象并返回 ConversationActions 对象。</p><p>新的 ConversationActions 对象包含一系列 ConversationAction 对象。每个 ConversationAction 对象都包含建议采取的可行操作及其置信度得分。</p><p>通知中的智能回复/操作<br>Android 9 引入了在通知中显示建议回复的功能。从 Android Q 开始，通知中还可以包含基于 intent 的建议操作。此外，现在系统可以自动生成这些建议。应用仍然可以提供它们自己的建议，或选择停用系统生成的建议。</p><p>用于生成这些回复的 API 是 TextClassifier 的一部分，且已在 Android Q 中直接提供给开发者。如需了解详情，请参阅关于 TextClassifier 改进的部分。</p><p>如果您的应用提供自己的建议，则平台不会生成任何自动建议。如果您不希望应用的通知显示任何建议回复或操作，可以通过使用 setAllowGeneratedReplies() 和 setAllowSystemGeneratedContextualActions() 选择停用系统生成的回复和操作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Android-Q-功能和-API&quot;&gt;&lt;a href=&quot;#Android-Q-功能和-API&quot; class=&quot;headerlink&quot; title=&quot;Android Q 功能和 API&quot;&gt;&lt;/a&gt;Android Q 功能和 API&lt;/h1&gt;&lt;p&gt;Android Q 
      
    
    </summary>
    
      <category term="Android" scheme="http://zhangyongfa888.site/categories/Android/"/>
    
    
      <category term="Android" scheme="http://zhangyongfa888.site/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>滴滴调整北京市网约车价格 将16区按计价标准划分为5大类</title>
    <link href="http://zhangyongfa888.site/2019/07/10/HEXO-Admin/"/>
    <id>http://zhangyongfa888.site/2019/07/10/HEXO-Admin/</id>
    <published>2019-07-10T02:57:00.000Z</published>
    <updated>2019-09-03T00:23:11.641Z</updated>
    
    <content type="html"><![CDATA[<h4 id="滴滴调整北京市网约车价格-将16区按计价标准划分为5大类"><a href="#滴滴调整北京市网约车价格-将16区按计价标准划分为5大类" class="headerlink" title="滴滴调整北京市网约车价格 将16区按计价标准划分为5大类"></a>滴滴调整北京市网约车价格 将16区按计价标准划分为5大类</h4><p>本报讯（记者 陈雪柠）针对不同时间的需求状况，滴滴将对本市网约车价格进行调整。昨天，滴滴出行发布本市滴滴网约车价格调整说明，宣布自7月11日起，滴滴网约车将根据区域进行价格调整。</p><p>　　滴滴将全市16区按计价标准划分为5大类。其中，东城区、西城区、海淀区、朝阳区、丰台区、石景山区、昌平区、门头沟区为一类，顺义区、通州区、大兴区、房山区为一类，密云区、怀柔区为一类，延庆区及平谷区则各自单独计价。</p><p>　　以东城区、西城区等区域计价标准看，调整后，工作日早6点至10点的早高峰时段，起步价由13元涨至14元，里程费由1.6元/公里涨至1.8元/公里，时长费不变；早10点至晚5点的平峰时段，里程费由1.6元/公里降至1.45元/公里，时长费由0.5元/公里降至0.4元/公里，起步价不变；晚5点至晚9点的晚高峰时段，起步价由13元涨至14元，里程费由1.6元/公里降至1.5元/公里，时长费不变；晚9点至早6点的夜间时段，起步价由13元涨至14元，里程费由1.6元/公里涨至2.15元/公里，时长费由1元降至0.8元/公里。</p><p>  <img src="http://res.zhangyongfa888.site/1562729905085rk2iy94h.png?imageslim" alt="paste image"><br>　　总体看，高峰时段价格普遍上涨，平峰时段价格有所降低。远郊区起步价降低，其中延庆区、平谷区起步价均为8元，密云区、怀柔区起步价也降低为11.5元。</p><p>　　对于价格调整的原因，滴滴出行表示是调节供需平衡，撮合司乘需求。“我们会基于不同城市不同时间的供需状况，并参考当地的消费水平、收入水平和能源价格等因素，合理地调整网约车价格。价格机制要满足乘客需求，还要让司机能获得合理的收入。”</p><p>　　滴滴建议市民合理安排行程尽量错峰出行；在高峰期用车可选择“同时呼叫”或拼车，提高出行效率；不好叫车时，可选择APP内单车或“公交”路线査询功能，选择其他出行方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;滴滴调整北京市网约车价格-将16区按计价标准划分为5大类&quot;&gt;&lt;a href=&quot;#滴滴调整北京市网约车价格-将16区按计价标准划分为5大类&quot; class=&quot;headerlink&quot; title=&quot;滴滴调整北京市网约车价格 将16区按计价标准划分为5大类&quot;&gt;&lt;/a&gt;滴滴
      
    
    </summary>
    
      <category term="NEWS" scheme="http://zhangyongfa888.site/categories/NEWS/"/>
    
    
      <category term="互联网" scheme="http://zhangyongfa888.site/tags/%E4%BA%92%E8%81%94%E7%BD%91/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://zhangyongfa888.site/2019/07/09/hello-world/"/>
    <id>http://zhangyongfa888.site/2019/07/09/hello-world/</id>
    <published>2019-07-09T07:09:38.366Z</published>
    <updated>2019-07-09T07:09:38.366Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
