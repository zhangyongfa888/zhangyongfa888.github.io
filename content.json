{"meta":{"title":"WE ARE YOUNG","subtitle":"So let's set the world on fire","description":null,"author":"zhangyognfa","url":"http://github.zhangyongfa888.site","root":"/"},"pages":[{"title":"分类","date":"2019-07-09T07:41:26.000Z","updated":"2019-07-10T05:07:09.428Z","comments":false,"path":"categories/index.html","permalink":"http://github.zhangyongfa888.site/categories/index.html","excerpt":"","text":"分类1"},{"title":"日常分享","date":"2019-07-31T00:28:23.000Z","updated":"2019-08-14T05:33:28.356Z","comments":true,"path":"share/index.html","permalink":"http://github.zhangyongfa888.site/share/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-09T07:40:35.000Z","updated":"2019-07-10T05:01:57.990Z","comments":false,"path":"tags/index.html","permalink":"http://github.zhangyongfa888.site/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Android唯一识别码 获取","slug":"Android唯一识别码-获取","date":"2019-08-28T03:52:19.000Z","updated":"2019-08-28T06:17:18.419Z","comments":true,"path":"2019/08/28/Android唯一识别码-获取/","link":"","permalink":"http://github.zhangyongfa888.site/2019/08/28/Android唯一识别码-获取/","excerpt":"","text":"前言目前有个需求，需要获取设备的唯一识别码 标记用户的手机,在android低版本上很好实现，imei或者deviceID之间能够拿到，但是android10已经不给此项权限了……于是开始找资料。 不可重置的设备标识符 ：官（墙）方（外）推荐方法从 Android Q 开始，应用必须具有 READ_PRIVILEGED_PHONE_STATE 特许权限才能访问设备的不可重置标识符（包含 IMEI 和序列号）。许多用例不需要不可重置的设备标识符。如果您的应用没有该权限，但您仍尝试查询标识符的相关信息，则平台的响应会因目标 SDK 版本而异： 如果应用以 Android Q 为目标平台，则会发生 SecurityException。如果应用以 Android 9（API 级别 28）或更低版本为目标平台，则相应方法会返回 null 或占位符数据（如果应用具有 READ_PHONE_STATE 权限）。否则，会发生 SecurityException。注意：如果您的应用是设备所有者或配置文件所有者应用，那么即使您的应用以 Android Q 为目标平台，您也只需 READ_PHONE_STATE 权限即可访问不可重置的设备标识符。此外，如果您的应用具有特殊运营商权限，则无需任何权限即可访问这些标识符。如果您的应用将不可重置的设备标识符用于广告跟踪或用户分析目的，请为这些特定用例创建 Android 广告 ID。要了解详情，请参阅唯一标识符的最佳做法。https://developer.android.google.cn/training/articles/user-data-ids 另一篇文章有讲解如何获取广告id :Google Advertising Id 获取 但是还需要注册谷歌开发者 申请谷歌广告的id The Google Mobile Ads SDK was initialized incorrectly. AdMob publishers should follow the instructions here: https://googlemobileadssdk.page.link/admob-android-update-manifest to add a valid App ID inside the AndroidManifest. Google Ad Manager publishers should follow instructions here: https://googlemobileadssdk.page.link/ad-manager-android-update-manifest. 最后放弃了~ 国内 设备获取设备标识符全国信息安全标准化技术委员会 有《信息安全技术 移动互联网应用（App）收集个人信息基本规范（草案）》， 规定了地图导航、网络约车、即时通讯、博客论坛、网络支付、新闻资讯、网上 购物等 21 种常用服务类型可收集的最少信息。 App 收集个人信息基本要求管理要求App收集个人信息应满足以下管理要求： a） App 运营者应履行个人信息保护义务，采取必要安全措施，保障用户个人信息安全。 b） 当用户同意 App 收集某服务类型的最少信息时，App 不得因用户拒绝提供最少信息 之外的个人信息而拒绝提供该类型服务。 注：附录 A 列举了 App 常见的服务类型以及服务类型对应的最少信息。 c） App 不得收集与所提供的服务无关的个人信息。 d） 对外共享、转让个人信息前，App 应事先征得用户明示同意。当用户不同意, 则不 得对外共享、转让用户个人信息。 e） App 不得收集不可变更的设备唯一标识（如 IMEI 号、MAC 地址等） ，用于保障网络 安全或运营安全的除外。 f） 用户明确拒绝使用某服务类型后，App 不得频繁（如每 48 小时超过一次）征求用 户同意使用该类型服务，并保证其他服务类型正常使用。 g） App 应对其使用的第三方代码、插件的个人信息收集行为负责。第三方代码、插件 收集个人信息视同 App 收集，App 应防止第三方代码、插件收集无关的个人信息。 注：如第三方代码、插件自行向用户明示其收集、使用个人信息的目的、方式、范围，并征得用户同意，则第三方代码、插件独立对其个人信息收集行为承担责任。 技术要求App收集个人信息应满足以下技术要求： a） 当收集的个人信息超出服务类型的最少信息时，超出部分的个人信息，App 应逐项 征得用户明示同意。 b） 当同一 App 有 2 种或 2 种以上服务类型时，App 应允许用户逐项开启和退出服务类 型，开启或退出的方式应易于操作。 c） 当用户退出某服务类型后，App 应终止该服务类型收集个人信息的活动，并对仅用 于该服务的个人信息进行删除或匿名化处理。 d） 当申请个人信息相关权限或要求用户输入个人信息时，App 应向用户同步明示申请 权限或收集信息的目的。 e） App 应向用户提供实时查询已收集个人信息类型的功能；查询结果应以独立界面展 示，且查询方式应易于操作。 f） 存在对外共享、转让个人信息的，App 应向用户提供查询数据接收方身份的功能； 查询结果应以独立界面展示，且查询方式应易于操作。 g） 在技术可行且不影响终端和服务正常的情况下，App 应优先在用户终端中存储、使 用所收集的个人信息。 h） App 应以实现服务所必需的最低合理频率向后台服务器发送个人信息。 所以这么严格，相关部门肯定会有一个规范来统一下发或者管理手机的唯一识别码，来达到“监管”用户的操作 规范来了~移动智能终端补充设备标识体系移动安全联盟移动安全联盟(Mobile Security Alliance，简称MSA)于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。由各大手机厂商”共同维护”来进行统一、规范化唯一识别码，目前包括的手机厂商有 厂商 版本 小米 MIUI10.2 及以上 vivo FuntouchOS 9 及以上 华为 全版本 OPPO Color OS 7.0 及以上（9 月份正式支持） Lenovo ZUI 11.4 及以上（9 月中旬正式支持） 体系说明移动智能终端补充设备标识体系架构共涉及四类实体，包括开发者、开发者开发的应用软件、移动智能终端设备的操作系统、用户及用户使用的设备。为保护用户用户的隐私和标识设备的唯一性，根据不同使用对象和不同用途，基于移动智能终端设备，分别生成设备唯一标识符、匿名设备标识符、开发者匿名设备标识符和应用匿名设备标识符，将这四个设备标识符构成补充设备标识体系。 体系图 唯一标识符作为普通用户仍然是拿不到，但是能够替代的，我们可以用其他的id, OAID 可与用户数据、账号绑定 用于个性化推荐、广告业务。 VAID 多应用之间能够共享的唯一标识，同一个开发者多个应用可以使用，举个例子：司机端和货主端 ，货主端发货刷单，司机端抢单时候可以用vaid判断，是否是同一台设备；缺点是必须是该手机平台的线上应用才能统计到是否是同一个开发者账号下的app,部分厂商，若应用未在其开发者平台后台上架，则认定未非法应用，无 法生成 VAID，手机 LOG 中将会有相关异常值输出。 AAID 单个app用于用户统计等，没有VAID的需求情况下 可以使用。 目前移动安全联盟 仍在免费注册阶段，还没有收费制服。作为旁观者，还是尽早注册，毕竟中国的手机市场很大，而且如上的通过谷歌广告的形式获取唯一识别码走不通，利润可想而知。 相关连接移动安全联盟 全国信息安全标准化技术委员会 谷歌官方文档 小米设备标识体系的说明 Google Advertising Id 获取","categories":[],"tags":[],"author":"zhangyognfa"},{"title":"Awesome-android-tips","slug":"Awesome-android-tips","date":"2019-08-23T07:20:53.000Z","updated":"2019-08-23T08:36:48.813Z","comments":true,"path":"2019/08/23/Awesome-android-tips/","link":"","permalink":"http://github.zhangyongfa888.site/2019/08/23/Awesome-android-tips/","excerpt":"","text":"EnglishVersion -&gt;_-&gt;:https://github.com/jiang111/awesome-android-tips/blob/master/README-en.md 值得收藏的AS插件 -&gt;_-&gt;:https://github.com/jiang111/awesome-androidstudio-plugins 这里收集了大家常用的一些Android代码,持续更新中,内容来自自己的平时积累和网络上看到的文章，部分原文地址在最下方。如有错误欢迎指正,如有侵权,请联系我删除。里面可能会有重复内容,请忽略或者提醒我删除。 Table of Contents setBackgroundResource(0) 可以移除 View 的背景色 Resources.getSystem().getDisplayMetrics().density 可以不用 Context 也能获取屏幕密度哦 通过重载 ViewGroup 的 dispatchDraw 可以实现一个简单的蒙版效果。 例如下拉刷新时，可以在 contentView 上加一层遮罩。 canvas.drawRect(0, mContentView.getTranslationY(), getWidth(), getHeight(), mMaskPaint); new 出来的 View 可以用 View.generateViewId() （API 17 以上可用） 生成 id，系统保证唯一 使用 GridView时 android:padding 和 android:clipToPadding=”false” 配合使用效果更好哦。 在布局文件中，如果只是为了占位，可以用 Space 来取代 View。 最棒的一点是Space可以跳过 Draw 这个过程。 TypedValue.applyDimension(int unit, float value, DisplayMetrics metrics) 方便dp, px, sp 之间的转换。 Activity.startActivities() 这个方法最直接的理解就是使用intent开启多个Activity TextUtils.isEmpty() 如果传入的String 为NULL或者Length为0的话就返回 true。 Html.fromHtml() 如果你对Html熟悉的话，可以很迅速通过这个方法处理一些富文本操作。比如超链接和图文排版等处理。 TextView.setError() 设置文本框错误提醒 Build.VERSION_CODES 有些时候我们的app需要根据不同的SDK版本进行执行不同的操作 PhoneNumberUtils.convertKeypadLettersToDigits 这个方法简单粗暴，会将输入的字母根据键盘上的映射转换为数字。 ArgbEvaluator ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。 ValueAnimator.reverse() 顺畅的取消动画效果 DateUtils.formatDateTime()) 这个方法可以输出相应格式化的时间或者日期 Pair 这个类 可以用来存储存储一”组”数据。但不是key和value的关系。 SparseArray 目前有很多地方从性能优化方说使用SparseArray来替换hashMap，来节省内存，提高性能。 Linkify.addLinks() 这个类可以更方便的为文本添加超链接。 android.media.ThumbnailUtils这个类主要是用来处理缩略图相关的工作,比如:用来获取媒体（图片、视频）的缩略图 12createVideoThumbnail(String filePath, int kind)extractThumbnail(Bitmap source, int width, int height) Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas和Paint可以动态的修改一个纯色Bitmap的颜色。 模块间有消息需要传递时，使用LocalBroadcastManager替代Listener进行模块解耦。除了解耦，这样发送消息和执行消息差一个线程循环，可以减小方法的调用链，我这就碰到一次方法调用链太长导致StackOverflow的问题。 静态变量不要直接或者间接引用Activity、Service等。这会使用Activity以及它所引用的所有对象无法释放，然后，用户操作时间一长，内存就会狂升。 Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，可能会造成内存泄露,所以可以在 onDestory() 的时候调用removeCallbacksAndMessages来移除这个Handler所对应等待执行的message。 不少人在子线程中更新View时喜欢使用Context.runOnUiThread，这个方法有个缺点，就是一但Context生命周期结束，比如Activity已经销毁时，一调用就会崩溃。 SharedPreferences.Editor.commit这个方法是同步的，一直到把数据同步到Flash上面之后才会返回，由IO操作的不可控，尽量使用apply方法代替。apply只在API Level&gt;=9才会支持，需要做兼容。不过，最新的 support v4 包已经为我们做好了处理，使用 SharedPreferencesCompat.EditorCompat.getInstance().apply(editor) 即可。 PackageManager.getInstalledPackages这个方法经常使用，你可能不知道，当获取的结果数量比较多的时候，在某些机型上面调用它花费的时间可能秒级的，所以尽量在子线程中使用。另外，如果结果太多，超过系统设置的Binder数据最大传输量的上限，则会发生TransactionException，如果你使用这个方法获取机器上的己安装应用列表，最好做一下预防。 如果使用Context.startActivity启动外部应用，最好做一下异常预防，因为寻找不到对应的应用时，会抛出异常。如果你要打开的是应用内的Activity，不防使用显式Intent，这样能提高系统搜索目标Activity的效率。 Application的生命周期就是进程的生命周期。只有进程被干掉时，Application才会销毁。哪怕是没有Activity、Service在运行，Application也会存在。所以，为了减少内存压力，尽量不要在Application里面引用大对象、Context等。 设置全屏方法有2种:1.通过代码设置，2通过manifest文件设置。用代码设置全屏时app在我们应用运行后，可能会看到短暂的状态栏，然后才全屏，而第二种方法是不会有这种情况的,所以推荐第二种。 12345678910//方法1: //无title requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setFlags(WindowManager.LayoutParams. FLAG_FULLSCREEN,WindowManager.LayoutParams. FLAG_FULLSCREEN); //必须在setContentView()之前调用setContentView(R.layout.main); //方法2:&lt;activity android:name=&quot;.&quot; android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; //全屏主题 android:label=&quot;@string/app_name&quot; /&gt; viewpager 的 setCurrentItem 一定要在 setAdapter 方法之后调用才会有效果. 判断手机是不是飞行模式 boolean isEnabled = Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) == 1; TabLayout 修改字体的方法官方的 TabLayout 没有提供修改 TextView size 的方法，可以新建一个 style CustomTabLayoutTextAppearance 继承 TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse ，然后增加 item ，设置 android:textAllCaps 为 true ，再设置 android:textSize 为你想设置的大小。 再在 TabLayout 的布局文件里设置 app:tabTextAppearance=”@style/CustomTabLayoutTextAppearance” 即可。 遍历HashMap的最佳方法 12345public static void printMap(Map mp) &#123; for (Map.Entry m : mp.entrySet()) &#123; System.out.println(m.getKey() + \":\" + m.getValue()); &#125;&#125; 使用Java在一个区间内产生随机整数数 12345public static int randInt(int min, int max) &#123; Random rand = new Random(); int randomNum = rand.nextInt((max - min) + 1) + min; return randomNum;&#125; 如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。 transient关键字修饰变量可以限制序列化。 当使用JakeWharton的TabPageIndicator时，如果需要先做一些耗时的操作，然后再展示TabPageIndicator的话，需要先设置mIndirector.setVisibility(View.GONE);然后耗时任务结束以后再mIndirector.setVisibility(View.VISIBLE);否则会报错 类继承之间的调用顺序 父类static成员 -&gt; 子类static成员 -&gt; 父类普通成员初始化和初始化块 -&gt; 父类构造方法 -&gt; 子类普通成员初始化和初始化块 -&gt; 子类构造方法 华为手机无法显示log解决方案,.拨号界面输入(*#*#2846579#*#*) Service menu will appear.Go to “ProjectMenu” -&gt; “Background Setting” -&gt; “Log Setting”Open “Log switch” and set it to ON.Open “Log level setting” and set the log level you wish. 后台service经常因为重启之类的出现onStartCommand()中的Intent传递的参数为null， 通过在onStartCommand()中的返回值改成return super.onStartCommand(intent, Service.START_REDELIVER_INTENT, startId); 可以解决问题。下面介绍几个flag的意思 flag 解释 START_STICKY 如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。 START_NOT_STICKY “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。 START_REDELIVER_INTENT 重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。 START_STICKY_COMPATIBILITY START_STICKY的兼容版本，但不保证服务被kill后一定能重启。 不能在Activity没有完全显示时显示PopupWindow和Dialog 在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定 有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等） *备注：大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释： 数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task，一般情况不推荐； 数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用； 数字3：在Receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）； ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。 谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感 不要在非UI线程中初始化ViewStub，否则会返回null 尽量不要通过Application缓存数据，这不稳定 华为手机无法打开USB调试的问题， 插好数据线,拨号界面 输入 ##2846579## 进入工程模式 projectmenu→3后台设置→4USB端口配置→Balong调试模式,点确定 不要拔线,退出工程模式,直接重启手机,电脑中显示可移动磁盘(若仍未出现,重复步骤1、2) 这个是关闭USB调试的情况下电脑中使用手机的可移动磁盘的方法，使用后下拉菜单中usb选项也回来了。 android listview中的消息被软键盘遮挡了,在设置listview的时候加上android:transcriptMode=”normal”就好了 TextUtils 是一个非常好用的工具类，把 List 转成字符串，逗号分隔，逗号分隔的 String 字符串，切割成 List ，分别可以用 TextUtils 的 join 和 split 方法。如果要对 List 去重，则可以用 Collection 的 frequency 方法。 在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。 activity中的runOnUiThrea(Runnable action)方法可以直接回到主线程 listview有个footerDividersEnabled和headerDividersEnabled方法可以设置listview的顶部和底部divide，但是必须保证你设置了headview和footview才会有效果 Throwable类中的getStackTrace()方法，根据这个方法可以得到函数的逐层调用地址，其返回值为StackTraceElement[]； StackTraceElement类，其中四个方法getClassName()，getFileName()，getLineNumber()，getMethodName()在调试程序打印Log时非常有用； UncaughtExceptionHandler接口，再好的代码异常难免，利用此接口可以对未捕获的异常善后 Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到； view的isShown方法，只有当view本身以及它的所有祖先们都是visible时，isShown（）才返回TRUE。而平常我们调用if(view.getVisibility() == View.VISIBLE)只是对view本身而不对祖先的可见性进行判断。 Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等；Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等； TextView类中的append(CharSequence)方法，添加文本。一些特殊文本直接用+连接会变成String； System类中的arraycopy(src, srcPos, dest, destPos, length)方法，用来copy数组； Fragment类中的onHiddenChanged(boolean)方法，使用FragmentTransaction中的hide()，show()时只会调用Fragment中的show和hidden状态,其他生命周期不会调用。 Activity类中的onWindowFocusChanged(boolean)，onNewIntent(intent)等回调方法； TextView类中的setTransformationMethod(TransformationMethod)方法，可用来实现“显示密码”功能 PageTransformer接口，用来自定义ViewPager页面切换动画，用setPageTransformer(boolean, PageTransformer)方法来进行设置； apache提供的一系列jar包：commons-lang.jar，commons-collections.jar，commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……； ActivityLifecycleCallbacks接口，用于在Application类中监听各Activity的状态变化 阅读地址点我 ActionBar.hide()/.show() 顾名思义，隐藏和显示ActionBar，可以优雅地在全屏和带Actionbar之间转换。 SystemClock.sleep() 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。 UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。 ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。 getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。 HandlerThread，代替不停new Thread开子线程的重复体力写法。 IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service Executors. newSingleThreadExecutor();这个是java的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列 android:animateLayoutChanges=”true”，LinearLayout中添加View的动画的办法，支持通过setLayoutTransition()自定义动画。 AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常.. ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。 android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants” includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。 Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。 EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿) java8中新增的LocalDate和LocalTime接口，Date虽然是个万能接口，但是它真的不好用，有了这俩，终于可以愉快的处理日期时间了。 WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。 使用SnackBar的时候，不要使用view.getRootView()作为snackbar的view,华为荣耀7 会出问题。 设置TextView单行显示的时候不要用Lines=1,而要用singleLine=”true” ,因为魅族部分手机在设置Lines=1的时候，然后TextView的值全为数字的时候， 你就会懵逼了. TouchDelegate可用于更改View的触摸区域。场景：比如在RecyclerView的ItemView里包含了CheckBox组件, 然后想实现点击ItemView的时候，也可以触发CheckBox，就可以使用此类 ArgbEvaluator可用于计算不同颜色值之间的插值，配合ValueAnimator.ofObject或者ViewPager.PageTransformer使用，可以实现不同颜色之间的平滑过渡。 Palette可用于提取一张图片的颜色。 ViewDragHelper,做过自定义ViewGroup的童鞋都应该知道这个东西吧，用来处理触摸事件的神器，妈妈再也不用担心我自定义控件了。 PageTransformer用于定义ViewPager页面切换时的动画效果（淡入淡出，放大缩小神马的…）官方有例子，直接看吧。 Formatter.formatFileSize() 这个方法会格式化数据的大小，根据输入的字节大小，返回 B KB MB GB 等等（最大支持到 PB）。当然要注意的是输入的最大值是 Long.MAX_VALUE. Activity.recreate重新创建Activity。有什么用呢？可以在程序更换主题后，立马刷新当前Activity，而不会有明显的重启Activity的动画。 View.getContext顾名思义，就不用解释了吧…以前在写RecyclerView的Adapter的时候，为了使用LayoutInflater，经常傻乎乎地在构造函数中传入一个外部的context….是不是只有我不知道而已（笑cry脸） View.post方便在非UI线程对界面进行修改，与Handler的作用类似。并且由于post的Runnable会保证在该View绘制完成的前提下才调用，所以一般也可以用于获取View的宽高。 Activity.runOnUiThread与View.post类似，方便在非UI线程中对界面进行修改。 Fragment在配合PagerAdapter使用的时候可以重写setUserVisibleHintFragment()方法，然后根据参数的布尔值（true的话表示当前Fragment对用户可见),来执行一些逻辑。 android:animateLayoutChanges 这是一个非常酷炫的属性。在父布局加上 android:animateLayoutChanges=”true” 后，如果触发了layout方法（比如它的子View设置为GONE），系统就会自动帮你加上布局改变时的动画特效！！ android:clipToPadding 设置父view是否允许其子view在它的padding（这里指的是父View的padding）中绘制。是不是有点绕？举个实际场景吧：假如有个ListView，我们想要在初始位置时，第一项Item离顶部有10dp的距离，就可以在ListView的布局中加入android:clipToPadding=”false” android:paddingTop=”10dp”即可。是不是很方便呢？ rv 的 Layoutmanager 可以直接申明在 xml 中,具体代码可查看RecyclerView.createLayoutManager 方法. RecyclerView在23.2.+的版本中新增了自动测量的功能，由于新增了自动测量，那么它的item的根布局在需要测量的方向上就不能写match_parent了，需要改成wrap_content getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。 Canvas中clipRect、clipPath和clipRegion剪切区域的API。 GradientDrawable 有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！ 有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过&lt;application android:hardwareAccelerated=”false” …&gt;，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。 PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。 StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable来完成了，各种addState即可。 android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。 ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。 ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。 onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。 TextView.setCompoundDrawablePadding，代码设置TextView的drawable padding。 ImageSwitcher，可以用来做图片切换的一个类，类似于幻灯片。 在自定义控件的时候,能用drawable来绘制圆，或者其他样式的时候,尽量用drawable,因为drawable的效果要远胜于canvas.drawXXX(). 如果想要自定义View支持SwipeRefreshLayout，只需要声明并实现ScrollingView接口即可，RecyclerView和NestedScrollView已经实现此接口。 AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。 DatabaseUtils——一个包含各种数据库操作的使用工具。 Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。 SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。 android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。 android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。 android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。 Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck! 使用RenderScript虚化图片效果。如果你的app的minSDK为16或者更低，你需要使用support模式，因为很多方法都是在API 17之后添加的。renderscriptTargetApi最高到23，但是你应该把它设置到能保持脚本中使用到的功能完整的最低API。如果你想在support模式下target API 21+你必须使用gradle-plugin 2.1.0 和 buildToolsVersion “23.0.3” 或者以上。需要在gradle中添加renderscriptTargetApi 18,renderscriptSupportModeEnabled true 这两句话 123456789101112131415161718public static Bitmap blurBitmap(Context context, Bitmap src, int radius) &#123; Bitmap dest = src.copy(src.getConfig(), true); RenderScript rs = RenderScript.create(context); Allocation allocation = Allocation.createFromBitmap(rs, src); Type t = allocation.getType(); Allocation blurredAllocation = Allocation.createTyped(rs, t); ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); blurScript.setRadius(radius); blurScript.setInput(allocation); blurScript.forEach(blurredAllocation); blurredAllocation.copyTo(dest); allocation.destroy(); blurredAllocation.destroy(); blurScript.destroy(); t.destroy(); rs.destroy(); return dest; &#125; 如果想把一个view保存为Bitmap，正常情况下用第一种方法就可以了，但是如果是ScrollView，则必须采用第二种方法。 当Activity LauncherMode 为singleTask singleInstance时,使用startActivityForResult会立马返回，不能正常调用。具体请看http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml 当PopupWindow中有EditText控件时,因为Popupwindow 默认没有获取到焦点，需要手动设置焦点，这样子view才能获取到事件的监听。所以你需要在创建完popwindow后设置他的焦点，popupWindow.setFocusable(true);就可以让EditText获取焦点。 PopupWindow默认点击外部的时候不消失，需要对PopupWindow 设置一个背景图popWindow.setBackgroundDrawable(new BitmapDrawable());要创建一个空对象，设置为null是不行的，或者就创建一个全透明的背景图。 android中的序列化官方推荐Parceble,其实Parceble最好用于内存之间数据的交换,如果要把数据写入硬盘的话,推荐实现Serializable tools标签可以很好的帮助开发者实时预览xml的效果,通过tools:background可以预览控件所占的控件,tools:visibility可以把一个gone的控件在预览的时候展示出来,并且运行以后tools标签的内容不会展示出来.例如: 123456&lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:background=\"#FF00FF\" tools:visibility=\"visible\" tools:text=\"这段话只在预览时能看到,运行以后就看不到了\" /&gt; android studio 2.1起已经支持jdk8了,使用的时候要在gradle中加上,需要把buildToolsVersion更新到24以上的版本 12345678910111213android &#123; defaultConfig &#123; ... jackOptions &#123; enabled true &#125; &#125; ... compileOptions &#123; targetCompatibility 1.8 sourceCompatibility 1.8 &#125;&#125; 6.0之后getResources().getColor()方法被废弃了，大家可以用ContextCompat.getColor(context, R.color.color_name)替换，ContextCompat 是 v4 包里的，请放心使用，另外还有getDrawable()等方法 图片的资源文件官方推荐只把launcher放在mipmap文件夹下面，而app用到的资源文件建议放在drawable下面。 SharedPreference.Editor的apply是异步操作，不会返回成功的状态，而commit是同步操作，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后再操作下一个数据，从而降低了效率。 如果你在 manifest 中把一个 activity 设置成 android:windowSoftInputMode=”adjustResize”，那么 ScrollView（或者其它可伸缩的 ViewGroups）会缩小，从而为软键盘腾出空间。但是，如果你在 activity 的主题中设置了 android:windowFullscreen=”true”，那么 ScrollView 不会缩小。这是因为该属性强制 ScrollView 全屏显示。然而在主题中设置 android:fitsSystemWindows=”false” 也会导致 adjustResize 不起作用 在Android 4.0以后，在Manifest.xml中静态注册的广播，程序安装后必须启动一次才能接收到广播，比如你的应用监听开机启动的广播，必须要你的程序被运行过才能监听到 Activity的onDestory方法调用时机是不确定的（有时候离开界面很久之后才会调用onDestory方法），应该避免指望通过onDestory方法去释放与Activity相关的资源，否则会导致一些随机bug 2.X时代Bitmap对象虽然存储在堆内存中，但是用了一个byte数组存储其像素信息。通过计数器来记录该像素信息被引用的个数。有人认为这个byte数组在native堆中，但事实上它也在堆中。只有在使用者调用recycle()后，Bitmap对象才会释放像素信息，才会在失去引用后被垃圾回收机制销毁。再加上DVM的heap size有严格的阀值，所以在使用大量图片资源的时候，及其容易发生OOM。解决办法一般都是，用一个哈希表存储Bitmap对象的软引用，作为内存缓存，并在适当时机掉用其recycle()。3.0以上版本Bitmap对象可以通过垃圾回收机制完全销毁，理论上不用再调用recycle()。 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos; 时间戳请使用long或者String类型接收，遇到的坑,由于项目中的model好多都是通过GsonFormat生成的，服务器给的json中的时间戳都是10位的，导致了GsonFormat自动解析成了int, 当测试人员选择时间为2100年的时候时间戳是4开头的十位 用int类型接收越界了,导致报错 为你的app添加默认布局样式,比如:每一个控件都需要写width和height属性,然而很多的控件的宽高属性都是wrap_content,那么我们可以通过在style文件添加如下样式: 1234&lt;style name=&quot;Theme.YourApp&quot; parent=&quot;android:style/Theme.Light&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;&lt;/style&gt; 这样,控件的宽高默认都是wrap_content样式啦。 在style中写的样式通过视同parent标签来扩展你的样式,这样更高效,这里官方的建议是，只有Android自带的style才用parent标签，如果是自定义的style，直接用.符号来连接就行。如Fill.Height。 1234567&lt;style name=&quot;Fill&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;fill_parent&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;fill_parent&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;Fill.Height&quot; &gt; &lt;item name=&quot;android:orientation&quot;&gt;vertical&lt;/item&gt;&lt;/style&gt; Android上的应用切换按钮列出的其实不是应用而是Task，所以你会看到有的应用在切换视图里有多个任务。如果你的应用中有逻辑上相互独立的部分，或者想在多窗口环境下并排显示应用的两个不同部分，这种情况就适合多任务了。使用manifest属性(静态)或者 intent flags(动态)可以实现这一点,详见视频: http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294 当app的theme用的是NoActionBar,但是在layout中仍然用到toolbar的时候,不要在style文件中加fitsSystemWindows属性,而是在用到toolbar的layout最外层加fitsSystemWindows,否则当你使用EditText,在小米手机上长按EditText调出系统粘贴功能的时候,粘贴的layout的布局会错位. 当WebView与ScrollView嵌套使用,并且WebView有字体放大缩小的功能时,当切换webview的字体后,webview的高度并不能很好的计算出来,这时候可以通过注入的方式,让js算出高度,经测试,这样是最可靠的,代码地址:http://blog.csdn.net/jys1115/article/details/43525979 Context类中的createPackageContext(packageName, flags)方法，可用来获取指定包名应用程序的Context对象。 TextView类的setKeyListener(KeyListener)方法；其中DigitsKeyListener类，使用getInstance(String accepted)方法即可指定EditText可输入字符集； View类中的getLocationInWindow(int[])方法和getLocationOnScreen(int[])方法，获取View在窗口/屏幕中的位置； Context.getCacheDir() - 可以获取到app默认的缓存路径。 StaticLayout 在自定义控件绘制文本的时候很有用。 Android中的四大组件千万不要通过new的方式创建出来。 测试app的时候,我们大都想要将debug和release版本同时安装到手机里,可以通过在gradle中修改applicationid来实现: 1234567891011android &#123; buildTypes &#123; debug &#123; applicationIdSuffix &apos;.debug&apos; versionNameSuffix &apos;-DEBUG&apos; &#125; release &#123; //... &#125; &#125;&#125; 在大多数的登陆界面中，都提供了用户是否让密码可见的选项，Support Library 24.2.0 提供了官方的实现，TextInputLayout 中添加了 passwordToggleEnabled 属性来开启此功能，并且可以通过 passwordToggleDrawable 设置图标。(摘自:Android笔记的微博) 同样,在Support Library 24.2.0中增加RecyclerView 在快速滚动时的回调接口,SnapHelper是官方的一个实现OnFlingListener 的 一个抽象类,LinearSnapHelper 则是一个完整的实现.LinearSnapHelper默认实现的功能是类似ViewPager,在滚动结束后,会选择列表某一条居中展示(这里有开始位置展示,或者结束位置显示点我).例如: 1234LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.HORIZONTAL, false);recyclerView.setLayoutManager(linearLayoutManager);LinearSnapHelper snapHelper = new LinearSnapHelper();snapHelper.attachToRecyclerView(recyclerView); Android中推荐使用的数据结构 : 1234567ArrayMap&lt;K,V&gt; in place of HashMap&lt;K,V&gt; ArraySet&lt;K,V&gt; in place of HashSet&lt;K,V&gt; SparseArray&lt;V&gt; in place of HashMap&lt;Integer,V&gt; SparseBooleanArray in place of HashMap&lt;Integer,Boolean&gt; SparseIntArray in place of HashMap&lt;Integer,Integer&gt; SparseLongArray in place of HashMap&lt;Integer,Long&gt; LongSparseArray&lt;V&gt; in place of HashMap&lt;Long,V&gt; 生成GUID(由于java中只能生成UUID,所以这里要转换一下): 1return UUID.randomUUID().toString().toUpperCase().replaceAll(&quot;-&quot;, &quot;&quot;); 业务场景：需要定时后台扫描数据库，上传本地照片至云端，定时任务采用何种模式: 1.Handler或者Timer定时一般为秒级别的任务,Timer会启动额外线程，而Handler可以不用。2.无论是Handler还是Timer都需要依赖于进程存活3.利用Handler实现定时任务的类:HandlerTimer4.如果时间较长，则需要使用AlarmManager5.另外，我们对于这种业务应该优先考虑是否可以基于事件通知。6.如果是加入媒体库的文件，我们可以使用registerContentObserver监听媒体库文件变化。 把Activity作为参数传给一个静态方法,会影响这个Activity的正常销毁吗? 1.内存泄露与方法是否是静态与否无关，与内部的方法体实现有关系。2.内存泄露可以简单理解成：生命周期长的对象不正确持有了持有了生命周期短的对象，导致生命周期短的对象无法回收。3.比如Activity实例被Application对象持有，Activity实例被静态变量持有。 在assets文件夹下存放单个文件的大小不能超过1M，如果读取超过1M的文件会报 “Data exceeds UNCOMPRESS_DATA_MAX (1314625 vs 1048576)” 的IOException。如果一定要存储，可以分割文件，再去合并文件 在Android library中不能使用switch-case语句访问资源ID，因为case分支后面跟的参数必须是常数，而library中的每一个资源ID都没有被声明为final。 当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率； 不要通过Bundle传递大块的数据，否则会报TransactionTooLargeException异常 （AnimationDrawable在Android5.0及以上的版本已有明显的优化）尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错； .9图不能通过tinypng压缩，不然会有问题； genymotion模拟器快是因为它是基于x86架构的，如果你的应用中用到了so，但没有x86架构的so，只能放弃使用它；Android Studio的模拟器也一样； 使用Toast时，建议定义一个全局的Toast对象，这样可以避免连续显示Toast时不能取消上一次Toast消息的情况（如果你有连续弹出Toast的情况，避免使用Toast.makeText）； 尽量避免给window和Activity同时都设置了背景，这样会造成过渡绘制，可以通过在给Activity设置主题时，去掉windowBackground背景的方式减少一层过渡绘制，有时候为了避免进入Activity时会黑屏或者白屏（和主题有关），会在给Activity设置主题的时候给window设置背景，如果这种情况下给Activity也设置了背景，是会增加一倍内存的： 1&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt; 设置中更改字体为特大之类的会影响到app的字体样式，解决方法有: 1.将所有字体使用的单位换成dp，不再使用sp.这样不是很靠谱，并不是所有人都能做到。 2. 12345678Configuration configuration = getResources().getConfiguration(); configuration.fontScale = (float) 1; //0.85 小, 1 标准大小, 1.15 大，1.3 超大 ，1.45 特大 DisplayMetrics metrics = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(metrics); metrics.scaledDensity = configuration.fontScale * metrics.density; getBaseContext().getResources().updateConfiguration(configuration, metrics); //（ps:dialog popupwindow 除外,这两种需要在控件中重新设置fontScale) Android中新引入的替代枚举的注解有IntDef和StringDef,这里以IntDef做例子说明一下. 1234567891011121314151617public class Colors &#123; @IntDef(&#123;RED, GREEN, YELLOW&#125;) //声明必要的int常量,使用@IntDef修饰LightColors,参数设置为待枚举的集合 @Retention(RetentionPolicy.SOURCE) //使用@Retention(RetentionPolicy.SOURCE)指定注解仅存在与源码中,不加入到class文件中 public @interface LightColors&#123;&#125; //声明一个注解为LightColors public static final int RED = 0; public static final int GREEN = 1; public static final int YELLOW = 2;&#125;//用法private void setColor(@Colors.LightColors int color) &#123; Log.d(&quot;MainActivity&quot;, &quot;setColor color=&quot; + color);&#125;//调用的该方法的时候setColor(Colors.GREEN); PathInterpolatorCompat 很方便的使用它来创建各种插值曲线，举个非常简单的例子： 123456Path path = new Path();path.cubicTo(0.2f, 0f, 0.1f, 1f, 0.5f, 1f);path.lineTo(1f, 1f);ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 500);animator.setInterpolator(PathInterpolatorCompat.create(path));animator.start(); 检测当前网络能否访问远程服务器(国内通过ping百度来检测) 1234567891011public static boolean isNetWorkAvailable(final Context context) &#123; try &#123; Runtime runtime = Runtime.getRuntime(); Process pingProcess = runtime.exec(&quot;/system/bin/ping -c 1 www.baidu.com&quot;); int exitCode = pingProcess.waitFor(); //0 代表连通，2代表不通 return (exitCode == 0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 拦截系统返回键(onBackPressed())，使App不退出，而是进入后台运行 1234@Override public void onBackPressed() &#123; moveTaskToBack(false); &#125; view.performClick() 自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件，该方法可以由某些特殊条件触发模拟用户点击行为。类似的还有 performLongClick() 方法。 Linkify.addLinks() 通过 android:autoLink 属性可以为其添加诸如 web、phone 等固定模版的超链接点击事件。但毕竟系统模版有限，而利用 Linkify.addLinks() 方法可以添加一些应用内自定义模版，比如新浪微博中的 “@XXX” 格式的超链接跳转等，都可以通过自定义正则表达式来匹配处理。 getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE) 设置安全窗口，禁用系统截屏。防止 App 中的一些界面被截屏，并显示在其他设备中造成信息泄漏。（常见手机设备系统截屏操作方式为：同时按下电源键和音量键。） activity生命周期(Ref Link) RecyclerView 调用notifyItem()的时候会有默认的动画,可以通过调用((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);来去掉默认动画.以防止出现闪屏的问题 Toolbar 使用的主题如果 parent=”ThemeOverlay.AppCompat.Light”，只要改一下 @color/white 就可以使 OverflowButton 变为白色，同时点击它展开的菜单背景也可以是白的 Android View的生命周期示例图样。来自G+ +Arpit Mathur 当需要从资源文件中获取 html 并展示时，使用 Resource#getText() 而不是 Resource#getString()。当需要动态显示 HTML 时，使用 Html.fromHtml() 请看这里 JAVA中时间String转Timestamp 12345678910try &#123; DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); format.setLenient(false); //要转换字符串 str_test 自定义的格式为 yyyy-mm-dd，可以改成你需要的格式 String str_test =&quot;2011-04-24&quot;; Timestamp ts = new Timestamp(format.parse(str_test).getTime()); System.out.println(ts.toString());&#125; catch (ParseException e) &#123;e.printStackTrace();&#125; 当Activity 继承 FragmentActivity的时候，调用startActivityForResult方法中传递的requestCode范围应该在0-65535范围内，否则会报”Can only use lower 16 bits for requestCode”异常。 Android有一个隐藏的类可以判断文本输入框内输入的是不是表情，这个类就是 android.text.Emoji类，它的isEmoji(int codePoint)方法可以直接判断出来是不是表情。这个类是隐藏的，如果要用到则需要将它拷贝出来。 布局中不得不使用ViewGroup 多重嵌套时，不要使用LinearLayout 嵌套，改用RelativeLayout，可以有效降低嵌套数。 不能使用ScrollView 包裹ListView/GridView/ExpandableListVIew;因为这样会把ListView 的所有Item 都加载到内存中，要消耗巨大的内存和cpu 去绘制图面。 不要通过Intent 在Android 基础组件之间传递大数据（binder transaction缓存为1MB），可能导致OOM。 在Application 的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。 将android:allowbackup 属性设置为false，防止adb backup 导出数据。 除非min API level &gt;=17，请注意addJavascriptInterface 的使用 12345说明：API level&gt;=17，允许js 被调用的函数必须以@JavascriptInterface 进行注解，因此不受影响； 对于API level &lt; 17，尽量不要使用addJavascriptInterface，如果一定要用，那么：1) 使用https 协议加载URL，使用证书校验，防止访问的页面被篡改挂马；2) 对加载URL 做白名单过滤、完整性校验等防止访问的页面被篡改；3) 如果加载本地html,应该会HTML 内置在APK 中，以及对HTML 页面进行完整性校验。 如何动态修改AlertDialog的Button样式, 1234567891011//监听Dialog的setOnShowListener方法dialog.setOnShowListener(new DialogInterface.OnShowListener() &#123; @Override public void onShow(final DialogInterface dialog) &#123; Button negativeButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_NEGATIVE); Button positiveButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_POSITIVE); negativeButton.invalidate(); positiveButton.invalidate(); &#125;&#125;);dialog.show(); 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源； 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提升效率。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;; WebView 在 API 21之后,写Cookie的时候默认禁止了跨域写cookie,需要通过代码,来设置开启跨域请求 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; CookieManager.getInstance().setAcceptThirdPartyCookies(WebView, true); &#125; 使用IdleHandler,替代Handler.postDelay(),IdleHandler是在我们的onResume和measure, layout, draw这么message执行结束之后， 提供了他们执行完毕的回调. 看这里 1234567Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; //TODO... return false; &#125; &#125;); 在Multidex分包的时候,如果主dex过大, 5.0以下的机型可能会出现multidex installation failure错误,这时需要让主dex方法数小一点.,配置方法 123456789101112配置正常的multiDex库之后,在主模块的gradle文件添加如下代码:Android&#123; ...//其他代码 dexOptions &#123; javaMaxHeapSize &quot;4g&quot; preDexLibraries = false additionalParameters += &apos;--multi-dex&apos; additionalParameters += &apos;--set-max-idx-number=35000&apos;//(35000可根据自己的需求更改)来适配4.0-4.4一些低端机型，因为拆分的dex太大，这些低端机型加载不了dex additionalParameters += &apos;--minimal-main-dex&apos; &#125;&#125; 注意:在gradle版本3.1.0之后dex编译采用D8,可能会导致这种分包不成功。将gradle的版本降到3.0.0之后，分包成功。另外也可以采用gradle3.1.0或者以上的版本，然后将项目的gradle配置为android.enableD8=false //暂时关闭 即可 高版本android中，可以使用Application启动Activity并且不设置FLAG，但在低版本中必须要设置FLAG,所以建议大家使用application的context去startActivity的时候添加FLAG_ACTIVITY_NEW_TASK 不要滥用 1&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; 属性,切勿为app设置该属性,而仅针对具体的activity进行设置.公司有位开发为整个app设置了该属性,我们有个签名的横屏页面,其他是强制竖屏页面,有个需求是进入该竖屏页面后某些特殊原因需要自动跳转到签名页面,而跳转到横屏页面后导致整个app的所有页面生命周期全部重新走了一遍,该签名页面无限循环打开. 当你在多module中使用了多个三方库,而这些三方库使用了多个版本的Recyclerview,我们可以通过exclude group: ‘com.android.support’, module: ‘recyclerview-v7’ 来实现使用项目中的版本,但是这样造成的问题是每添加一个库就得写一下exclude,这样很不友好,而gradle为我们提供了依赖替换规则.如下代码实现了全局替换recyclerview的版本12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == &apos;com.android.support&apos;) &#123; if (requested.name.startsWith(&quot;recyclerview-v7&quot;)) &#123; details.useVersion &quot;28.0.0&quot; &#125; &#125; &#125;&#125; 当然,依赖替换规则还允许我们在本地库和远程库之间进行切换. 1234567configurations.all &#123; resolutionStrategy.dependencySubstitution &#123; if (useLocal) &#123; //如果使用本地仓库,系统将会把org.utils:api依赖替换为本地api的project substitute module(&quot;org.utils:api&quot;) because &quot;we work with the unreleased development version&quot; with project(&quot;:api&quot;) &#125; &#125;&#125; 摘自如下地址","categories":[],"tags":[],"author":"zhangyognfa"},{"title":"滴滴插件化实践","slug":"滴滴插件化实践","date":"2019-07-30T11:05:00.000Z","updated":"2019-08-01T02:11:31.871Z","comments":true,"path":"2019/07/30/滴滴插件化实践/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/30/滴滴插件化实践/","excerpt":"","text":"工程目录 paste image 宿主配置apply plugin: &apos;com.android.application&apos; apply plugin: &apos;com.didi.virtualapk.host&apos; //*** dependencies{ implementation &apos;***.huozhu:core:&apos; + rootProject.ext.versions.core implementation &apos;com.didi.virtualapk:core:0.9.8&apos; }公共库配置因为涉及到插件的下载加载以及之间的跳转 所以封装一个下载加载的公共类 dependencies{ implementation &apos;com.didi.virtualapk:core:0.9.8&apos; }插件配置apply plugin: &apos;com.didi.virtualapk.plugin&apos; virtualApk { packageId = 0x75 targetHost = &apos;../app&apos; applyHostMapping = true forceUseHostDependences = true }插件中的gradle.properties android.useDexArchive=false项目配置build.gradle中 buildscript { repositories { google() jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:3.1.0&apos; classpath &apos;com.didi.virtualapk:gradle:0.9.8.6&apos; } }插件加载并跳转 loadPlugin(&quot;plugin_mywallet&quot;, new LoadPlugin() { @Override public void plugin(LoadedPlugin plugin) { startActivity(plugin.getLaunchIntent()); } });插件之间的跳转和传参loadPlugin(&quot;plugin_orderlist&quot;, new LoadPlugin() { @Override public void plugin(LoadedPlugin loadedPlugin) { try { Intent intent = new Intent(context,Class.forName(&quot;***.plugin_orderlist.PluginOrderDetailsActivity&quot;)); intent.putExtra(&quot;extra_orderid&quot;, orderCode); startActivity(intent); } catch (Exception e) { e.printStackTrace(); } } });其他配置基地址 基地址封装在公共库 并能够在宿主中修改,插件中之间调用基地址即可区分正式和开发环境 public static String BaseUrl = &quot;https://tess.cisdom.com.cn/public/index.php/apient/&quot;; public static String BaseDownload = &quot;http://192.168.50.7/wx/&quot;; public static void setBaseUrl(String baseUrl) { BaseUrl = baseUrl; } public static void setBaseDownload(String baseDownload) { BaseDownload = baseDownload; }公共库打包aar见 https://blog.csdn.net/u013325929/article/details/50563571 遇到的问题插件包需要签名插件包生成插件找不到入口函数 -&gt;在清单文件加入application","categories":[],"tags":[],"author":"zhangyognfa"},{"title":"滴滴插件化","slug":"滴滴插件化","date":"2019-07-12T00:56:54.000Z","updated":"2019-07-12T01:09:25.636Z","comments":true,"path":"2019/07/12/滴滴插件化/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/12/滴滴插件化/","excerpt":"","text":"插件开发规范 V1.0.1由于VirtualAPK本身的特性，插件需要遵循以下规范： 1.宿主配置Project build.gradle classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos; `&lt;/pre&gt; Module build.gradle &lt;pre&gt;`apply plugin: &apos;com.didi.virtualapk.host&apos; compile &apos;com.didi.virtualapk:core:0.9.0&apos; `&lt;/pre&gt;2.插件配置插件 Project build.gradle 文件中，需要加入如下引用： classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos;注：版本号应与宿主版本号相同 插件 Module build.gradle 文件中，需要加入如下引用： apply plugin: &apos;com.didi.virtualapk.plugin&apos; virtualApk { packageId = 0x6f // 插件资源id，避免资源id冲突 targetHost=&apos;../host/app&apos;// 宿主工程的路径 applyHostMapping = true // 插件编译时是否启用应用宿主的apply mapping 默认为true }3.构建环境 官方构建环境建议： 框架强依赖构建环境。如果更换构建环境，可能会出现问题 Gradle 2.14.1 com.android.tools.build 2.1.3 即：插件 Project build.gradle 文件中 classpath &apos;com.android.tools.build:gradle:2.1.3&apos; 插件gradle-wrapper.properties文件中： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip4.打包 插件打包时，应当用命令 ./gradlew clen assemblePlugin 或者 gradle clean assemblePlugin 进行打包 输出位置为：app\\build\\outputs\\plugin\\release 由于插件 Module build.gradle 文件中设置了如下参数， targetHost=’../host/app’// 宿主工程的路径 故，打包时的文件结构应为： 即：HOST 应与插件在同一目录下编译 插件调用宿主 将宿主中需要被插件调用的 模块、类，下沉到公共组件库。 即：以aar包的形式。分别被插件，组件依赖即可。 aar 引入模板： compile(group:&apos;test&apos;, name: &apos;app-release&apos;, version:&apos;0.2&apos;, ext: &apos;aar&apos;)插件中包含 so 包需特别注意如果插件中包含如百度地图等 so 包，由于部分第三方库存在的包名校验机制，需要注册一份新的 secretKey 写到宿主中,这个不难理解，因为运行时包名是宿主的包名，不能通过校验。 资源链接我的踩坑记录 https://blog.csdn.net/a31081314/article/details/82661009 我的demo 地址 https://github.com/CD3108/VirtualAPK 源码地址 https://github.com/didi/VirtualAPK 详细框架接入 https://www.jianshu.com/p/013510c19391 四大组件加载过程 https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;mpshare=1&amp;scene=1&amp;srcid=0712oTUswGWi172UK0Azpg4i&amp;key=8652b956ca1971a47b1e263b435230c7469d30646ddbe6ce2fb781033d6eba5215c9fd7e5eaf0bd73dd5da279b32dd901261d5e55bf32997bc333ad8a059e095e2193a5baa805447fc49cd315fca4404&amp;ascene=0&amp;uin=MTI0NjM4NTEyMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=12010110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=mswE9bS3QeCxTOoepaUWh9VXHxeYMosdkHkAydyR09JHQkVe%2BAJHCCnPQrRpBfQN 资源加载过程 https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537 来自VirtualAPK开发群 点击链接加入群聊【VirtualAPK】：","categories":[],"tags":[],"author":"zhangyognfa"},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2019-07-10T06:33:00.000Z","updated":"2019-07-12T00:55:09.087Z","comments":true,"path":"2019/07/10/Markdown基本语法/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/10/Markdown基本语法/","excerpt":"","text":"Markdown基本语法简介Markdown 是一种_轻量级标记语言_，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为.md , .markdown。 Markdown 标题使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题显示效果一级标题二级标题三级标题四级标题五级标题六级标题使用-/=标记我展示的是一级标题 ================= 我展示的是二级标题 -----------------显示效果我展示的是一级标题我展示的是二级标题Markdown 区块&gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套显示效果 最外层 第一层嵌套 第二层嵌套 Markdown 代码 printf() 函数 代码区块使用 4 个空格或者一个制表符（Tab 键）。printf() //tab键 Markdown 链接[链接名称](&quot;http://www.baidu.com&quot;) 或者 &lt;http://www.baidu.com&gt; 链接名称 或者 http://www.baidu.com Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) {% image 图片地址 'alt 属性文本' '可选标题' %} example: ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) [RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;) RUNOOB Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 显示如下： 表头 表头 单元格 单元格 单元格 单元格 对齐方式 -: 设置内容和标题栏居右对齐 :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐| 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 参考 菜鸟教程 整理","categories":[{"name":"语言","slug":"语言","permalink":"http://github.zhangyongfa888.site/categories/语言/"}],"tags":[{"name":"IT","slug":"IT","permalink":"http://github.zhangyongfa888.site/tags/IT/"}],"author":"zhangyognfa"},{"title":"Android Q 功能和 API","slug":"Android-Q-功能和-API","date":"2019-07-10T05:41:00.000Z","updated":"2019-07-10T05:47:15.705Z","comments":true,"path":"2019/07/10/Android-Q-功能和-API/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/10/Android-Q-功能和-API/","excerpt":"","text":"Android Q 功能和 APIAndroid Q 为用户和开发者引入了强大的新功能。本文重点介绍面向开发者的新功能。 要了解新版 API，请阅读 API 差异报告或访问 Android API 参考文档。为醒目起见，将突出显示新版 API。此外，请务必查阅 Android Q 行为变更（针对以 Android Q 为目标平台的应用和所有应用）以及隐私权变更，以了解平台变更可能给您的应用带来哪些方面的影响。 安全增强功能Android Q 引入了若干安全功能，详见以下各节摘要说明： 改进了生物识别身份验证对话框Android Q 对 Android 9 中增加的统一生物识别身份验证对话框进行了以下改进： 指定用户确认要求您现在可以提供一个提示，以告知系统在用户使用隐式生物识别模式完成身份验证后无需要求用户进行确认。例如，您可以告知系统，在用户使用面孔身份验证完成身份验证后无需进一步确认。 默认情况下，系统会要求用户进行确认。通常，用户希望确认敏感或高风险的操作（例如，购买商品）。但是，如果您的应用存在某些低风险操作，您可以将 false 传递到 setConfirmationRequired() 方法，以此来提供不要求用户确认的提示。由于此标记作为提示传递到系统，因此如果用户更改了针对生物识别身份验证的系统设置，则系统可能会忽略相应的值。 无需用户确认的面孔身份验证示例。 paste image 图 1. 无需用户确认的面孔身份验证 要求用户确认的面孔身份验证示例。 paste image 图 2. 需要用户确认的面孔身份验证 改进了对设备凭据的回退支持您现在可以告知系统，如果用户因某种原因而无法使用其生物识别输入设备进行身份验证，则可以使用设备 PIN 码、图案或密码来进行身份验证。要启用此回退支持，请使用 setDeviceCredentialAllowed() 方法。 如果您的应用目前使用 createConfirmDeviceCredentialIntent() 回退到设备凭据，请改为使用新方法。 检查设备的生物识别功能现在，您可以先通过使用 BiometricManager 类中的 canAuthenticate() 方法，检查设备是否支持生物识别身份验证，然后再调用 BiometricPrompt。 直接从 APK 运行嵌入式 DEX 代码您现在可以告知平台直接从应用的 APK 文件中运行嵌入式 DEX 代码。如果攻击者曾设法篡改了设备上本地编译的代码，则此选项有助于防止此类攻击。 注意：启用此功能可能会影响应用的性能，因为在应用启动时 ART 必须使用 JIT 编译器（而不是读取提前编译好的原生代码）。我们建议您先测试应用性能，然后再决定是否在已发布的应用中启用此功能。要启用此功能，请在应用清单文件的 元素中将 android:useEmbeddedDex 属性的值设为 true。您还必须编译一个 APK，其中要包含 ART 可以直接访问的未压缩 DEX 代码。将以下选项添加到 Gradle 或 Bazel 配置文件，以编译包含未压缩 DEX 代码的 APK： Gradle aaptOptions { noCompress ‘dex’ } Bazel android_binary( ..., nocompress_extensions = [“.dex”], )TLS 1.3 支持现在，平台的 TLS 实现支持 TLS 1.3。TLS 1.3 是 TLS 标准的主要修订版本，它提升了性能和安全性。我们的基准测试数据表明，与 TLS 1.2 相比，使用 TLS 1.3 可以将建立安全连接的速度提高 40%。 默认情况下，系统会为所有 TLS 连接启用 TLS 1.3。您可以通过调用 SSLContext.getInstance(“TLSv1.2”) 来获取已停用 TLS 1.3 的 SSLContext。您还可以对相关对象调用 setEnabledProtocols()，从而为每个连接启用或停用协议版本。 以下是有关 TLS 1.3 实现的一些重要的详细信息： TLS 1.3 加密套件不可自定义。在启用 TLS 1.3 后，受支持的 TLS 1.3 加密套件会始终保持启用状态，并且系统会忽略所有试图通过调用 setEnabledCipherSuites() 将其停用的行为。在协商 TLS 1.3 时，系统会在将会话添加到会话缓存之前调用 HandshakeCompletedListeners（这与 TLS 1.2 和之前的其他版本不同）。SSLEngine 实例会在之前原本会抛出 SSLHandshakeException 的部分情况下抛出 SSLProtocolException。不支持 0-RTT 模式。公共 Conscrypt API现在，Conscrypt 安全提供程序包含适用于 TLS 功能的公共 API。过去，用户可以通过反射来访问此功能。但是，由于在 Android P 中增加了关于调用非公共 API 的限制，因此这已在 Android Q 中加入了灰名单，并将在未来版本中进一步受限。 此更新在 android.net.ssl 下增加了一组类，这些类包含用于访问通用 javax.net.ssl API 不提供的功能的静态方法。这些类的名称为相关 javax.net.ssl 类的复数，用户可以由此推断是否为这些类。例如，在 javax.net.ssl.SSLSocket 实例中运行的代码可以使用新的 android.net.ssl.SSLSockets 类中的方法。 连接功能Android Q 包含一些与网络和连接相关的改进。 WLAN 网络连接 APIAndroid Q 增加了对点对点连接的支持。借助此功能，应用可以使用 WifiNetworkSpecifier 描述所请求网络的属性，以此来提示用户更改设备连接到的接入点。点对点连接用于“非网络提供”目的，例如 Chromecast 和 Google Home 硬件等辅助设备的引导配置。 使用此 API 时，您需要遵循以下流程： 使用 WifiNetworkSpecifier.Builder 创建 WLAN 网络说明符。 设置网络过滤器以匹配要连接到的网络以及所需凭据。 在每个请求中确定 SSID、SSID pattern、BSSID 和 BSSID pattern 的组合以设置网络过滤器，但要遵循以下要求： 每个请求都应该至少提供 SSID、SSID pattern、BSSID 或 BSSID pattern 中的一个每个请求都只能设置 SSID 或 SSID pattern 中的一个每个请求都只能设置 BSSID 或 BSSID pattern 中的一个将说明符以及一个 NetworkCallback 实例添加到该网络请求中，以跟踪该请求的状态。 如果用户接受该请求且成功连接到网络，则系统将对回调对象调用 NetworkCallback.onAvailable()。如果用户拒绝该请求或未成功连接到网络，则系统将对回调对象调用 NetworkCallback.onUnavailable()。 点对点连接不需要位置权限和 WLAN 权限。如果您发起连接到对等设备的请求，便会在同一设备上启动一个对话框，让相应设备的用户可以通过此对话框来接受连接请求。 绕过用户批准用户应某个特定应用的请求批准连接到某个网络后，设备便会存储用户针对相应接入点的批准响应。如果该应用再次发出连接到此接入点的特定请求，则设备会跳过用户批准阶段，并自动连接到此网络。在连接到 API 请求的网络后，如果用户选择取消保存该网络，则系统会移除该应用和网络组合对应的已存储批准响应，相应应用将来发出的任何请求都需要由用户再次批准。如果应用发出非特定（例如使用 SSID 或 BSSID pattern）请求，则用户需要批准相应请求。 代码示例以下代码示例显示了如何使用前缀为“test”的 SSID 和 OUI 为“10:03:23”的 BSSID 连接到开放网络。 KOTLINval specifier = WifiNetworkSpecifier.Builder() .setSsidPattern(PatternMatcher(&quot;test&quot;, PatternMatcher.PATTERN_PREFIX)) .setBssidPattern(MacAddress.fromString(&quot;10:03:23:00:00:00&quot;), MacAddress.fromString(&quot;ff:ff:ff:00:00:00&quot;)) .build() val request = NetworkRequest.Builder() .addTransportType(NetworkCapabilities.TRANSPORT_WIFI) .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) .setNetworkSpecifier(specifier) .build() val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager val networkCallback = object : ConnectivityManager.NetworkCallback() { ... override fun onAvailable(network: Network?) { // do success processing here.. } override fun onUnavailable() { // do failure processing here.. } ... } connectivityManager.requestNetwork(request, networkCallback) ... // Release the request when done. connectivityManager.unregisterNetworkCallback(networkCallback)WLAN 网络建议 APIAndroid Q 扩大了支持范围，现在允许应用为设备添加网络凭据，以自动连接到 WLAN 接入点。您可以使用 WifiNetworkSuggestion 提供关于要连接到哪个网络的建议。平台最终会根据您的应用和其他应用的输入来选择要接受的接入点。 以下代码示例显示了如何为一个开放网络、一个 WPA2 网络和一个 WPA3 网络提供凭据： KOTLINval suggestion1 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test111111&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestion2 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test222222&quot;) .setWpa2Passphrase(&quot;test123456&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestion3 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test333333&quot;) .setWpa3Passphrase(&quot;test6789&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestionsList = listOf(suggestion1, suggestion2, suggestion3) val wifiManager = context.getSystemService(Context.WIFI_SERVICE) as WifiManager val status = wifiManager.addNetworkSuggestions(suggestionsList); if (status != WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS) { // do error handling here } // Optional (Wait for post connection broadcast to one of your suggestions) val intentFilter = IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION); val broadcastReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { if (!intent.action.equals(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) { return; } // do post connect processing here } }; context.registerReceiver(broadcastReceiver, intentFilter);来自应用的建议必须先得到用户批准，然后平台才会发起到建议的网络的连接。当平台第一次在扫描结果中找到与应用提供的其中一个建议相匹配的网络时，将由用户响应通知进行批准。当平台连接到建议的其中某个网络时，设置会显示相关文本以将网络连接归因于提出建议的相应应用。 处理用户断开连接的行为如果用户在应用连接到建议的某个网络时使用 WLAN 选择器明确断开与该网络的连接，则该网络会被列入黑名单 24 小时。在该网络被列入黑名单期间，即使应用移除并重新添加与该网络对应的网络建议，系统也不会考虑自动连接该网络。 更改应用的审批状态用户拒绝接收网络建议通知时会从应用中移除 CHANGE_WIFI_STATE 权限。用户稍后可以通过转到 WLAN 控制菜单（依次转到设置 &gt; 应用和通知 &gt; 特殊应用权限 &gt; WLAN 控制 &gt; 应用名称）对此作出批准。 改进了 WLAN 高性能和低延迟模式借助 Android Q，您可以为底层调制解调器提供提示，以最大限度地缩短延迟。 Android Q 扩展了 WLAN Lock API，以有效地支持高性能和低延迟模式。系统会针对高性能和低延迟模式停用 WLAN 节能模式，并且您可以在低延迟模式下启用进一步的延迟优化（具体取决于调制解调器支持）。 仅当获取锁的应用在前台运行且屏幕处于开启状态时才能启用低延迟模式。低延迟模式对实时移动游戏应用尤其有用。 DNS 解析器中的专用查找Android Q 增加了对“通过传输层安全协议 (TLS) 执行 DNS”和进行专用 DNS 查找的支持。以前，平台 DNS 解析器支持 A 类解析，它可以根据域名来解析 IP 地址，而无需与通过此 IP 提供的服务有关的具体信息。经过此次更新，它现在还支持 SRV 和 NAPTR 查找。 Android Q 可以为开发者提供标准明文查找和“通过传输层安全协议 (TLS) 执行 DNS”模式。 WLAN Easy Connect借助 Android Q，您可以利用 Easy Connect 为对等设备配置 WLAN 凭据，以替代已弃用的 WPS。应用可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 将 Easy Connect 集成到其设置和配置流程中。此 intent 需要 URI。调用应用可以通过各种方法来检索 URI，包括扫描贴纸或显示屏中的二维码，或扫描蓝牙 LE 或 NFC 广告。 URI 一经可用，您就可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 来配置对等设备的 WLAN 凭据。这样一来，用户就可以选择 WLAN 网络以共享并安全地传输相关凭据。 Easy Connect 不需要位置权限或 WLAN 权限。 注意：在使用此 intent 之前，应用必须先通过调用 WifiManager.isEasyConnectSupported() 验证设备是否支持 Easy Connect。Wi-Fi Direct connection APIWifiP2pConfig 和 WifiP2pManager API 类在 Android Q 中有更新，以支持利用预先确定的信息快速与 WLAN 直连建立连接的功能。此信息通过边信道进行共享，例如蓝牙或 NFC。 以下代码示例显示了如何使用预先确定的信息来创建群组： KOTLINval manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager val channel = manager.initialize(this, mainLooper, null) // prefer 5G band for this group val config = WifiP2pConfig.Builder() .setNetworkName(&quot;networkName&quot;) .setPassphrase(&quot;passphrase&quot;) .enablePersistentMode(false) .setGroupOperatingBand(WifiP2pConfig.GROUP_OWNER_BAND_5GHZ) .build() // create a non-persistent group on 5GHz manager.createGroup(channel, config, null)要使用凭据加入群组，请将 manager.createGroup() 替换为以下内容： KOTLIN manager.connect(channel, config, null) 蓝牙 LE 连接导向型频道 (CoC)借助 Android Q，您的应用可以使用 BLE CoC 连接在两个 BLE 设备之间传输较大的数据流。此接口抽象化处理了蓝牙和连接机制，以简化实现。 电话功能Android Q 包含一些与电话相关的改进。 通话质量方面的改进Android Q 增加了在支持相关功能的设备上收集进行中的 IP 多媒体子系统 (IMS) 通话质量相关信息的功能，包括通过网络接听和拨打电话的质量。 选接电话和来电显示Android Q 让您的应用可以将用户通讯录中不存在号码的来电标识为潜在骚扰电话，以及代表用户拒接骚扰电话而不响铃。系统会在通话记录中将这些已屏蔽的来电的相关信息记录为已屏蔽的来电，以便用户更清楚地了解何时有过未接来电。使用此新版 API，不需要从用户那里获取 READ_CALL_LOG 权限就可以提供选接电话和来电显示功能。 Call Redirection Service APIAndroid Q 更改了来电 Intent 的处理方式。我们弃用了 NEW_OUTGOING_CALL 广播，并将其替换为 CallRedirectionService API。CallRedirectionService 提供了相关接口，以供您修改 Android 平台拨打的去电。例如，第三方应用可能会取消通话并通过 VoIP 对其进行重新路由。 在外部存储设备中创建文件的相关改进除了引入分区存储隐私权行为变更之外，Android Q 还在写入文件方面提供了更大的灵活性，添加了可以帮助您影响这些文件在外部存储设备上的保存位置的功能。 新媒体文件的待处理状态Android Q 引入了 IS_PENDING 标记，通过此标记，您的应用可以在媒体文件写入磁盘时进行独占访问。 以下代码段显示了在应用中创建新图片时如何使用 IS_PENDING 标记。 KOTLINval values = ContentValues().apply { put(MediaStore.Images.Media.DISPLAY_NAME, &quot;IMG1024.JPG&quot;) put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;) put(MediaStore.Images.Media.IS_PENDING, 1) } val resolver = context.getContentResolver() val collection = MediaStore.Images.Media .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY) val item = resolver.insert(collection, values) resolver.openFileDescriptor(item, &quot;w&quot;, null).use { pfd -&gt; // Write data into the pending image. } // Now that we&apos;re finished, release the &quot;pending&quot; status, and allow other apps // to view the image. values.clear() values.put(MediaStore.Images.Media.IS_PENDING, 0) resolver.update(item, values, null, null)对存储位置的影响Android Q 引入了多种功能，可以帮助您整理您的应用存储在外部存储设备上的文件。 目录提示当您的应用将媒体存储在搭载 Android Q 的设备上时，系统默认按照媒体的类型对其进行整理。例如，默认情况下，新图片文件会存储在“pictures”目录下。 如果您的应用知道应存储文件的具体位置（例如 Pictures/MyVacationPictures），您可以设置 MediaColumns.RELATIVE_PATH，以便提示系统在何处存储新写入的文件。同样，您可以在调用 update() 期间通过更改 MediaColumns.RELATIVE_PATH 或 MediaColumns.DISPLAY_NAME 来移动磁盘上的文件。 设备选择在 Android 9（API 级别 28）及更低版本中，保存到外部存储设备上的所有文件都显示在名为 external 的单个卷下。但是，Android Q 为每个外部存储设备都提供唯一的卷名称。这一新的命名系统可帮助您高效地整理内容并将内容编入索引，还可让您控制新内容的存储位置。 主要共享存储设备始终称为 VOLUME_EXTERNAL_PRIMARY。您可以通过调用 MediaStore.getExternalVolumeNames() 发现其他卷。 要查询、插入、更新或删除特定卷，请将卷名称传递到 MediaStore API 中的任何 getContentUri() 方法，如以下代码段中所示： // Publish an audio file onto a specific external storage device. val values = ContentValues().apply { put(MediaStore.Audio.Media.RELATIVE_PATH, &quot;Music/My Album/My Song&quot;) put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Song.mp3&quot;) } // Assumes that the storage device of interest is the 2nd one // that your app recognizes. val volumeNames = MediaStore.getExternalVolumeNames(context) val selectedVolumeName = volumeNames[1] val collection = MediaStore.Audio.Media.getContentUri(selectedVolumeName) val item = resolver.insert(collection, values)注意：在 Android Q 中，StorageVolume 类中的 createAccessIntent() 方法已被弃用，因此您不应使用此方法浏览外部存储设备。如果您这么做，Android Q 设备的用户将无法在您的应用中查看保存在外部存储设备中的文件。媒体和图形Android Q 引入了以下媒体和图形方面的新功能和 API： 捕获播放的音频Android Q 可让应用捕获其他应用播放的音频。要了解所有详情，请参阅捕获播放的音频。 原生 MIDI API借助 Android Native MIDI API (AMidi)，应用开发者可以使用 C/C++ 代码发送和接收 MIDI 数据、与 C/C++ 音频/控制逻辑进行更紧密的集成以及最大限度地减少对 JNI 的需求。 有关详情，请参阅 Android Native MIDI API。 MediaCodecInfo 方面的改进MediaCodecInfo 中有一些新方法可以显示有关编解码器的更多信息： isSoftwareOnly()如果编解码器仅在软件中运行，则返回 true。软件编解码器并不能保证渲染性能。isHardwareAccelerated()如果编解码器由硬件加速，则返回 true。isVendor()如果编解码器由设备供应商提供，则返回 true；如果由 Android 平台提供，则返回 false。isAlias()MediaCodecList 可能针对使用备用编解码器名称（别名）的同一底层编解码器包含额外的条目。如果此条目中的编解码器是另一个编解码器的别名，则此方法会返回 true。此外，MediaCodec.getCanonicalName() 会针对通过别名创建的编解码器返回底层编解码器名称。 性能点“性能点”表示编解码器以特定高度、宽度和帧速率渲染视频的能力。例如，UHD_60 性能点表示以每秒 60 帧的速度渲染超高清视频（3840x2160 像素）。 方法 MediaCodecInfo.VideoCapabilities.getSupportedPerformancePoints() 会返回编解码器可以渲染或捕获的 PerformancePoint 条目列表。 您可以通过调用 PerformancePoint.covers(PerformancePoint) 检查给定的 PerformancePoint 是否会覆盖另一个性能点。例如，UHD_60.covers(UHD_50) 会返回 true。 我们为所有硬件加速的编解码器都提供了性能点列表。如果编解码器连标准性能点的最低值都不能满足，则此列表可能为空。 请注意，已升级到 Android Q 但未更新供应商映像的设备是没有性能点数据的，因为此数据来自供应商 HAL。在这种情况下，getSupportedPerformancePoints() 会返回 null。 ANGLE在 Android Q 发布后，Android 开发者和合作伙伴可以选择使用 ANGLE 运行应用；ANGLE 是 Chrome 组织中的一个项目，能够将 ES 置于 Vulkan 上层，而不必使用供应商提供的 ES 驱动程序。 有关详情，请参阅 ANGLE。 Thermal API当设备过热时，它们可能会限制 CPU 和/或 GPU，而这可能会以意想不到的方式影响应用和游戏。使用复杂图形、大量计算或持续网络活动的应用更有可能遇到问题，并且问题可能因芯片组和核心频率、集成级别以及设备封装和设备类型而异。 现在，在 Android Q 中，应用和游戏可以使用 Thermal API 监控设备变化情况，并在设备过热时采取措施维持低电耗状态，使设备恢复到正常温度。应用在 PowerManager 中注册监听器，系统通过该监听器报告持续的热状态，热状态的范围从轻度和中度到重度、危急、紧急和关机。 当设备报告热应力时，各应用和游戏可以减少正在进行的活动，以此来帮助减少各个方面的耗电量。例如，影音在线播放应用可以降低分辨率/比特率或减少网络流量；相机应用可以停用闪光灯或密集型图像增强；游戏可以降低帧速率或减少多边形曲面细分；媒体应用可以降低扬声器音量；地图应用可以关闭 GPS。 Thermal API 需要新的设备 HAL 层，目前在搭载 Android Q 的 Pixel 设备上受支持。我们正在与设备制造商合作伙伴合作，以期尽快为生态系统提供广泛支持。 摄像头和图片Android Q 引入了摄像头和图片方面的以下新功能： 单色摄像头支持Android 9（API 等级 28）首次引入了单色摄像头功能。Android Q 为单色摄像头支持增加了几项增强功能： 新增了对 Y8 流格式的支持，以提高内存效率。支持单色原始 DNG 捕获。引入了 MONO 和 NIR CFA 枚举，以区分常规单色摄像头和近红外摄像头。您可以使用此功能来捕捉原生单色图片。逻辑多摄像头设备可以使用单色摄像头作为物理子摄像头，以获取更出色的低光图片质量。 动态深度格式从 Android Q 开始，摄像头可以使用名为“动态深度格式”(DDF) 的新架构将图片的深度数据存储在单独的文件中。应用可以请求 JPG 图片及其深度元数据，以便在后期处理中利用这些信息来应用所需的模糊处理，而无需修改原始图片数据。 要了解新格式的规范，请参阅动态深度格式。 高效率图片文件格式高效率图片文件 (HEIF) 格式是一种标准的图片和视频格式，与其他文件格式相比，这种格式的编码质量更高，文件更小。 如需详细了解此文件格式，请参阅 HEIC。 多摄像头方面的改进Android 9（API 级别 28）中引入了将多摄像头融合成单个逻辑摄像头的功能，Android Q 对此功能进行了改进。Camera2 API 中添加了以下内容： isSessionConfigurationSupported(SessionConfiguration sessionConfig) - 使您能够查询传递的会话配置能否用于创建摄像头拍摄会话。 LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID - 使您能够确定支持逻辑摄像头设备的有效物理摄像头的 ID。您可以使用返回的 ID 来请求逻辑信息流和物理子摄像头信息流，以提高用电效率。 无障碍服务 APIAndroid Q 引入了以下新的无障碍服务功能和 API： AccessibilityNodeInfo 输入键标记在 Android Q 中，AccessibilityNodeInfo 得到了增强，现在增加了一个新标记，用于指示其是否代表文本输入键的。您可以使用 AccessibilityNodeInfo.isTextEntryKey() 方法来访问此标记。 无障碍对话框语音反馈当无障碍服务要求用户重复按无障碍快捷方式以启动服务时，此对话框现在可以在服务请求时附带文字转语音提示。 物理键盘的无障碍快捷方式在 Android Q 中，用户现在可以通过物理键盘来触发无障碍快捷方式，只需按 Control+Alt+Z 即可。 软键盘控制器增强功能在 Android Q 中，无障碍服务现在可以请求显示软键盘，即使设备检测到连接了硬键盘也不例外。用户可以替换此行为。 用户定义的无障碍服务超时Android Q 引入了 API 方法 AccessibilityManager.getRecommendedTimeoutMillis()，用于为用户针对互动式和非互动式的无障碍界面元素定义的超时提供支持。返回值受用户偏好设置和无障碍服务 API 的影响。 自动填充方面的改进Android Q 包含对自动填充服务的以下改进。 与兼容性相关的自动填充请求您现在可以使用 FillRequest.FLAG_COMPATIBILITY_MODE_REQUEST 标记确定是否通过兼容性模式生成了自动填充请求。 同时保存用户名和密码借助 SaveInfo.FLAG_DELAY_SAVE 标记，应用现在可以使用多个 Activity 显示用户名、密码和其他字段。 用户与保存界面的互动您现在可以在保存对话框中显示和隐藏密码字段，只需在此对话框中设置操作监听器，并更改相应密码远程视图的可见性即可。 支持更新数据集现在，自动填充功能可以更新现有密码。例如，如果用户已经存储了一个密码，然后又保存了一个新密码，则自动填充功能现在会提示用户更新现有密码，而不是保存新密码。 字段分类方面的改进Android Q 包含对 Field Classification API 的以下改进。 UserData.Builder 构造函数我们更改了 UserData.Builder 构造函数，现在可以更好地契合 Builder 模式。 允许将一个值映射到多种类别 ID在使用 Android Q 中的 UserData.Builder 时，您现在可以将一个值映射到多种类别 ID。在以前的版本中，如果一个值被添加多次，系统就会抛出异常。 改进了对信用卡号码的支持现在，字段分类可以检测四位数字作为信用卡号码的最后四位数字。 支持特定于应用的字段分类Android Q 增加了 FillResponse.setUserData()，让您能够在会话期间设置特定于应用的用户数据。这有助于自动填充服务检测包含特定于应用的内容的字段的类型。 界面和系统控件Android Q 提供以下界面方面的改进： 支持 JVMTI PopFrame 功能Android Q 增加了对 Android JVMTI 实现中的 can_pop_frames 功能的支持。在调试时，此功能让您能够在断点暂停并调整函数的局部变量、全局变量或实现，然后重新运行函数。有关详情，请参阅 Oracle 的 Pop Frame 参考页面。 Surface Control APIAndroid Q 提供了一个 SurfaceControl API，用于对系统合成器 (SurfaceFlinger) 进行底层访问。对于大多数用户而言，SurfaceView 是使用此合成器的正确方法。SurfaceControl API 在某些情况下很有用，例如： 同步多个表面跨进程的表面嵌入底层生命周期管理SurfaceControl API 在 SDK 和 NDK 绑定中都可用。NDK 实现包含用于与合成器手动交换缓冲区的 API。这为遇到 BufferQueue 限制的用户提供了一种替代方案。 WebView 挂起渲染程序检测Android Q 引入了一个新的 WebViewRenderProcessClient 抽象类，应用可以使用该抽象类检测 WebView 是否无响应。要使用此类，请执行以下操作： 定义您自己的子类，并实现其 onRenderProcessResponsive() 和 onRenderProcessUnresponsive() 方法。将 WebViewRenderProcessClient 的实例附加到一个或多个 WebView 对象上。如果 WebView 无响应，系统将调用客户端的 onRenderProcessUnresponsive() 方法，在调用时会传递 WebView 和 WebViewRenderProcess（如果 WebView 是单进程，WebViewRenderProcess 参数将为 null）。您的应用可以执行适当的操作，例如向用户显示一个对话框，以询问其是否要暂停渲染流程。如果 WebView 仍然无响应，则系统会定期调用 onRenderProcessUnresponsive()（频率不高于每 5 秒一次），但不会执行其他任何操作。如果 WebView 再次无响应，系统只调用 onRenderProcessResponsive() 一次。 设置面板Android Q 引入了“设置面板”，这是一种 API，让应用能够在自身环境中向用户显示设置。这可以避免用户转到设置更改 NFC 或移动数据等设置，以便使用此应用。 图 1. 用户尝试在设备未连接到网络时打开网页。Chrome 弹出互联网连接设置面板… 图 2. 用户可以开启 WLAN 并选择网络，而无需离开 Chrome 应用。例如，假设用户打开了网络浏览器，而其设备已开启飞行模式。在 Android Q 之前的版本中，此应用只能显示一条通用消息，要求用户打开设置以恢复连接。而借助 Android Q，浏览器应用便可以显示一个内嵌面板，其中会显示各种主要连接设置，例如飞行模式、WLAN（包括附近的网络）和移动数据。借助此面板，用户无需离开应用即可恢复连接。 要显示设置面板，请发出具有某个新 Settings.Panel 操作的 intent： KOTLINval panelIntent = Intent(Settings.Panel.settings_panel_type) startActivityForResult(panelIntent)settings_panel_type 可以是下列项之一： ACTION_INTERNET_CONNECTIVITY显示与互联网连接相关的设置，例如飞行模式、WLAN 和移动数据。ACTION_WIFI：显示 WLAN 设置，但不显示其他连接设置。这对于需要 WLAN 连接以执行大容量上传或下载的应用非常有用。ACTION_NFC显示与近距离无线通信 (NFC) 相关的所有设置。ACTION_VOLUME显示所有音频流的音量设置。我们计划针对此功能引入一个 AndroidX 封装容器。在搭载 Android 9（API 级别 28）或更低级别的设备上调用时，此封装容器会在设置应用中打开最合适的页面。 共享功能方面的改进Android Q 为共享功能提供了多项改进。要了解所有详情，请参阅 Android Q 中共享功能方面的改进。 深色主题背景Android Q 提供全新的深色主题背景，既会应用于 Android 系统界面，也会应用于设备上运行的应用。要了解所有详情，请参阅深色主题背景。 前台服务类型Android Q 引入了一个新的 XML 清单属性 foregroundServiceType，您可以将其包含在多项特定服务的定义中。虽然很少适用，但您可以为一项特定服务分配多个前台服务类型。 下表显示了不同的前台服务类型，以及适合在其中声明特定类型的服务： 前台服务类型 应声明相应类型的服务的示例使用情形connectedDevice 监控穿戴式设备健身跟踪器dataSync 从网络下载文件location 延续用户发起的操作mediaPlayback 播放有声读物、播客或音乐mediaProjection 简短地录屏phoneCall 处理正在进行的通话KotlinAndroid Q 对 Kotlin 开发进行了以下更新。 libcore API 的可空性注释Android Q 改进了 SDK 中针对 libcore API 的可空性注释的覆盖范围。借助这些注释，在 Android Studio 中使用 Kotlin 或 Java 可空性分析的应用开发者可以在与这些 API 互动时获取非 Null 信息。 通常，Kotlin 中的为空性合同违规行为会导致编译错误。为确保与现有代码兼容，所有新注释都仅限于 @RecentlyNullable 和 @RecentlyNonNull。这意味着为空性违规行为会引发警告，而不是错误。 此外，Android 9 中添加的所有 @RecentlyNullable 或 @RecentlyNonNull 注释都会分别更改为 @Nullable 和 @NonNull。这意味着为空性违规行为现在会引发错误，而不是警告。 要详细了解注释方面的变更，请参阅 Android 开发者博客中的 Android Pie SDK 现已更适用于 Kotlin一文。 NDKAndroid Q 包含以下 NDK 方面的变更。 改进了文件描述符所有权的调试Android Q 增加了 fdsan，它可以帮助您更轻松地查找和修复文件描述符所有权方面的问题。 与错误处理文件描述符所有权相关的错误（通常表现为“use-after-close”和“double-close”）类似于内存分配“use-after-free”和“double-free”错误，但通常更难以诊断和修复。“fdsan”会尝试通过强制执行文件描述符所有权来检测和/或防止文件描述符误管理。 要详细了解与这些问题相关的崩溃，请参阅 fdsan 检测到的错误。要详细了解 fdsan，请参阅关于 fdsan 的 Googlesource 页面。 ELF TLS使用 API 级别 29 及更高版本的 NDK 编译的应用无需再使用 emutls，但可以改为使用 ELF TLS。我们增加了对动态和静态链接器的支持，以支持处理线程局部变量的新方法。 对于针对 API 级别 28 及更低版本编译的应用，我们实现了针对 libgcc/compiler-rt 的改进，以便解决一些 emutls 问题。 有关详情，请参阅面向 NDK 开发者的 Android 变更。 运行时Android Q 包含以下运行时方面的变更。 触发基于 Mallinfo 的垃圾回收当小型平台 Java 对象引用 C++ 堆中的大型对象时，通常只有在系统已回收并（举例而言）最终确定 Java 对象后，才能回收 C++ 对象。在之前的版本中，平台会估算与 Java 对象相关联的许多 C++ 对象的大小。这种估算并不总是准确，并且偶尔会导致内存使用量大大增加，因为平台无法在应该进行垃圾回收时完成回收。 在 Android Q 中，垃圾回收器 (GC) 会跟踪系统 malloc() 分配的堆的总大小，以确保 malloc() 分配的大型堆始终包含在可触发 GC 的计算中。因此，与 Java 执行交错大量 C++ 分配的应用可能会出现垃圾回收频率提高的现象。其他应用的频率则可能会略有下降。 测试和调试Android Q 包含以下测试和调试方面的改进。 改进了设备上系统跟踪功能现在，您在执行设备上系统跟踪时可以指定跟踪的记录大小和持续时间限制。在您指定任一值后，系统便会执行长期跟踪，并在记录跟踪时定期将跟踪缓冲区复制到目标文件。在达到您指定的记录大小或持续时间限制后，跟踪便会完成。 请使用这些附加参数来测试除了您使用标准跟踪进行测试的用例之外的其他用例。例如，您可能正在诊断某个性能错误，而此错误仅在您的应用长时间运行后才会发生。在这种情况下，您可以记录为期一整天的长期跟踪，然后分析 CPU 调度程序、磁盘活动、应用线程以及报告中的其他数据，以帮助您确定造成此错误的原因。 TextClassifier 改进Android Q 在 TextClassifier 接口中提供了其他文本分类功能。 语言检测TextClassifier 现在具有 detectLanguage() 方法。此方法的工作方式与现有分类方法类似，即接收 TextLanguage.Request 对象并返回 TextLanguage 对象。 新的 TextLanguage 对象包含一系列有序对。每个有序对都包含所请求文本示例的语言区域和相应的置信度得分。 建议采取的对话操作TextClassifier 现在具有 suggestConversationActions() 方法。此方法的工作方式与现有分类方法类似，即接收 ConversationActions.Request 对象并返回 ConversationActions 对象。 新的 ConversationActions 对象包含一系列 ConversationAction 对象。每个 ConversationAction 对象都包含建议采取的可行操作及其置信度得分。 通知中的智能回复/操作Android 9 引入了在通知中显示建议回复的功能。从 Android Q 开始，通知中还可以包含基于 intent 的建议操作。此外，现在系统可以自动生成这些建议。应用仍然可以提供它们自己的建议，或选择停用系统生成的建议。 用于生成这些回复的 API 是 TextClassifier 的一部分，且已在 Android Q 中直接提供给开发者。如需了解详情，请参阅关于 TextClassifier 改进的部分。 如果您的应用提供自己的建议，则平台不会生成任何自动建议。如果您不希望应用的通知显示任何建议回复或操作，可以通过使用 setAllowGeneratedReplies() 和 setAllowSystemGeneratedContextualActions() 选择停用系统生成的回复和操作。","categories":[{"name":"Android","slug":"Android","permalink":"http://github.zhangyongfa888.site/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://github.zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"滴滴调整北京市网约车价格 将16区按计价标准划分为5大类","slug":"HEXO-Admin","date":"2019-07-10T02:57:00.000Z","updated":"2019-07-10T05:08:52.902Z","comments":true,"path":"2019/07/10/HEXO-Admin/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/10/HEXO-Admin/","excerpt":"","text":"滴滴调整北京市网约车价格 将16区按计价标准划分为5大类本报讯（记者 陈雪柠）针对不同时间的需求状况，滴滴将对本市网约车价格进行调整。昨天，滴滴出行发布本市滴滴网约车价格调整说明，宣布自7月11日起，滴滴网约车将根据区域进行价格调整。 滴滴将全市16区按计价标准划分为5大类。其中，东城区、西城区、海淀区、朝阳区、丰台区、石景山区、昌平区、门头沟区为一类，顺义区、通州区、大兴区、房山区为一类，密云区、怀柔区为一类，延庆区及平谷区则各自单独计价。 以东城区、西城区等区域计价标准看，调整后，工作日早6点至10点的早高峰时段，起步价由13元涨至14元，里程费由1.6元/公里涨至1.8元/公里，时长费不变；早10点至晚5点的平峰时段，里程费由1.6元/公里降至1.45元/公里，时长费由0.5元/公里降至0.4元/公里，起步价不变；晚5点至晚9点的晚高峰时段，起步价由13元涨至14元，里程费由1.6元/公里降至1.5元/公里，时长费不变；晚9点至早6点的夜间时段，起步价由13元涨至14元，里程费由1.6元/公里涨至2.15元/公里，时长费由1元降至0.8元/公里。 总体看，高峰时段价格普遍上涨，平峰时段价格有所降低。远郊区起步价降低，其中延庆区、平谷区起步价均为8元，密云区、怀柔区起步价也降低为11.5元。 对于价格调整的原因，滴滴出行表示是调节供需平衡，撮合司乘需求。“我们会基于不同城市不同时间的供需状况，并参考当地的消费水平、收入水平和能源价格等因素，合理地调整网约车价格。价格机制要满足乘客需求，还要让司机能获得合理的收入。” 滴滴建议市民合理安排行程尽量错峰出行；在高峰期用车可选择“同时呼叫”或拼车，提高出行效率；不好叫车时，可选择APP内单车或“公交”路线査询功能，选择其他出行方式。","categories":[{"name":"IT","slug":"IT","permalink":"http://github.zhangyongfa888.site/categories/IT/"}],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://github.zhangyongfa888.site/tags/互联网/"}],"author":"zhangyognfa"},{"title":"Hello World","slug":"hello-world","date":"2019-07-09T07:09:38.366Z","updated":"2019-07-09T07:09:38.366Z","comments":true,"path":"2019/07/09/hello-world/","link":"","permalink":"http://github.zhangyongfa888.site/2019/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}