{"meta":{"title":"WE ARE YOUNG","subtitle":"So let's set the world on fire","description":null,"author":"zhangyongfa","url":"http://zhangyongfa888.site","root":"/"},"pages":[{"title":"","date":"2019-12-09T05:32:59.711Z","updated":"2019-12-09T05:32:50.941Z","comments":true,"path":"api/index.html","permalink":"http://zhangyongfa888.site/api/index.html","excerpt":"","text":""},{"title":"404 Not Found：该页无法显示","date":"2019-12-19T03:20:20.715Z","updated":"2019-12-19T03:20:20.715Z","comments":true,"path":"404/index.html","permalink":"http://zhangyongfa888.site/404/index.html","excerpt":"","text":"404 L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":150,\"height\":300,\"position\":\"left\",\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":false,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});"},{"title":"分类","date":"2019-07-09T07:41:26.000Z","updated":"2019-07-10T05:07:09.428Z","comments":false,"path":"categories/index.html","permalink":"http://zhangyongfa888.site/categories/index.html","excerpt":"","text":"分类1"},{"title":"日常分享","date":"2019-07-31T00:28:23.000Z","updated":"2019-08-14T05:33:28.356Z","comments":true,"path":"share/index.html","permalink":"http://zhangyongfa888.site/share/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-07-09T07:40:35.000Z","updated":"2019-07-10T05:01:57.990Z","comments":false,"path":"tags/index.html","permalink":"http://zhangyongfa888.site/tags/index.html","excerpt":"","text":""},{"title":"企业安装包下载","date":"2020-03-10T05:58:58.099Z","updated":"2020-03-10T05:58:58.099Z","comments":true,"path":"download/index.html","permalink":"http://zhangyongfa888.site/download/index.html","excerpt":"","text":"企业版下载地址（蓝奏云）企业测试1.1.1企业正式1.1.1企业测试1.1.2 icon"}],"posts":[{"title":"酷q机器人实践","slug":"酷q机器人实践","date":"2020-07-03T07:32:00.000Z","updated":"2020-07-06T00:52:49.565Z","comments":true,"path":"2020/07/03/酷q机器人实践/","link":"","permalink":"http://zhangyongfa888.site/2020/07/03/酷q机器人实践/","excerpt":"","text":"START酷Q官方地址 STEP1选择合适的语言官方sdk 根据自己熟悉的语言选择sdk 这里选择了java 按照官方给的步骤走一遍 你会发现json解析失败。 可能原因就是官方从cpk包太旧 与开发的jar包不统一问题 解决办法 :参考这里 ⇣⇣⇣ 需要注意的是，部署过1.0版本的请手动把JCQ老版本的cpk和数据目录删了，因为老版本几乎是基于jcq-1.2.7，新版本基于jcq-1.3.1 -具体操作： 1.删除酷Q目录下app文件夹内jcq的cpk插件，并下载新版JCQ1.3.1放在此处 2.删除酷Q目录下data/app/org.meowy.cqp.jcq/和data/app/org.meowy.cqp.jcq/,然后回到酷Q根目录把release解压出来的data目录丢进去覆盖 在\\酷Q Air\\data\\app\\org.meowy.cqp.jcq\\conf中新建文件 JCQ.cfg [App] com.example.demo.status=1 com.aye10032.broadcastbot.status=1一切就绪后 代码片段 qq机器人 使用的工具 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.meowy.cqp&lt;/groupId&gt; &lt;artifactId&gt;jcq-coolq&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.squareup.okhttp3&lt;/groupId&gt; &lt;artifactId&gt;okhttp&lt;/artifactId&gt; &lt;version&gt;3.14.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.json&lt;/groupId&gt; &lt;artifactId&gt;json&lt;/artifactId&gt; &lt;version&gt;20180813&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;其他工具https://zhangyongfa888.lanzous.com/b099b6upg 密码:dzbm","categories":[{"name":"JAVA","slug":"JAVA","permalink":"http://zhangyongfa888.site/categories/JAVA/"},{"name":"robot","slug":"JAVA/robot","permalink":"http://zhangyongfa888.site/categories/JAVA/robot/"}],"tags":[{"name":"AI","slug":"AI","permalink":"http://zhangyongfa888.site/tags/AI/"}],"author":"zhangyongfa"},{"title":"flutter初探","slug":"flutter初探","date":"2020-06-18T01:20:00.000Z","updated":"2020-06-18T02:10:37.559Z","comments":true,"path":"2020/06/18/flutter初探/","link":"","permalink":"http://zhangyongfa888.site/2020/06/18/flutter初探/","excerpt":"","text":"极速构建漂亮的原生应用Flutter是谷歌的移动UI框架，可以快速在iOS和Android上构建高质量的原生用户界面。 Flutter可以与现有的代码一起工作。在全世界，Flutter正在被越来越多的开发者和组织使用，并且Flutter是完全免费、开源的。 快速开发毫秒级的热重载，修改后，您的应用界面会立即更新。使用丰富的、完全可定制的widget在几分钟内构建原生界面。 富有表现力和灵活的UI快速发布聚焦于原生体验的功能。分层的架构允许您完全自定义，从而实现难以置信的快速渲染和富有表现力、灵活的设计。 原生性能Flutter包含了许多核心的widget，如滚动、导航、图标和字体等，这些都可以在iOS和Android上达到原生应用一样的性能。 开始目录结构 结构 android:android的工程目录 assets：自己创建的资源文件夹 在pubspec.yaml中添加下位置 ios：ios的工程目录 lib：flutter代码目录 pubspec.yaml：配置文件 常用的就是引用第三方库 dependencies: flutter: sdk: flutter cupertino_icons: ^0.1.3 http: &apos;&gt;=0.11.3+12&apos; flutter_swiper: ^1.1.6 fluttertoast: ^3.0.3 assets: - assets/images/assets是创建的资源目录的路径。修改完配置文件要put get 一下完成同步 demo文件main.dart编写的入口文件 其中包括 入口代码 void main() { runApp(MyApp()); }runApp需要的参数是一个 Widget void runApp(Widget app) { WidgetsFlutterBinding.ensureInitialized() ..scheduleAttachRootWidget(app) ..scheduleWarmUpFrame(); }widget可以理解为android中的View 遇到的问题1.状态栏高度和颜色颜色透明 SystemUiOverlayStyle systemUiOverlayStyle = SystemUiOverlayStyle(statusBarColor: Colors.transparent); SystemChrome.setSystemUIOverlayStyle(systemUiOverlayStyle);高度获取 final double statusBarHeight = MediaQuery.of(context).padding.top;2.组合view排列方式 Column垂直排列 Row水平排列 Column/Row 继承自Flex 所以也可以使用flex 并配置 direction: Axis.vertical3.视图圆角 Container( height: 40, width: 40, decoration: new BoxDecoration( color: bgColor, borderRadius: BorderRadius.all(Radius.circular(10))), ), color在decoration中设置了就不能在Container中设置了 4.frame布局使用Stack Stack( alignment: Alignment.center, children: [ Container( height: 40, width: 40, decoration: new BoxDecoration( color: bgColor, borderRadius: BorderRadius.all(Radius.circular(10))), ), Text( title.substring(0, 1), style: TextStyle(color: Colors.white, fontSize: 15), ), ],5.控件可点击包一层InkWell (onTap事件)或者FlatButton（onPress事件） 6.GridView设置包裹的高度防止滑动冲突 shrinkWrap: true,7.高度太长设置可以滑动 包一层SingleChildScrollView 8.一些常量都在constants.dart里 仿oa 首页 第二页","categories":[{"name":"Flutter","slug":"Flutter","permalink":"http://zhangyongfa888.site/categories/Flutter/"}],"tags":[{"name":"Flutter","slug":"Flutter","permalink":"http://zhangyongfa888.site/tags/Flutter/"}],"author":"zhangyongfa"},{"title":"SWIFT传值","slug":"SWIFT传值","date":"2020-06-01T08:21:00.000Z","updated":"2020-06-01T08:39:30.388Z","comments":true,"path":"2020/06/01/SWIFT传值/","link":"","permalink":"http://zhangyongfa888.site/2020/06/01/SWIFT传值/","excerpt":"","text":"参考：swift–四种传值(代理、闭包、属性、通知)https://www.cnblogs.com/adampei-bobo/p/8954042.html 属性场景：比如从A携带参数到B 如图B中需要获取前一页携带的参数 B页面 A页面 代理类型android的接口 例：第一步: 创建代理 第二步:在需要传值的地方传值 MySecondViewController().CallBack(back: &quot;123&quot;)通知安卓中的广播 1.注册通知 NotificationCenter.default.addObserver(self, selector: #selector(endTopicAction(obj:)), name: NSNotification.Name.init(&quot;11&quot;), object: nil)2.添加收到通知后的事件 @objc func endTopicAction(obj:Notification){ print(&quot;--------&quot;,obj.object!) }3.发送 let a = [[&quot;A&quot;:&quot;aaa&quot;],[&quot;B&quot;:&quot;bbb&quot;]] NotificationCenter.default.post(name: NSNotification.Name.EndTopicSuccessNoti, object: a)4.在注册页要注销 deinit { NotificationCenter.default.removeObserver(self) }闭包func testClosure(res:()-&gt;()){ res() } func testClosure(arg1:String,res:()-&gt;()) { res() } func testClosure(arg1:String,res:(String)-&gt;()) { res(arg1) } func testClosure(arg1:String,res:(String,String)-&gt;()) { res(arg1,&quot;111&quot;) } func testClosure(arg1:String,res:(String)-&gt;(Bool)) { let b = res(arg1) print(&quot;test4 return :&quot;,b)//return false } func testClosure(arg1:String,res:(String,String)-&gt;(Bool,Bool)) { let b = res(arg1,&quot;222&quot;) print(&quot;test5 return :&quot;,b.0,b.1)//return true false } 测试样例 testClosure(arg1: &quot;test1&quot;) { print(&quot;test1:无返回值&quot;) } //最后一个参数时候 可以尾随闭包 testClosure { } testClosure(){ } //不是尾随闭包 testClosure(res: { }) let block:(String,String)-&gt;() = { res1 ,res2 in print(res1,res2) } testClosure(arg1: &quot;aa&quot;, res: block) testClosure(arg1: &quot;test2&quot;) { (result) in print(&quot;test2:&quot;,result) } testClosure(arg1: &quot;test3&quot;) { (res1, res2) in print(&quot;test3:&quot;,res1,res2) } testClosure(arg1: &quot;test4&quot;) { (res3) -&gt; (Bool) in print(&quot;test4:&quot;,res3) return false } testClosure(arg1: &quot;test5&quot;) { (res4, res5) -&gt; (Bool, Bool) in print(&quot;test5:&quot;,res4,res5) return (true,false) } // // test1:无返回值 // test2: test2 // test3: test3 111 // test4: test4 // test4 return : false // test5: test5 222 // test5 return : true false // print({&quot;1&quot; &quot;2&quot; in &quot;1&quot;+&quot;2&quot;}) 类似block用法 A页面 let vc = DetailsViewController(); vc.block = { a1,a3 in print(&quot;22222222222&quot;,a1,a3) } B页面（DetailsViewController） var block:((String,String)-&gt;())? block?(&quot;12&quot;, &quot;we&quot;)","categories":[{"name":"swift","slug":"swift","permalink":"http://zhangyongfa888.site/categories/swift/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://zhangyongfa888.site/tags/ios/"}],"author":"zhangyongfa"},{"title":"iOS初探","slug":"iOS初探","date":"2020-05-25T05:28:00.000Z","updated":"2020-06-01T08:40:31.659Z","comments":true,"path":"2020/05/25/iOS初探/","link":"","permalink":"http://zhangyongfa888.site/2020/05/25/iOS初探/","excerpt":"","text":"目录结构 目录结构 项目里没有什么内容 项目结构 从上到下依次是 AppDelegate：APP启动时基本上每一次的状态改变都会调用一些delegate中的方法来响应当前的状态，让我们可以对程序进行特定操作。 willFinishLaunchingwillFinishLaunching：程序将要完成启动。只在程序启动时执行一次。launchOptions：存存储程序启动的原因。 (BOOL)application:(UIApplication *)application willFinishLaunchingWithOptions:(NSDictionary *)launchOptions { return YES; } didFinishLaunchingdidFinishLaunching：程序已经完成启动，将要显示界面了。只在程序启动时执行一次。launchOptions：存存储程序启动的原因。 didFinishLaunching是在app显示界面给用户之前最后执行的状态，理所当然我们可以在这个方法内完成一些基本的初始化，但是应该是轻量级的初始化操作，不然会导致程序启动时间长，影响用户体验。 举一些栗子： 不使用StoryBoard，需要配置window第三方登录sdk注册，以及很多第三方sdk的初始化配置判断程序接下来的业务逻辑，播不播放引导图片？播不播放开屏广告？有没有登录？但项目复杂了之后，需要配置的东西越来越多，所以didFinishLaunching非常容易耦合，这是我们应该要注意的。 (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions { //若用户直接启动，launchOptions内无数据。 //若由其他程序通过openURL:启动。 //launchOptions中UIApplicationLaunchOptionsURLKey的数据为openURL:的参数url。 //launchOptions中UIApplicationLaunchOptionsSourceApplicationKey的数据为启动本程序的源程序的bundle ID(NSString)。 NSURL *url = [launchOptions objectForKey:UIApplicationLaunchOptionsURLKey]; if (url) { [self launchOptionsWithURL:url]; } NSString *bundleId = [launchOptions objectForKey:UIApplicationLaunchOptionsSourceApplicationKey]; if (bundleId) { [self launchOptionsWithBundleId:bundleId]; } //若由远程通知启动。 //launchOptions中UIApplicationLaunchOptionsRemoteNotificationKey对应数据为启动本程序的远程通知信息useinfo(NSDictionary)。 NSDictionary *useinfo = [launchOptions objectForKey:UIApplicationLaunchOptionsRemoteNotificationKey]; if (useinfo) { [self launchOptionsWithUseinfo:useinfo]; } return YES;} DidBecomeActiveDidBecomeActive：程序已激活。程序在处于前台时调用：程序第一次启动时、从后台返回前台时。 若程序之前在后台，可以在这方法内重新拉取数据，刷新用户界面。 (void)applicationDidBecomeActive:(UIApplication *)application;WillResignActiveWillResignActive：程序将要进入未激活。程序在处于前台时调用：有电话打进来、手机锁屏等。程序被其他任务强制占用了，就会调用这个方法，所以这个方法也称为程序中断调用方法。 实际运用场景为： 对音频、视频、游戏的暂停操作暂停定时器减少OpenGL ES帧率暂停正在执行的任务，若有下载任务可以取消或暂停。 (void)applicationWillResignActive:(UIApplication *)application { } DidEnterBackgroundDidEnterBackground：程序已经进入后台。程序从前台进入后台时调用。 作用是： 释放共享资源保存用户数据（写到硬盘）作废计时器保存足够的程序状态以便下次恢复 (void)applicationDidEnterBackground:(UIApplication *)application { }2.6 WillEnterForegroundWillEnterForeground：程序将要进入前台。程序从后台进入前台时调用。 WillEnterForeground主要用于撤销WillResignActive中做的操作。 (void)applicationWillEnterForeground:(UIApplication *)application { } WillTerminate​​​​​​​WillTerminate：程序将要终止。程序终止之前调用。 目的就是为了保留一些重要的数据，方便下次启动后的恢复，达到一种让用户感觉该程序永远运行在后台从来没被终止过的感觉。 (void)applicationWillTerminate:(UIApplication *)application { [self saveContext]; 原文链接：https://blog.csdn.net/qq_36557133/article/details/86770301 Assets.xcassetsAssets.xcassets是用来存放图像资源文件的。将一个图片放在Assets里面是这个样子的 {% image http://res.zhangyongfa888.site/1590384969071l5a56ook.png?imageslim 'back' '' %} 当然还能放一些自定义的颜色使用方法： {% image http://res.zhangyongfa888.site/1590385230758e1imim8a.png?imageslim '颜色使用' '' %} LaunchScreen.storyboardLaunch screen interface file base name 这里只放了一个label 使用 Xcode storyboard(故事板) 来提供 app 的启动屏幕”的要求已延期到2020.6.30. main.m 主函数int main(int argc, char * argv[]) { NSString * appDelegateClassName; @autoreleasepool { // Setup code that might create autoreleased objects goes here. appDelegateClassName = NSStringFromClass([AppDelegate class]); } return UIApplicationMain(argc, argv, nil, appDelegateClassName); }main.storyboard (已删除)删除方法：https://www.jianshu.com/p/12faf6fd7388 PrefixHeader.pch（手动创建）创建方法：https://blog.csdn.net/lxmy2012/article/details/53976228PrefixHeader.pch 是一个预编译的文件，可以被项目中的其它文件访问到，一般用来存放常用的宏、常用的头文件、配置日期等。 study0518-Bridging-Header.hUse this file to import your target’s public headers that you would like to expose to Swift. swift混编的桥接头文件 podpodfile是一个规范文件，描述一个或多个项目目标依赖项，CocoaPods管理iOS组件库.https://www.jianshu.com/p/dfaf0954b76d 项目中只依赖了SnapKit（swift）https://www.jianshu.com/p/332b816cd3e4","categories":[{"name":"oc","slug":"oc","permalink":"http://zhangyongfa888.site/categories/oc/"}],"tags":[{"name":"ios","slug":"ios","permalink":"http://zhangyongfa888.site/tags/ios/"}],"author":"zhangyongfa"},{"title":"项目整理","slug":"项目整理","date":"2020-04-08T07:45:00.000Z","updated":"2020-04-08T09:18:04.207Z","comments":true,"path":"2020/04/08/项目整理/","link":"","permalink":"http://zhangyongfa888.site/2020/04/08/项目整理/","excerpt":"","text":"时间轴整理了一下做过/参与的部分项目。。 油联易卡 状态 惠储油，会生活！4G时代领先的油联易卡储油服务产品，只为精明的你！ 油联易卡点此链接由油联（北京）石油化工有限公司与海航云商控股有限公司联合发行，是适合在全国任意加油站，可用任意支付方式进行加油消费的创新型跨平台储油服务产品。【产品特点】油联易卡率先采用按“升”储油加油消费的模式，不仅可以通过储油优惠 + 加油优惠叠加的方式，为消费者带来更大的优惠；同时融合了先进的互联网、移动互联网、物联网产品解决方案，将储油、保值、通用、安全四大特点融为一体，是真正使消费者在自控油价，削减风险等方面得到长期利益的惠民型创新产品。【1＋N种选择使用油联易卡的理由】 储油功能根据购卡选择地区当日成品油零售价，按“升”购买存储成品油。 保值功能享受储油按升优惠后，锁定油价，不受价格波动影响。 优惠叠加享有储油优惠后，用户仍可享受其他商家给予的加油优惠（如：银行卡优惠、加油站优惠）。 交易安全先进的密钥与安全认证体系，保障用户的每一笔交易真实、安全、可靠。 服务便捷通过油联手机APP客户服务端，用户可随时对账户进行管理。 自得网 状态 自得网点此链接 是一家留学生社交+互助网络平台，2015年4月正式上线，用户对象是中国已出国留学和即将出国留学的精英群体，服务网络遍及全美，覆盖北京重点高校。 自得网上拥有两百多服务客栈，它们的主人是来自130多所美国大学的中国留学生。自得网的目标是让富有创造力、视野开阔的学子们发挥他们的真正价值，让那些需要帮助、备受信息不对称之苦的人，找到拉他们一把的小伙伴。自得，得与不得，全在自己。 啄木鸟教育 状态 啄木鸟点此链接国际教育专业美国留学咨询机构,专做美国留学,为数以千计的学子成功实现美国名校梦想。美国留学申请选择啄木鸟教育! 中美新闻网-侨报2.0 状态 摘自ChinaDaily 中美新闻网“该链接已失效”指向鲜明，定位清晰，关注点集中在世界两大经济体中国和美国，网站域名sino-us.com也充分展示了中美新闻网的定位和功能。 中美新闻网设置了聚焦中国、中美之间、老外在中国、外媒看中国、文化、生活等主要栏目，充分发挥格律媒体集团美国总部及北京代表处的资源优势，及时报道与中美两国相关联的政经要闻，以及中国在文化、经济、生活、旅游等方面的新闻和资讯。 中美新闻网的重点栏目“中美之间”，反映的是中美两国的政治关系和经济文化的互动和交流。“外媒看中国”集纳了英文主流媒体对中国的观感，从独特的视角解读中国。“老外在中国”则以在华的外国人和外企为采访对象，讲述外国人在中国的发展经历，见闻感受。 ————————-分割线————————— 货运宝产品货运宝，业务涵盖公路干线物流与同城货运。通过互联网科技，整合社会零散的运力资源与货运需求，使车-货-人得以快速链接。平台通过实名认证和透明化的信用评价体系，为用户提供一个可以安心交易的货运平台。生产制造、商贸等不同类型的企业，以及需要搬家、运货的组织和个人，都可以通过货运宝平台，快速找到附近合适的车辆/司机，通过议价（部分车型为定价制），获得合理价位的货运服务。广大货车司机朋友，借助货运宝平台，可以快速找到适合自身运力、路程的货源订单，极大的提升货车利用率，从而获得丰厚的承运报酬。货运宝，由河北智旦网络技术有限公司自主研发并运营。企业具备完善的管理制度，专业的技术和服务团队为用户提供优质的服务体验。产品业务从京津冀地区始发，目前已辐射全国100多个城市。 下载地址：http://www.zdhuoyunbao.com/download.html 货主端 状态 司机端 状态 企业端 船运版 状态 船东版 状态 物流版 状态 OA系统OA1.0 状态 OA2.0 状态 OA物业版本 状态 OA零售精英版 状态 OA X 状态 智旦OA是一款移动办公服务软件，功能十分齐全，有即时通讯、移动审批、手机考勤等功能，有了它，你就可以轻松办公，还可以提高工作效率，有需要的用户欢迎下载哦! 智旦OA介绍 智旦OA是河北智旦网络技术有限公司旗下一款移动办公软件， 能够帮助企业降低沟通、管理成本，提升企业办公效率，促进无纸化办公。 此应用适合需要使用移动办公的公司和个人用户，用户可通过此软件来管理客户， 完成行政审批申请等，管理人员也可通过此软件发布通告等。 智旦OA特点 办公邮件，随时响应 多种提醒方式，内部、外部邮件不再错过 即时通讯，安全沟通 同事之间提供微信级别聊天 移动审批，高效便捷 公文、报销、请假…快速审批 手机考勤，精准签到 WIFI、GPS锁定，告别打卡机 智慧办公，高效管理 提供多种移动OA功能，企业管理更高效 智部落商铺端 状态 骑手端 状态 客户端 状态 寺庙广德寺 状态 石室禅院 状态 商城智点点 状态 大茶肆大茶肆农业科技有限公司，是一家致力于茶行业标准化线上平台的创新型企业。 大茶肆旨在运用全新物联网经营理念，传承中国茶文化，通过智能物联网+众创+分享经济的方式，以传承，创新，专注，分享为核心，整合茶叶生产基地、茶叶加工基地、知名茶企茶匠、茶叶线下体验馆、茶职培训机构、茶叶农残质检等资源，集现代化农业与互联网科技为一体，做您身边的茶叶专家。 状态 测试系统消防考试系统 状态 逆向一点英语xp 状态","categories":[],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"SSM搭建（从入门到入门）","slug":"SSM搭建（从入门到入门）","date":"2020-03-04T07:59:00.000Z","updated":"2020-03-10T05:36:00.934Z","comments":true,"path":"2020/03/04/SSM搭建（从入门到入门）/","link":"","permalink":"http://zhangyongfa888.site/2020/03/04/SSM搭建（从入门到入门）/","excerpt":"","text":"ssm是个啥?二话不说直接搭建！工具IDEA: idea 数据库用的是MariaDb 当成MySql使就行 打开IDEA 新建项目 新建SPRING-MVC项目 这里选择的是springmvc，网上其他教程里直接是maven。主要是项生成下项目的目录结构。一步一步往下走。 添加maven支持 添加maven 添加后回自动生成目录java和resource paste image 在pom中添加所需的第三方包 主要是springmvc和mybatis的，当然还有其他常用库。 pom.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;groupId&lt;/groupId&gt; &lt;artifactId&gt;zyf888&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;!-- 全局属性配置 --&gt; &lt;properties&gt; &lt;!-- spring版本号 --&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;project.reporting.outputEncoding&gt;UTF-8&lt;/project.reporting.outputEncoding&gt; &lt;!-- spring版本号 --&gt; &lt;spring.version&gt;4.3.5.RELEASE&lt;/spring.version&gt; &lt;!-- mybatis版本号 --&gt; &lt;mybatis.version&gt;3.4.1&lt;/mybatis.version&gt; &lt;/properties&gt; &lt;build&gt; &lt;plugins&gt; &lt;plugin&gt; &lt;groupId&gt;org.mortbay.jetty&lt;/groupId&gt; &lt;artifactId&gt;maven-jetty-plugin&lt;/artifactId&gt; &lt;version&gt;6.1.7&lt;/version&gt; &lt;configuration&gt; &lt;connectors&gt; &lt;connector implementation=&quot;org.mortbay.jetty.nio.SelectChannelConnector&quot;&gt; &lt;port&gt;8888&lt;/port&gt; &lt;maxIdleTime&gt;30000&lt;/maxIdleTime&gt; &lt;/connector&gt; &lt;/connectors&gt; &lt;webAppSourceDirectory&gt;${project.build.directory}/${pom.artifactId}-${pom.version} &lt;/webAppSourceDirectory&gt; &lt;contextPath&gt;/&lt;/contextPath&gt; &lt;/configuration&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; &lt;!-- 依赖从这开始 &lt;dependencies&gt;是所有依赖包的父级标签 其中每添加一个依赖包，就加一个&lt;dependency&gt;标签 这里已经默认添加了一个测试包，我们需要把所有用到的依赖全部进来 (用到每个包的依赖信息需要自己找，下面是这个demo需要的依赖包) --&gt; &lt;!--项目依赖 --&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.codehaus.jackson&lt;/groupId&gt; &lt;artifactId&gt;jackson-mapper-asl&lt;/artifactId&gt; &lt;version&gt;1.9.13&lt;/version&gt; &lt;/dependency&gt; &lt;!-- java ee --&gt; &lt;dependency&gt; &lt;groupId&gt;javax&lt;/groupId&gt; &lt;artifactId&gt;javaee-api&lt;/artifactId&gt; &lt;version&gt;7.0&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 单元测试 --&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 实现slf4j接口并整合 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- JSON --&gt; &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.41&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MyBatis --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;${mybatis.version}&lt;/version&gt; &lt;/dependency&gt; &lt;!-- mybatis/spring整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- Spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-beans&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;${spring.version}&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.google.code.gson&lt;/groupId&gt; &lt;artifactId&gt;gson&lt;/artifactId&gt; &lt;version&gt;2.8.2&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt;配置web.xml以及springweb.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns=&quot;http://java.sun.com/xml/ns/javaee&quot; xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd&quot; version=&quot;3.0&quot;&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!-- Spring和mybatis的配置文件 --&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mybatis.xml&lt;/param-value&gt; &lt;/context-param&gt; &lt;!-- 编码过滤器 --&gt; &lt;filter&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;encodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!-- Spring监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.context.ContextLoaderListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- 防止Spring内存溢出监听器 --&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.IntrospectorCleanupListener&lt;/listener-class&gt; &lt;/listener&gt; &lt;!-- Spring MVC servlet --&gt; &lt;servlet&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:spring-mvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;SpringMVC&lt;/servlet-name&gt; &lt;!-- 此处可以可以配置成*.do，对应struts的后缀习惯 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;welcome-file-list&gt; &lt;welcome-file&gt;/index.html&lt;/welcome-file&gt; &lt;welcome-file&gt;/index.jsp&lt;/welcome-file&gt; &lt;/welcome-file-list&gt; &lt;/web-app&gt; 当前目录结构 spring-mvc &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-4.0.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-4.0.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!--避免IE执行AJAX时，返回JSON出现下载文件 --&gt; &lt;bean id=&quot;mappingJacksonHttpMessageConverter&quot; class=&quot;org.springframework.http.converter.json.MappingJackson2HttpMessageConverter&quot;&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html;charset=UTF-8&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 启动SpringMVC的注解功能，完成请求和注解model的映射 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.mvc.annotation.AnnotationMethodHandlerAdapter&quot;&gt; &lt;property name=&quot;messageConverters&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;mappingJacksonHttpMessageConverter&quot;/&gt; &lt;!-- JSON转换器 --&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!-- 对静态资源的访问 --&gt; &lt;!-- &lt;mvc:resources mapping=&quot;/js/**&quot; location=&quot;/js/&quot; /&gt; &lt;mvc:resources mapping=&quot;/css/**&quot; location=&quot;/css/&quot; /&gt; --&gt; &lt;!-- 自动扫描该包，使SpringMVC认为包下用了@controller注解的类是控制器 --&gt; &lt;context:component-scan base-package=&quot;com.zyf888.controller&quot;/&gt; &lt;!-- 添加注解驱动 --&gt; &lt;mvc:annotation-driven enable-matrix-variables=&quot;true&quot;&gt; &lt;mvc:message-converters&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;constructor-arg value=&quot;UTF-8&quot;/&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; &lt;!-- 允许对静态资源文件的访问 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 定义跳转的文件的前后缀 ，视图模式配置 --&gt; &lt;bean class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 这里的配置我的理解是自动给后面action的方法return的字符串加上前缀和后缀，变成一个 可用的url地址 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/view/&quot;/&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; spring-mybatis.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.zyf888&quot; /&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.zyf888&quot; /&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.zyf888.model&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;!--&lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapping/*.xml&quot;/&gt;--&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.zyf888.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; &lt;/beans&gt; jdbc.properties &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.1.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context-3.1.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc-4.0.xsd&quot;&gt; &lt;!-- 自动扫描 --&gt; &lt;context:component-scan base-package=&quot;com.duoduo&quot; /&gt; &lt;!-- 配置数据库相关参数properties的属性：${url} --&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!-- 数据库连接池 --&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt; &lt;property name=&quot;driverClass&quot; value=&quot;${jdbc.driver}&quot;/&gt; &lt;property name=&quot;jdbcUrl&quot; value=&quot;${jdbc.url}&quot;/&gt; &lt;property name=&quot;user&quot; value=&quot;${jdbc.username}&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;${jdbc.password}&quot;/&gt; &lt;property name=&quot;maxPoolSize&quot; value=&quot;${c3p0.maxPoolSize}&quot;/&gt; &lt;property name=&quot;minPoolSize&quot; value=&quot;${c3p0.minPoolSize}&quot;/&gt; &lt;property name=&quot;autoCommitOnClose&quot; value=&quot;${c3p0.autoCommitOnClose}&quot;/&gt; &lt;property name=&quot;checkoutTimeout&quot; value=&quot;${c3p0.checkoutTimeout}&quot;/&gt; &lt;property name=&quot;acquireRetryAttempts&quot; value=&quot;${c3p0.acquireRetryAttempts}&quot;/&gt; &lt;/bean&gt; &lt;!-- 配置SqlSessionFactory对象 --&gt; &lt;bean id=&quot;sqlSessionFactory&quot; class=&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt; &lt;!-- 注入数据库连接池 --&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;!-- 扫描model包 使用别名 --&gt; &lt;property name=&quot;typeAliasesPackage&quot; value=&quot;com.duoduo.model&quot;/&gt; &lt;!-- 扫描sql配置文件:mapper需要的xml文件 --&gt; &lt;property name=&quot;mapperLocations&quot; value=&quot;classpath:mapping/*.xml&quot;/&gt; &lt;/bean&gt; &lt;!-- DAO接口所在包名，Spring会自动查找其下的类 --&gt; &lt;bean class=&quot;org.mybatis.spring.mapper.MapperScannerConfigurer&quot;&gt; &lt;property name=&quot;basePackage&quot; value=&quot;com.duoduo.dao&quot; /&gt; &lt;property name=&quot;sqlSessionFactoryBeanName&quot; value=&quot;sqlSessionFactory&quot;/&gt; &lt;/bean&gt; &lt;!-- (事务管理)transaction manager, use JtaTransactionManager for global tx --&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot; /&gt; &lt;/bean&gt; 测试连接@Controller @RequestMapping(&quot;/&quot;) public class UserController { @RequestMapping(value = &quot;/a&quot;) @ResponseBody public String allUser() { return new Gson().toJson(&quot;alllll&quot;); } } 连接好了 遇到了一个打包上传的问题，java.lang.ClassNotFoundException: org.springframework.web.util.IntrospectorCleanupListener已经解决。需要这样操作 paste image 数据库操作接口操作 userDao 调用方法 @Resource private UserDao userDao; @RequestMapping(value = &quot;/&quot;) @ResponseBody public String allUser() { return new Gson().toJson(userDao.getAllUser()); }http://localhost:8080/add?sex=%E7%94%B7&amp;mobile=18823123123&amp;name=%E5%BC%A0%E4%B8%89&amp;age=12 paste image 其中中文可能会有编码文字。设置数据库编码货主spring编码问题不作累述。 后记后台好难啊","categories":[{"name":"SSM","slug":"SSM","permalink":"http://zhangyongfa888.site/categories/SSM/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"http://zhangyongfa888.site/tags/JAVA/"}],"author":"zhangyongfa"},{"title":"MD插入音频视频","slug":"MD插入音频视频","date":"2020-01-19T06:10:00.000Z","updated":"2020-03-04T07:55:16.872Z","comments":true,"path":"2020/01/19/MD插入音频视频/","link":"","permalink":"http://zhangyongfa888.site/2020/01/19/MD插入音频视频/","excerpt":"","text":"插入音频&lt;audio id=&quot;audio&quot; controls=&quot;&quot; preload=&quot;none&quot;&gt; &lt;source id=&quot;mp3&quot;src=&quot;https://sz-sycdn.kuwo.cn/4591311c3897b5be364a4a61fa5c0ee0/5e23f572/resource/n2/83/56/3583003746.mp3&quot;&gt; &lt;/audio&gt; 插入视频&lt;video id=&quot;video&quot; controls=&quot;&quot; preload=&quot;none&quot; poster=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.jpg&quot;&gt; &lt;source id=&quot;mp4&quot; src=&quot;http://img.blog.fandong.me/2017-08-26-Markdown-Advance-Video.mp4&quot; type=&quot;video/mp4&quot;&gt; &lt;/video&gt;","categories":[{"name":"插入音视频","slug":"插入音视频","permalink":"http://zhangyongfa888.site/categories/插入音视频/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://zhangyongfa888.site/tags/MarkDown/"}],"author":"zhangyongfa"},{"title":"一个简单的进度条实现","slug":"一个简单的进度条实现","date":"2020-01-19T05:23:00.000Z","updated":"2020-03-10T05:29:55.397Z","comments":true,"path":"2020/01/19/一个简单的进度条实现/","link":"","permalink":"http://zhangyongfa888.site/2020/01/19/一个简单的进度条实现/","excerpt":"","text":"动画基本分类Android动画可以分为帧动画、补间动画和属性动画。 动画分类 视图动画（补间动画、帧动画）补间动画通多对整个视图不断做图像的变换（平移、缩放、旋转、透明度）产生的动画效果，是一种渐进式动画。 逐帧动画，是通过一个接一个的加载Drawable资源来创建动画，按顺序的播放，像一个胶卷。对于视图动画，他只是单独的图片内容在变换，而不是整个视图。很显然，如果图片过多多大就会导致OOM异常。 视图动画的作用对象只能是View，在同一个图形通过在界面上进行透明度,缩放,旋转,平移的变化。 根据动画效果，补间动画分为以下4类： 透明度动画（alpha） 缩放动画（scale） 平移动画（Translate） 旋转动画（rotate） 动画关系 补间动画XML中的使用spaceshipImage.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:interpolator=&quot;@[package:]anim/interpolator_resource&quot; android:shareInterpolator=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;alpha android:fromAlpha=&quot;float&quot; android:toAlpha=&quot;float&quot; /&gt; &lt;scale android:fromXScale=&quot;float&quot; android:toXScale=&quot;float&quot; android:fromYScale=&quot;float&quot; android:toYScale=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot; /&gt; &lt;translate android:fromXDelta=&quot;float&quot; android:toXDelta=&quot;float&quot; android:fromYDelta=&quot;float&quot; android:toYDelta=&quot;float&quot; /&gt; &lt;rotate android:fromDegrees=&quot;float&quot; android:toDegrees=&quot;float&quot; android:pivotX=&quot;float&quot; android:pivotY=&quot;float&quot; /&gt; &lt;set&gt; ... &lt;/set&gt; &lt;/set&gt;创建动画ImageView spaceshipImage = (ImageView) findViewById(R.id.spaceshipImage); Animation myAnimation= AnimationUtils.loadAnimation(this, R.anim.filename); spaceshipImage.startAnimation(myAnimation);JAVA中的使用ImageView imageView = findViewById(R.id.image_view); // 创建 需要设置动画的 视图View // 组合动画设置 AnimationSet setAnimation = new AnimationSet(true); // 创建组合动画对象(设置为true) // 设置组合动画的属性 setAnimation.setRepeatMode(Animation.RESTART); ... // 逐个创建子动画,不作过多描述 // 子动画1:透明度动画 Animation alpha = new AlphaAnimation(1,0); alpha.setDuration(3000); ... // 子动画2:缩放动画 Animation scale1 = new ScaleAnimation(1,0.5f,1,0.5f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); scale1.setDuration(1000); ... // 子动画3:平移动画 Animation translate = new TranslateAnimation(TranslateAnimation.RELATIVE_TO_PARENT,-0.5f, TranslateAnimation.RELATIVE_TO_PARENT,0.5f, TranslateAnimation.RELATIVE_TO_SELF,0 ,TranslateAnimation.RELATIVE_TO_SELF,0); translate.setDuration(10000); ... // 子动画4:旋转动画 Animation rotate = new RotateAnimation(0,360,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF,0.5f); rotate.setDuration(1000); rotate.setRepeatMode(Animation.RESTART); rotate.setRepeatCount(Animation.INFINITE); ... // 将创建的子动画添加到组合动画里 setAnimation.addAnimation(alpha); setAnimation.addAnimation(rotate); setAnimation.addAnimation(translate); setAnimation.addAnimation(scale1); imageView.startAnimation(setAnimation); // 播放动画插值器Interpolator插值器是在XML中定义的一个动画修改器，它影响动画的变化率。这允许现有动画附加加速、减速、重复、反弹等效果。 插值器 &lt;set android:interpolator=&quot;@android:anim/accelerate_interpolator&quot;&gt; ... &lt;/set&gt; Animation alphaAnimation = new AlphaAnimation(1,0); alphaAnimation.setDuration(3000); //创建插值器对象 Interpolator interpolator = new OvershootInterpolator(); //为动画添加插值器 alphaAnimation.setInterpolator(interpolator); imageView.startAnimation(alphaAnimation); 插值器 更多参考 Android动画之Interpolator(插值器) 帧动画 帧动画继承关系 XML使用rocket_thrust &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt; &lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; android:oneshot=[&quot;true&quot; | &quot;false&quot;] &gt; &lt;item android:drawable=&quot;@[package:]drawable/drawable_resource_name&quot; android:duration=&quot;integer&quot; /&gt; //如下 &lt;item android:drawable=&quot;@drawable/wheel0&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel1&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel2&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel3&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel4&quot; android:duration=&quot;50&quot; /&gt; &lt;item android:drawable=&quot;@drawable/wheel5&quot; android:duration=&quot;50&quot; /&gt; &lt;/animation-list&gt; ImageView rocketImage = (ImageView) findViewById(R.id.rocket_image); rocketImage.setBackgroundResource(R.drawable.rocket_thrust); rocketAnimation = (AnimationDrawable) rocketImage.getBackground(); rocketAnimation.start();JAVA方式&lt;-- 直接从drawable文件夹获取动画资源（图片） --&gt; animationDrawable = new AnimationDrawable(); for (int i = 0; i &lt;= 25; i++) { int id = getResources().getIdentifier(&quot;a&quot; + i, &quot;drawable&quot;, getPackageName()); Drawable drawable = getResources().getDrawable(id); animationDrawable.addFrame(drawable, 100); } &lt;-- 开始动画 --&gt; btn_startFrame.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { animationDrawable.setOneShot(true); iv.setImageDrawable(animationDrawable); // 获取资源对象 animationDrawable.stop(); // 特别注意：在动画start()之前要先stop()，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次 animationDrawable.start(); // 启动动画 } }); &lt;-- 停止动画 --&gt; btn_stopFrame.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { animationDrawable.setOneShot(true); iv.setImageDrawable(animationDrawable); animationDrawable.stop(); } });属性动画属性动画，在Android 3.0的（API级别11）引入的，该属性动画系统可以制作动画的任何对象的属性。但是一般来说，属性动画系统是首选的使用方法，因为它更灵活，并提供更多功能。 具体使用ObjectAnimator 我们通过控制传入 ofFloat()的第二个参数preperty 或者 XML中的android:propertyName属性 来产生不同动画效果，以下为Android预置好的一些属性：即四种基本变换，透明度、平移、缩放、旋转 属性 作用 数值类型 alpha 透明度 float translationX X方向的位移 float translationY Y方向的位移 float scaleX X方向的缩放倍数 float scaleY Y方向的缩放倍数 float rotation 以屏幕方向为轴的旋转度数 float rotationX 以X轴为轴的旋转度数 float rotationY 以Y轴为轴的旋转度数 float 以上大部分来自作者：whd_Alive链接：https://www.jianshu.com/p/a480ca619dd9 进度条动画的创建先创建几个imageView 填充背景 paste image paste image 然后在代码中添加属性动画 postDelayed(new Runnable() { @Override public void run() { ObjectAnimator objectAnimatorX = ObjectAnimator.ofFloat(imageViews[position], &quot;scaleX&quot;, 1.2f, ratio[position]); objectAnimatorX.setDuration(600); objectAnimatorX.setInterpolator(new OvershootInterpolator()); objectAnimatorX.setRepeatMode(ValueAnimator.REVERSE); objectAnimatorX.setRepeatCount(ValueAnimator.INFINITE); objectAnimatorX.start(); ObjectAnimator objectAnimatorY = ObjectAnimator.ofFloat(imageViews[position], &quot;scaleY&quot;, 1.2f, ratio[position]); objectAnimatorY.setRepeatCount(ValueAnimator.INFINITE); objectAnimatorY.setDuration(600); objectAnimatorY.setInterpolator(new OvershootInterpolator()); objectAnimatorY.setRepeatMode(ValueAnimator.REVERSE); objectAnimatorY.start(); ObjectAnimator alpha = ObjectAnimator.ofFloat(imageViews[position], &quot;alpha&quot;, alphaMax, alphaMin); alpha.setRepeatCount(ValueAnimator.INFINITE); alpha.setDuration(600); alpha.setRepeatMode(ValueAnimator.REVERSE); alpha.setInterpolator(new DecelerateInterpolator()); alpha.start(); } }, (position + 1) * 90);效果图就出来了……but传不了动图。。 动图来了","categories":[{"name":"动画","slug":"动画","permalink":"http://zhangyongfa888.site/categories/动画/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"小程序云函数初体验","slug":"小程序云函数初体验","date":"2019-12-23T08:51:00.000Z","updated":"2020-03-10T05:53:48.759Z","comments":true,"path":"2019/12/23/小程序云函数初体验/","link":"","permalink":"http://zhangyongfa888.site/2019/12/23/小程序云函数初体验/","excerpt":"","text":"无服务器（Serverless）计算是什么 paste image 云计算涌现出很多改变传统IT架构和运维方式的新技术，比如虚拟机、容器、微服务，无论这些技术应用在哪些场景，降低成本、提升效率是云服务永恒的主题。 过去十年来，我们已经把应用和环境中很多通用的部分变成了服务。Serverless的出现，带来了跨越式变革。Serverless把主机管理、操作系统管理、资源分配、扩容，甚至是应用逻辑的全部组件都外包出去，把它们看作某种形式的商品——厂商提供服务，我们掏钱购买。 过去是“构建一个框架运行在一台服务器上，对多个事件进行响应”，Serverless则变为“构建或使用一个微服务或微功能来响应一个事件”，做到当访问时，调入相关资源开始运行，运行完成后，卸载所有开销，真正做到按需按次计费。这是云计算向纵深发展的一种自然而然的过程。 Serverless是一种构建和管理基于微服务架构的完整流程，允许你在服务部署级别而不是服务器部署级别来管理你的应用部署。它与传统架构的不同之处在于，完全由第三方管理，由事件触发，存在于无状态（Stateless）、暂存（可能只存在于一次调用的过程中）计算容器内。构建无服务器应用程序意味着开发者可以专注在产品代码上，而无须管理和操作云端或本地的服务器或运行时。Serverless真正做到了部署应用无需涉及基础设施的建设，自动构建、部署和启动服务。 国内外的各大云厂商 Amazon、微软、Google、IBM、阿里云、腾讯云、华为云相继推出Serverless产品，Serverless也从概念、愿景逐步走向落地，在各企业、公司应用开来。 理解Serverless技术—FaaS和BaaSServerless由开发者实现的服务端逻辑运行在无状态的计算容器中，它由事件触发， 完全被第三方管理，其业务层面的状态则被开发者使用的数据库和存储资源所记录。Serverless涵盖了很多技术，分为两类：FaaS和BaaS。 FaaS（Function as a Service，函数即服务）FaaS意在无须自行管理服务器系统或自己的服务器应用程序，即可直接运行后端代码。其中所指的服务器应用程序，是该技术与容器和PaaS（平台即服务）等其他现代化架构最大的差异。 FaaS可以取代一些服务处理服务器（可能是物理计算机，但绝对需要运行某种应用程序），这样不仅不需要自行供应服务器，也不需要全时运行应用程序。 FaaS产品不要求必须使用特定框架或库进行开发。在语言和环境方面，FaaS函数就是常规的应用程序。例如AWS Lambda的函数可以通过Javascript、Python以及任何JVM语言（Java、Clojure、Scala）等实现。然而Lambda函数也可以执行任何捆绑有所需部署构件的进程，因此可以使用任何语言，只要能编译为Unix进程即可。FaaS函数在架构方面确实存在一定的局限，尤其是在状态和执行时间方面。 在迁往FaaS的过程中，唯一需要修改的代码是“主方法/启动”代码，其中可能需要删除顶级消息处理程序的相关代码（“消息监听器接口”的实现），但这可能只需要更改方法签名即可。在FaaS的世界中，代码的其余所有部分（例如向数据库执行写入的代码）无须任何变化。 相比传统系统，部署方法会有较大变化 – 将代码上传至FaaS供应商，其他事情均可由供应商完成。目前这种方式通常意味着需要上传代码的全新定义（例如上传zip或JAR文件），随后调用一个专有API发起更新过程。 FaaS中的函数可以通过供应商定义的事件类型触发。对于亚马逊AWS，此类触发事件可以包括S3（文件）更新、时间（计划任务），以及加入消息总线的消息（例如Kinesis）。通常你的函数需要通过参数指定自己需要绑定到的事件源。 大部分供应商还允许函数作为对传入Http请求的响应来触发，通常这类请求来自某种该类型的API网关（例如AWS API网关、Webtask）。 BaaS（Backend as a Service，后端即服务）BaaS（Backend as a Service，后端即服务）是指我们不再编写或管理所有服务端组件，可以使用领域通用的远程组件（而不是进程内的库）来提供服务。理解BaaS，需要搞清楚它与PaaS的区别。 首先BaaS并非PaaS，它们的区别在于：PaaS需要参与应用的生命周期管理，BaaS则仅仅提供应用依赖的第三方服务。典型的PaaS平台需要提供手段让开发者部署和配置应用，例如自动将应用部署到Tomcat容器中，并管理应用的生命周期。BaaS不包含这些内容，BaaS只以API的方式提供应用依赖的后端服务，例如数据库和对象存储。BaaS可以是公共云服务商提供的，也可以是第三方厂商提供的。其次从功能上讲，BaaS可以看作PaaS的一个子集，即提供第三方依赖组件的部分。 BaaS服务还允许我们依赖其他人已经实现的应用逻辑。对于这点，认证就是一个很好的例子。很多应用都要自己编写实现注册、登录、密码管理等逻辑的代码，而对于不同的应用这些代码往往大同小异。完全可以把这些重复性的工作提取出来，再做成外部服务，而这正是Auth0和Amazon Cognito等产品的目标。它们能实现全面的认证和用户管理，开发团队再也不用自己编写或者管理实现这些功能的代码。 无服务器（Serverless）计算如何工作？与使用虚拟机或一些底层的技术来部署和管理应用程序相比，无服务器计算提供了一种更高级别的抽象。因为它们有不同的抽象和“触发器”的集合。 拿计算来讲，这种抽象有一个特定函数和抽象的触发器，它通常是一个事件。以数据库为例，这种抽象也许是一个表，而触发器相当于表的查询或搜索，或者通过在表中做一些事情而生成的事件。 比如一款手机游戏，允许用户在不同的平台上为全球顶级玩家使用高分数表。当请求此信息时，请求从应用程序到API接口。API接口或许会触发AWS的Lambda函数，或者无服务器函数，这些函数再从数据库表中获取到数据流，返回包含前五名分数的一定格式的数据。 一旦构建完成，应用程序的功能就可以在基于移动和基于 Web 的游戏版本中重用。 这跟设置服务器不同，不是必须要有Amazon EC2实例或服务器，然后等待请求。环境由事件触发，而响应事件所需的逻辑只在响应时执行。这意味着，运行函数的资源只有在函数运行时被创建，产生一种非常高效的方法来构建应用程序。 无服务器（Serverless）适用于哪些场景？serverless在现阶段，Serverless主要应用在以下几个场景。首先在Web及移动端服务中，可以整合API网关和Serverles服务构建Web及移动后端，帮助开发者构建可弹性扩展、高可用的移动或 Web后端应用服务。在IoT场景下可高效的处理实时流数据，由设备产生海量的实时信息流数据，通过Serverles服务分类处理并写入后端处理。另外在实时媒体资讯内容处理场景里，用户上传的音视频到对象存储OBS，通过上传事件触发多个函数，分别完成高清转码、音频转码等功能，满足用户对实时性和并发能力的高要求。无服务器计算还适合于任何事件驱动的各种不同的用例，这包括物联网，移动应用，基于网络的应用程序和聊天机器人等。这里简单说两个场景，方便大家思考。 场景一：应用负载有显著的波峰波谷Serverless 应用成功与否的评判标准并不是公司规模的大小，而是其业务背后的具体技术问题，比如业务波峰波谷明显，如何实现削峰填谷。一个公司的业务负载具有波峰波谷时，机器资源要按照峰值需求预估；而在波谷时期机器利用率则明显下降，因为不能进行资源复用而导致浪费。 业界普遍共识是，当自有机器的利用率小于 30%，使用 Serverless 后会有显著的效率提升。对于云服务厂商，在具备了足够多的用户之后，各种波峰波谷叠加后平稳化，聚合之后资源复用性更高。比如，外卖企业负载高峰是在用餐时期，安防行业的负载高峰则是夜间，这是受各个企业业务定位所限的；而对于一个成熟的云服务厂商，如果其平台足够大，用户足够多，是不应该有明显的波峰波谷现象的。 场景二：典型用例 - 基于事件的数据处理视频处理的后端系统，常见功能需求如下：视频转码、抽取数据、人脸识别等，这些均为通用计算任务，可由函数计算执行。 开发者需要自己写出实现逻辑，再将任务按照控制流连接起来，每个任务的具体执行由云厂商来负责。如此，开发变得更便捷，并且构建的系统天然高可用、实时弹性伸缩，用户不需要关心机器层面问题。 Serverless 的问题对于企业来说，支持Serverless计算的平台可以节省大量时间和成本，同时可以释放员工，让开发者得以开展更有价值的工作，而不是管理基础设施。另一方面可以提高敏捷度，更快速地推出新应用和新服务，进而提高客户满意度。但是Serverless不是完美的，它也存在一些问题，需要慎重应用在生产环境。 不适合长时间运行应用Serverless 在请求到来时才运行。这意味着，当应用不运行的时候就会进入 “休眠状态”，下次当请求来临时，应用将会需要一个启动时间，即冷启动时间。如果你的应用需要一直长期不间断的运行、处理大量的请求，那么你可能就不适合采用 Serverless 架构。如果你通过 CRON 的方式或者 CloudWatch 来定期唤醒应用，又会比较消耗资源。这就需要我们对它做优化，如果频繁调用，这个资源将会常驻内存，第一次冷启之后，就可以一直服务，直到一段时间内没有新的调用请求进来，则会转入“休眠”状态，甚至被回收，从而不消耗任何资源。 完全依赖于第三方服务当你所在的企业云环境已经有大量的基础设施的时候，Serverless 对于你来说，并不是一个好东西。当我们采用某云服务厂商的 Serverless 架构时，我们就和该服务供应商绑定了，那么我们再将服务迁到别的云服务商上就没有那么容易了。 我们需要修改一下系列的底层代码，能采取的应对方案，便是建立隔离层。这意味着，在设计应用的时候，就需要隔离 API 网关、隔离数据库层，考虑到市面上还没有成熟的 ORM 工具，让你既支持Firebase，又支持 DynamoDB等等。这些也将带给我们一些额外的成本，可能带来的问题会比解决的问题多。 缺乏调试和开发工具当我使用 Serverless Framework 的时候，遇到了这样的问题：缺乏调试和开发工具。后来，我发现了 serverless-offline、dynamodb-local 等一系列插件之后，问题有一些改善。然而，对于日志系统来说，这仍然是一个艰巨的挑战。 每次你调试的时候，你需要一遍又一遍地上传代码。而每次上传的时候，你就好像是在部署服务器，并不能总是快速地定位出问题在哪。后来，找了一个类似于 log4j 这样的可以分级别记录日志的 Node.js 库 winston。它可以支持 error、warn、info、verbose、debug、silly 六个不同级别的日志，再结合大数据进行日志分析过滤，才能快速定位问题。 构建复杂Serverless 很便宜，但是这并不意味着它很简单。AWS Lambda的 CloudFormation配置是如此的复杂，并且难以阅读及编写（JSON 格式），虽然CloudFomation提供了Template模板，但想要使用它的话，需要创建一个Stack，在Stack中指定你要使用的Template,然后aws才会按照Template中的定义来创建及初始化资源。 而Serverless Framework的配置更加简单，采用的是 YAML 格式。在部署的时候，Serverless Framework 会根据我们的配置生成 CloudFormation 配置。然而这也并非是一个真正用于生产的配置,真实的应用场景远远比这复杂。 总结云计算经过这么多年的发展，逐渐进化到用户仅需关注业务和所需的资源。比如，通过K8S这类编排工具，用户只要关注自己的计算和需要的资源（CPU、内存等）就行了，不需要操心到机器这一层。 Serverless架构让人们不再操心运行所需的资源，只需关注自己的业务逻辑，并且为实际消耗的资源付费。可以说，随着Serverless架构的兴起，真正的云计算时代才算到来了。 任何新概念新技术的落地，本质上都是要和具体业务去结合，去真正解决具体问题。虽然Serverless很多地方不成熟，亟待完善。不过Serverless自身的优越特性，对于开发者来说，吸引力是巨大的。相信随着技术的飞速发展，Serverless在未来还有无限可能！ 以上转自https://blog.csdn.net/cc18868876837/article/details/90672971 实践目前接触到的云函数有 小程序 云函数、leanClound 、Google Cloud Function等。 小程序云函数新建小程序 勾选云函数选项，即可使用。 新建 右键新建函数比如getAllRecord。新建后，在云开发中的数据库中新建表后才能获取到。然后编写代码，比如获取所有数据 // 先取出集合记录总数 const countResult = await db.collection(&apos;recordlist&apos;).count() const total = countResult.total // 计算需分几次取 const batchTimes = Math.ceil(total / 100) // 承载所有读操作的 promise 的数组 const tasks = [] for (let i = 0; i &lt; batchTimes; i++) { const promise = db.collection(&apos;recordlist&apos;).skip(i * MAX_LIMIT).limit(MAX_LIMIT).get() tasks.push(promise) } // 等待所有 return (await Promise.all(tasks)).reduce((acc, cur) =&gt; { return { data: acc.data.concat(cur.data), errMsg: acc.errMsg } })添加记录 db.collection(&quot;recordlist&quot;).add({ data: { &quot;money&quot;: event.money, &quot;title&quot;: event.title }, }).then( res =&gt; { return res; } ) 小程序调用添加一条记录 wx.cloud.callFunction({ name: &apos;getAllRecord&apos;, data: { &quot;method&quot;: &quot;add&quot;, &quot;title&quot;: that.data.array[that.data.index], &quot;money&quot;: that.data.inputStr }, success: res =&gt; { console.log(&apos;[云函数] [addOne] res &apos;, res) that.getData(that); that.setData({ hiddenAddModal: true }) }, fail: err =&gt; { console.error(&apos;[云函数] [addOne] 调用失败&apos;, err) } }) 小程序获取所有记录 wx.cloud.callFunction({ name: &apos;getAllRecord&apos;, data: { &quot;method&quot;: &quot;all&quot; }, success: res =&gt; { console.log(&apos;[云函数] [getAllRecord] res &apos;, res) that.setData({ moneyList: res.result.data }) }, fail: err =&gt; { console.error(&apos;[云函数] [getAllRecord] 调用失败&apos;, err) } })leanClound云函数leanClound接触比较早的但是从来没有用过的。至少，本博客接入的评论valine使用的是leanClound的服务。 云数据库中的数据 谷歌云函数Google Cloud Functions 是一款基于事件的轻量级异步计算解决方案，可帮助您构建单一用途的小函数，用于在无需管理服务器或运行时环境的情况下就能对云端事件做出响应。 现在注册 免费获得 $300 赠金 注册即可获得 $300 赠金，未来 12 个月内可在 Google Cloud Platform 上随心使用。谷歌脚本服务谷歌云函数由于墙的原因，国内很少用。谷歌脚本服务在TG上实现： function preparePayload(body) { var payload; if (body.message.text) { //接收到文本 var restText = body.message.text; if (restText.indexOf(&quot;名字&quot;) &gt;= 0) { restText = &quot;我叫多多~&quot;; } //消息体 payload = { &quot;method&quot;: &quot;sendMessage&quot;, &quot;chat_id&quot;: body.message.chat.id, &quot;text&quot;: restText, } } else if (body.message.sticker) { //接收到表情 直接返回表情 payload = { &quot;method&quot;: &quot;sendSticker&quot;, &quot;chat_id&quot;: body.message.chat.id, &quot;sticker&quot;: body.message.sticker.file_id } } else if (body.message.photo) { //接收到图片，直接返回图片 array = body.message.photo; text = array[1]; payload = { &quot;method&quot;: &quot;sendPhoto&quot;, &quot;chat_id&quot;: body.message.chat.id, &quot;photo&quot;: text.file_id } } else { payload = { &quot;method&quot;: &quot;sendMessage&quot;, &quot;chat_id&quot;: body.message.chat.id, &quot;text&quot;: &quot; 对不起，无法识别内容！！&quot; } } return payload } 多多机器人 这里自动回复的是输入什么回复什么，匹配到关键字后回复指定字符或者媒体资源。","categories":[{"name":"Serverless","slug":"Serverless","permalink":"http://zhangyongfa888.site/categories/Serverless/"},{"name":"Telegram","slug":"Serverless/Telegram","permalink":"http://zhangyongfa888.site/categories/Serverless/Telegram/"}],"tags":[{"name":"小程序","slug":"小程序","permalink":"http://zhangyongfa888.site/tags/小程序/"}],"author":"zhangyongfa"},{"title":"对一点英语进行破解（xp模块）","slug":"对一点英语进行破解（xp模块）","date":"2019-12-20T08:13:00.000Z","updated":"2020-03-04T07:56:47.195Z","comments":true,"path":"2019/12/20/对一点英语进行破解（xp模块）/","link":"","permalink":"http://zhangyongfa888.site/2019/12/20/对一点英语进行破解（xp模块）/","excerpt":"","text":"背景某同事要学应用，拿出来几个app让给破解了…… 趁着闲工夫，简单“破解”了一下。 代码private void hookYidian(final XC_LoadPackage.LoadPackageParam lpparam) { if (!lpparam.processName.equals(&quot;com.wumii.android.athena&quot;)) { return; } //因为使用的360加固，要拿到360的context，所以在360加固的StubApp中获取。 XposedHelpers.findAndHookMethod(&quot;com.stub.StubApp&quot;, lpparam.classLoader, &quot;attachBaseContext&quot;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); final Context context = (Context) param.args[0]; final ClassLoader cl = context.getClassLoader(); XposedBridge.log(&quot;hookYidian &quot; + cl.getClass().getName()); //第一个破解需求：几次发音后，不能发音了，而且分数被模糊了，求破解 //解决办法：拿到这个类SpeakScoreView 在检查是不是vip时候，强制返回是vip 这里的意思应该是 “是不是需要vip权限” =&gt;false XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.ui.widget.SpeakScoreView&quot;, cl, &quot;setCheckVip&quot;, boolean.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); param.args[0] = false; XposedBridge.log(&quot;hookYidian beforeHookedMethod setCheckVip &quot; + param.args[0]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;hookYidian afterHookedMethod setCheckVip &quot; + param.args[0]); } }); //上一步发现 最后一次发音后，分数的视图被模糊 在这里直接返回 不模糊 测试生效~ XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.ui.widget.SpeakScoreView&quot;, cl, &quot;setBlur&quot;, boolean.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); param.args[0] = false; XposedBridge.log(&quot;hookYidian beforeHookedMethod setBlur &quot; + param.args[0]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;hookYidian afterHookedMethod setBlur&quot; + param.args[0]); } }); //这里是vip视频 vip下才能进入，非vip有弹窗提示 所以在弹窗之前 返回不需要vip权限 直接跳转到下页 XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.ui.practice.video.PlayingVideoPagerFragment&quot;, cl, &quot;h&quot;, boolean.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); param.args[0] = false; XposedBridge.log(&quot;hookYidian beforeHookedMethod PlayingVideoPagerFragment vipTip &quot; + param.args[0]); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;hookYidian afterHookedMethod PlayingVideoPagerFragment vipTip&quot; + param.args[0]); } }); //这里是确实是忘了什么东西了。 XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.store.W&quot;, cl, &quot;W&quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(true); XposedBridge.log(&quot;hookYidian afterHookedMethod W vipTip &quot; + param.getResult()); } }); //经过打印 发现之前为false 改为vip 强制返回true XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.model.ui.PlayingVideoData&quot;, cl, &quot;getVip&quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(true); XposedBridge.log(&quot;hookYidian afterHookedMethod W vipTip &quot; + param.getResult()); } }); //实在是忘了是干啥的了 Class c = XposedHelpers.findClass(&quot;com.wumii.android.athena.model.ui.PlayingVideoData&quot;, cl); XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.ui.practice.PlayingVideoActivity.a&quot;, cl, &quot;a&quot;, Context.class, c, String.class, boolean.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); XposedBridge.log(&quot;hookYidian PlayingVideoActivity beforeHookedMethod &quot; + param.args[3]); param.args[3] = false; } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;hookYidian PlayingVideoActivity afterHookedMethod &quot; + param.args[3]); } }); //10000是点击查看示意的次数 然而没啥用 因为最后不要这个提示了 Class f = XposedHelpers.findClass(&quot;com.wumii.android.athena.core.feature.FeatureType&quot;, cl); XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.c.c.e&quot;, cl, &quot;a&quot;, f, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(10000); } }); //发音专项 不需要vip权限 返回false XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.c.c.e&quot;, cl, &quot;b&quot;, f, String.class, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(false); } }); //由于是一个H5页面 找源代码找了好久，泛型有一个Config类中有个getVip方法 返回true 则都能看了 XposedHelpers.findAndHookMethod(&quot;com.wumii.android.athena.model.realm.Config&quot;, cl, &quot;getVip&quot;, new XC_MethodHook() { @Override protected void beforeHookedMethod(MethodHookParam param) throws Throwable { super.beforeHookedMethod(param); } @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); param.setResult(true); } }); } }); }后记 太极中不能添加插件 需要提交给太极的作者才能使用，所以建议使用virtualXposed。当前hook的一点应用版本是v3.15.0。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zhangyongfa888.site/categories/逆向/"},{"name":"Xposed","slug":"逆向/Xposed","permalink":"http://zhangyongfa888.site/categories/逆向/Xposed/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"使用反射和插件化实现实现对宿主更新","slug":"使用反射和插件化实现实现对宿主更新","date":"2019-12-16T01:49:00.000Z","updated":"2020-03-04T07:52:54.764Z","comments":true,"path":"2019/12/16/使用反射和插件化实现实现对宿主更新/","link":"","permalink":"http://zhangyongfa888.site/2019/12/16/使用反射和插件化实现实现对宿主更新/","excerpt":"","text":"背景对于先有项目，没有集成热更新功能，但是集成了滴滴的插件化。唯一的缺陷就是无法在不更新宿主的情况下对宿主进行更新。 解决方案还好在打开宿主时候的splash页和main页进行了加载了一个备用插件，可以在这个备用插件中进行操作。splash中的代码，在首页加载push插件，原计划此插件是针对不同的手机厂商集成不同的第三方推送，现在正好可修复宿主。 Class cl = plugin.getClassLoader().loadClass(&quot;***.huozhu.plugin_push.PushDispatch&quot;); Constructor ct = cl.getDeclaredConstructor(new Class[]{Context.class}); AppIntent appIntent = (AppIntent) ct.newInstance(new Object[]{context}); Intent intent = new Intent(); intent.putExtra(&quot;from&quot;, &quot;splash&quot;); appIntent.startAppActivity(intent);main中的代码 LogUtils.e(&quot;plugin---&gt;&quot; + plugin.getPackageName()); Class cl = plugin.getClassLoader().loadClass(&quot;***.huozhu.plugin_push.PushDispatch&quot;); Constructor ct = cl.getDeclaredConstructor(new Class[]{Context.class}); AppIntent appIntent = (AppIntent) ct.newInstance(new Object[]{context}); Intent intent = new Intent(); intent.putExtra(&quot;from&quot;, &quot;main&quot;); appIntent.startAppActivity(intent);解决过程目前的需求是修改主页中菜单的数据，要求新添加一行数据 push中的处理 其中extra是处理推送的情况，小米推送（极光）点击无法弹出界面，所以需要自己重写通知。from用于区分来源。比如这次要修改主页的一行数据 先看下宿主代码，找到切入点： main代码 宿主中 在这里对数据进行添加，是一个网络请求。考虑会有延时。所以有两个方案，一个是延时后添加一条，一个是hook网络请求，重写添加全部。可行性的话，1很简单，2过于繁琐。针对1方案，再考虑切入点。可以针对menuModels进行数据添加，也可对adapter进行数据添加。考虑到对集合添加后还需要adapter刷新，所以直接对adapter进行添加数据。 代码 private void setMenu() { try { Class menuModelClz = contextHost.getClassLoader().loadClass(&quot;****.huozhu.ep.model.MenuModel&quot;); Constructor constructor = menuModelClz.getConstructor(new Class[]{int.class, boolean.class, String.class, int.class}); Object instance = constructor.newInstance(R.drawable.host_main_menu_driver_group, false, &quot;我的承运人&quot;, 7); Field field = AppUtils.activities.get(0).getClass().getDeclaredField(&quot;adapter&quot;); LogUtils.e(&quot;setMenu field &quot; + field.getClass().toString()); field.setAccessible(true); BaseQuickAdapter adapter = (BaseQuickAdapter) field.get(AppUtils.activities.get(0)); if (adapter == null) { new Handler().postDelayed(new Runnable() { @Override public void run() { setMenu(); } }, 2000); } adapter.addData(2, instance); } catch (Exception e) { LogUtils.e(&quot;setMenu Error &quot; + e.toString()); } } 这样就对宿主进行了数据的添加。 其他修改 再有一个支付弹窗，直接使用的是宿主中的方法。所以如果要该支付这块，要更新宿主。那岂不是很麻烦。所以反射就又用到了。功能修改是 点击最后一行的时候由“下单”改为“去支付”。 现有的操作是对这个弹窗视图进行覆写，然后重写其中的点击事件的代码。所有的控件都能顺利拿到，唯独这个点击事件。所有通过反射，当弹窗显示的时候，对这个“下单”的按钮进行hook。 代码： private void hookOnClickListener(View view) { try { // 得到 View 的 ListenerInfo 对象 //得到getListenerInfo方法 Method getListenerInfo = View.class.getDeclaredMethod(&quot;getListenerInfo&quot;); getListenerInfo.setAccessible(true); //得到ListenerInfo变量 Object listenerInfo = getListenerInfo.invoke(view); // 得到 原始的 OnClickListener 对象 //获取指定类 Class&lt;?&gt; listenerInfoClz = Class.forName(&quot;android.view.View$ListenerInfo&quot;); //获取类中的变量 Field mOnClickListener = listenerInfoClz.getDeclaredField(&quot;mOnClickListener&quot;); mOnClickListener.setAccessible(true); View.OnClickListener originOnClickListener = (View.OnClickListener) mOnClickListener.get(listenerInfo); // 用自定义的 OnClickListener 替换原始的 OnClickListener View.OnClickListener hookedOnClickListener = new HookedOnClickListener(originOnClickListener); mOnClickListener.set(listenerInfo, hookedOnClickListener); } catch (Exception e) { } } class HookedOnClickListener implements View.OnClickListener { private View.OnClickListener origin; HookedOnClickListener(View.OnClickListener origin) { this.origin = origin; } @Override public void onClick(View v) { if (origin != null) { origin.onClick(v); } payBtn.setText(&quot;去支付&quot;); } } 还有一种方法就是对setText进行监听，当这个控件被赋值为“下单”的时候，重新赋值为“去支付”。 后记 hook的切入点很重要。顺便对反射进行了复习，觉得法国生物学家拉马克提出的“用进废退”果然没错，经常使用就会很顺利，一不使用的就感觉自己退化了一样，跟不上了。可能导致最后的结局就是“适者生存”吧！ 参考链接 Java高级特性——反射 Hook技术看这篇就够了 一文读懂 AOP | 你想要的最全面 AOP 方法探讨","categories":[{"name":"插件化","slug":"插件化","permalink":"http://zhangyongfa888.site/categories/插件化/"},{"name":"反射","slug":"插件化/反射","permalink":"http://zhangyongfa888.site/categories/插件化/反射/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"使用frida脱壳","slug":"使用frida脱壳","date":"2019-11-29T06:29:00.000Z","updated":"2020-03-04T07:52:54.764Z","comments":true,"path":"2019/11/29/使用frida脱壳/","link":"","permalink":"http://zhangyongfa888.site/2019/11/29/使用frida脱壳/","excerpt":"","text":"安卓常见脱壳方法之前了解过一些加固方法，像360，乐固，爱加密，梆梆等。很多apk包都经过加壳处理，因此想了解更多内容就需要对加壳的APP进行脱壳处理。 drizzleDumper1.下载文件 https://www.lanzous.com/i7qbkva 2.将对应系统架构的drizzleDumper移动到根目录/data/local/tmp下，赋予读写执行权限 3.cmd进入到该目录下 执行 ./drizzleDumper 包名 时间 包名：要脱壳应用的包名 时间：单位s,打卡应用后多久后开始脱壳 4.脱壳的文件保存在/data/local/tmp/ 现有样例apk 360/乐固 无法脱壳/小米MIX2S/Android10/其他机型未测试 FDex2FDex2基于xposed框架实现。 1.下载FDex2 ,VXP https://www.lanzous.com/b098smcoj 密码:tuoqiao 2.安装FDEX2 和要脱壳的应用到 VXP中。 3.重启VXP，打卡FDEX2选中要脱壳的应用 4.打开被脱的应用 5.生成的dex在data/data/io.va.exposed.virtual/data/user/0/包名/ 现有样例apk 360/乐固 无法脱壳/小米MIX2S/Android10/其他机型未测试 ZjDroid FDex2 同样基于xposed框架实现。具体操作 详见https://www.cnblogs.com/goodhacker/p/3961045.html 下载ZjDroid 现有样例apk 360/乐固 无法脱壳/小米MIX2S/Android10/其他机型未测试 易开发易开发是一款帮助开发人员快速开发的工具，功能包括界面分析，页面信息等。目前软件尚未完成，更多功能完善中。详见 https://github.com/WrBug/DeveloperHelper 下载工具 https://www.coolapk.com/apk/com.wrbug.developerhelper 现有样例apk 360/乐固 无法脱壳/小米MIX2S/Android10/其他机型未测试 frida1.Frida的安装很简单，需要在windows安装frida客户端和在安卓安装frida服务端。需要python+node环境。 __windows __ 安装python和pip，注意添加环境变量，打开pip的安装包，输入命令 pip install Frida-tools到python安装目录/script pipinstall selenium __ android __ 首先到github上下载frida-server，网址为https://github.com/frida/frida/releases 找到符合自己系统架构的文件 移动到data/local/tmp/下 赋予可读写执行权限。 2.开启服务 adb shell adb su ./data/local/tmp/frida-server-12.7.23-android-arm64 cmd不报错 弹窗不消失表示服务在运行。 3.开始脱壳 使用https://github.com/GuoQiang1993/Frida-Apk-Unpack 提供的js 去脱壳。 现有样例apk 360/乐固 脱壳 小米MIX2S/Android10 测试无法脱壳 红米6 pro/Android9可脱壳 后续 其他脱壳方法还包括 IDA调试脱壳/修改系统源码主动脱壳/虚拟化等技术，仍在学习中。","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zhangyongfa888.site/categories/逆向/"},{"name":"脱壳","slug":"逆向/脱壳","permalink":"http://zhangyongfa888.site/categories/逆向/脱壳/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"记录一次xp模块过程、","slug":"记录一次xp模块过程、","date":"2019-11-26T03:15:00.000Z","updated":"2020-03-04T07:52:54.766Z","comments":true,"path":"2019/11/26/记录一次xp模块过程、/","link":"","permalink":"http://zhangyongfa888.site/2019/11/26/记录一次xp模块过程、/","excerpt":"","text":"0X01无意间发现一款老司机应用，用起来还不错，但是可恶的是有次数限制。怒。于是念念不忘，要破了他！ 0x02按照以往的经验，先拿到apk中的dex文件，但愿不要加固。 smali2 不慌 问题不大。才两个包，好找。 入口 找到了splash入口，阅读代码后发现 root后不能使用，使用代理不能使用，模拟器不能使用。 paste image 那好 先去了。 分析代码 initView b()方法中有个c方法，返回 检测到您使用的是模拟器或者设备已经root,不允许继续使用，所以 hook c方法 强制返回false 使其能够进入到a.a(activity)中。 XposedHelpers.findAndHookMethod(&quot;com.niming.douyin.ui.splash.SplashActivity&quot;, cl, &quot;c&quot;, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;SplashActivity beforeHookedMethod &quot; + param.getResult()); param.setResult(false); } }); b中还有一个方法，!k.b(this.activity)，看代码是把所有的模拟器标识都列了出来，不知道为啥禁用模拟器，可能这些限制是为了躲坑。 使用xp 强制也给他通过 XposedHelpers.findAndHookMethod(&quot;com.niming.douyin.ui.splash.SplashActivity&quot;, cl, &quot;a&quot;, Context.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); XposedBridge.log(&quot;SplashActivity beforeHookedMethod &quot; + param.getResult()); param.setResult(false); } });这样进入到了f()； 接口请求 这里走了一个请求domain的接口，请求成功后 调用了 ConfigUtil.getInstance().save(com.niming.douyin.a.a.k, domain); this.a.d();保存了一下地址，然后调用 d方法 这里是先验证一下设备有没有注册过，如果注册过，直接登录，没有注册过，先注册。在几次测试中发现，这个手机设备号在第一次注册就存入到数据库，再次进入会取之前的数据，限制3次就是从这个设备号查出来的。通过抓取接口发现 当满三次的时候，并不会返回成功的数据，所以无法拿到地址。只能通过重新注册获取这免费的三次机会。所以要hook下这个配置文件，获取是否注册的时候 返回false,重新注册，获取设备号的时候 随机一个，避免重复。 XposedHelpers.findAndHookMethod(&quot;com.niming.framework.basedb.ConfigUtil&quot;, cl, &quot;getString&quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); if (param.args[0].equals(&quot;device_id&quot;)) { //随机id String deviceId = String.valueOf(UUID.randomUUID().toString()); param.setResult(deviceId); } } }); XposedHelpers.findAndHookMethod(&quot;com.niming.framework.basedb.ConfigUtil&quot;, cl, &quot;getBooleanValue&quot;, String.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); if (param.args[0].toString().equals(&quot;is_device_register&quot;)) { param.setResult(false); } } }); 这样每次都会重新注册获取免费的三次机会。 在测试过程中发现 新注册后会跳转到广告页SplashAdActivity，这个界面有个延时操作，很麻烦。 paste image d 默认值给了5秒。 给他强制跳转，代码中有个方法 private void b() { MainActivity.a(this.activity); finish(); }直接能够调用~ XposedHelpers.findAndHookMethod(&quot;com.niming.douyin.ui.splash.SplashAdActivity&quot;, cl, &quot;initView&quot;, Bundle.class, new XC_MethodHook() { @Override protected void afterHookedMethod(MethodHookParam param) throws Throwable { super.afterHookedMethod(param); //去广告 XposedHelpers.callMethod(param.thisObject, &quot;b&quot;); } }); 这样跳转的时候就能够忽略延时广告，直接跳转了。 0x03 在网络请求测试中发现数据是加密的，当然代码都拿到了，还怕拿不到密码? 这里有个密码，有点兴奋，but不可能这么明显八。 反码了几次发现不对哦。 ennnnn…. e…. 我觉得这个TextUtils肯定用到了，戳进去发现是Jni…… 不过没关系。有工具！ 找到lib中的security,拖到这个小姐姐身上 很明显 仅仅返回的是字符串。从java代码看，应该是不同的环境需要不同的密码取转码。 解下数据，这波操作可以。 0x?? __ //todo __ 1.三次后自动注册一次 确保一直有次数 2.暴力寻找vip的uuid","categories":[{"name":"逆向","slug":"逆向","permalink":"http://zhangyongfa888.site/categories/逆向/"},{"name":"Xposed","slug":"逆向/Xposed","permalink":"http://zhangyongfa888.site/categories/逆向/Xposed/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"TINKER 集成","slug":"Tinker集成","date":"2019-11-04T08:44:00.000Z","updated":"2020-03-04T07:52:54.763Z","comments":true,"path":"2019/11/04/Tinker集成/","link":"","permalink":"http://zhangyongfa888.site/2019/11/04/Tinker集成/","excerpt":"","text":"TINKER 集成Tinker是啥Tinker是微信官方的Android热补丁解决方案，它支持动态下发代码、So库以及资源，让应用能够在不需要重新安装的情况下实现更新。当然，你也可以使用Tinker来更新你的插件。Tinker Github 为什么使用Tinker当前市面的热补丁方案有很多，其中比较出名的有阿里的AndFix、美团的Robust以及QZone的超级补丁方案。但它们都存在无法解决的问题，这也是正是我们推出Tinker的原因。如下，就可以知道Tinker的强大之处。 Tinker QZone AndFix Robust 类替换 yes yes no no So替换 yes no no no 资源替换 yes yes no no 全平台支持 yes yes no yes 即时生效 no no yes yes 性能损耗 较小 较大 较小 较小 补丁包大小 较小 较大 一般 一般 开发透明 yes yes no no 复杂度 较低 较低 复杂 复杂 Rom体积 Dalvik较大 较小 较小 较小 成功率 较高 较高 一般 最高 Tinker的已知问题由于原理与系统限制，Tinker有以下已知问题： Tinker不支持修改AndroidManifest.xml，Tinker不支持新增四大组件 由于Google Play的开发者条款限制，不建议在GP渠道动态更新代码； 在Android N上，补丁对应用启动时间有轻微的影响； 不支持部分三星android-21机型，加载补丁时会主动抛出”TinkerRuntimeException:checkDexInstall failed”； 对于资源替换，不支持修改remoteView。例如transition动画，notification icon以及桌面图标。 Tinker集成过程（使用bugly集成）项目工程的.gradle 中添加 classpath &quot;com.tencent.bugly:tinker-support:1.2.0&quot;app的.gradle中添加 implementation &apos;com.tencent.bugly:crashreport_upgrade:1.4.2&apos; implementation &apos;com.tencent.tinker:tinker-android-lib:1.9.14&apos;应用bugly配置好的gradle文件 apply from: &apos;tinker-support.gradle&apos; tinker-support.gradle 代码 apply plugin: &apos;com.tencent.bugly.tinker-support&apos; def bakPath = file(&quot;${buildDir}/bakApk/&quot;) /** * 此处填写每次构建生成的基准包目录 */ def baseApkDir = &quot;huozhu-1104-11-36-34&quot; /** * 对于插件各参数的详细解析请参考 */ tinkerSupport { // 开启tinker-support插件，默认值true enable = true // 指定归档目录，默认值当前module的子目录tinker autoBackupApkDir = &quot;${bakPath}&quot; // 是否启用覆盖tinkerPatch配置功能，默认值false // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch overrideTinkerPatchConfiguration = true // 编译补丁包时，必需指定基线版本的apk，默认值为空 // 如果为空，则表示不是进行补丁包的编译 // @{link tinkerPatch.oldApk } baseApk = &quot;${bakPath}/${baseApkDir}/huozhu-release.apk&quot; // 对应tinker插件applyMapping baseApkProguardMapping = &quot;${bakPath}/${baseApkDir}/huozhu-release-mapping.txt&quot; // 对应tinker插件applyResourceMapping baseApkResourceMapping = &quot;${bakPath}/${baseApkDir}/huozhu-release-R.txt&quot; // 构建基准包和补丁包都要指定不同的tinkerId，并且必须保证唯一性 tinkerId = &quot;base_11.04.11.49&quot; // 构建多渠道补丁时使用 // buildAllFlavorsDir = &quot;${bakPath}/${baseApkDir}&quot; // 是否启用加固模式，默认为false.(tinker-spport 1.0.7起支持） // isProtectedApp = true // 是否开启反射Application模式 enableProxyApplication = false // 是否支持新增非export的Activity（注意：设置为true才能修改AndroidManifest文件） supportHotplugComponent = true } /** * 一般来说,我们无需对下面的参数做任何的修改 * 对于各参数的详细介绍请参考: * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97 */ tinkerPatch { //oldApk =&quot;${bakPath}/${appName}/app-release.apk&quot; ignoreWarning = false useSign = true dex { dexMode = &quot;jar&quot; pattern = [&quot;classes*.dex&quot;] loader = [] } lib { pattern = [&quot;lib/*/*.so&quot;] } res { pattern = [&quot;res/*&quot;, &quot;r/*&quot;, &quot;assets/*&quot;, &quot;resources.arsc&quot;, &quot;AndroidManifest.xml&quot;] ignoreChange = [] largeModSize = 100 } packageConfig { } sevenZip { zipArtifact = &quot;com.tencent.mm:SevenZip:1.1.10&quot; // path = &quot;/usr/local/bin/7za&quot; } buildConfig { keepDexApply = false //tinkerId = &quot;1.0.1-base&quot; //applyMapping = &quot;${bakPath}/${appName}/app-release-mapping.txt&quot; // 可选，设置mapping文件，建议保持旧apk的proguard混淆方式 //applyResourceMapping = &quot;${bakPath}/${appName}/app-release-R.txt&quot; // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配 } } 配置application 新建SampleApplicationLike 继承自DefaultApplicationLike ,开启反射application模式 enableProxyApplication = false //tinker-support.gradle 中的配置 在onBaseContextAttached 添加MultiDex 和Tinker public void onBaseContextAttached(Context base) { super.onBaseContextAttached(base); // you must install multiDex whatever tinker is installed! MultiDex.install(base); // 安装tinker TinkerManager.installTinker(this); }应用的Application 继承自TinkerApplication 并重写默认构造方法 public MyApplication() { super(ShareConstants.TINKER_ENABLE_ALL, “xx.xx.SampleApplicationLike”, “com.tencent.tinker.loader.TinkerLoader”, false); } Tinker 生成插件包(可使用bugly中的tinker-support)先生成基准包，也就是上线后有bug的包；默认在build/bakApk 中 assemble一次就会生成一次 基准包目录结构 目录结构 huozhu-release.apk 因为是组件化的目录结构 所以是huozhu-release.apk 而不是app-release.apk 而且注意 tinker-support.gradle 配置的指定文件名称是否一致; huozhu-release-mapping.txt :开启混淆后会生成mapping文件 基准包生成后将 地址 复制到配置中 /** * 此处填写每次构建生成的基准包目录 */ def baseApkDir = &quot;huozhu-1104-11-36-34&quot;同时指定一个唯一的tinkerId 可以理解为 每一次打补丁包都要指定一个tinkerId 修改部分代码 然后执行生成补丁 因为是bugly中的tinker 所以直接使用tinker-support中的buildTinkerPatchRelease ，在outputs根目录生的patch生成了可用补丁 如果是tinker中的tinkerPatchRelease 则在outputs/apk/tinkerPatch中生成了补丁 插件目录 加载补丁包在app首页或者任意位置去加载补丁包 这里封装了一下下载补丁的方法 直接调用即可 PatchUtils.getInstance().checkPatch(context);核心方法是 TinkerInstaller.onReceiveUpgradePatch(context, file.getAbsolutePath());Tinker中已经有各种判断 补丁是否正确等判断，所以直接加载就可以。 加载监听： TinkerManager.getInstance().setTinkerListener(new TinkerManager.TinkerListener() { @Override public void onDownloadSuccess(String s) { Log.d(&quot;onDownloadSuccess&quot;, s); } @Override public void onDownloadFailure(String s) { Log.d(&quot;onDownloadFailure&quot;, s); } @Override public void onPatchStart() { } @Override public void onApplySuccess(String s) { Log.d(&quot;onApplySuccess&quot;, s); Toast.makeText(context, &quot;更新完成 即将重启&quot;, Toast.LENGTH_SHORT).show(); new Handler().postDelayed(new Runnable() { @Override public void run() { PackageManager packageManager = context.getPackageManager(); Intent intent = packageManager.getLaunchIntentForPackage(context.getPackageName()); intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK); context.startActivity(intent); AppUtils.exitApp(context); System.exit(0); } }, 2000); } @Override public void onApplyFailure(String s) { Log.d(&quot;onApplyFailure&quot;, s); } @Override public void onPatchRollback() { } });遇到的问题1.当项目中含有第三方lib库时候，加载补丁会报错 java.lang.UnsatisfiedLinkError: Shared library &quot;/data/app/***-3IhVXmnAlMEQk_hwO6_0Mg==/lib/arm/libc++_shared.so&quot; already opened by ClassLoader解决办法：第三方库加载前，有tinker加载 TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduMapSDK_base_v6_0_0&quot;); TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduMapSDK_map_v6_0_0&quot;); TinkerLoadLibrary.loadArmLibrary(getApplication(), &quot;BaiduTraceSDK_v3_0_7&quot;);2.新添加的activity 找不到声明 基础包必须设置supportComponent=true，并且新增Activity的Exported属性必须为false。后续如何对多渠道、加固包等做处理，以及少扣绩效","categories":[{"name":"热更新","slug":"热更新","permalink":"http://zhangyongfa888.site/categories/热更新/"},{"name":"Tinker","slug":"热更新/Tinker","permalink":"http://zhangyongfa888.site/categories/热更新/Tinker/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyongfa"},{"title":"测试点击事件","slug":"测试点击事件","date":"2019-09-09T07:51:17.000Z","updated":"2019-09-10T06:39:11.525Z","comments":true,"path":"2019/09/09/测试点击事件/","link":"","permalink":"http://zhangyongfa888.site/2019/09/09/测试点击事件/","excerpt":"","text":"计算工具——————————————————————选择开始时间 计算 function a() { var current = new Date(); var currentYear = current.getFullYear(); var currentMonth = current.getMonth() + 1; var currentDay = current.getDate(); var currentDate = currentYear + \"-\" + (currentMonth < 10 ? \"0\" + currentMonth : currentMonth + \"\") + \"-\" + (currentDay < 10 ? \"0\" + currentDay : currentDay + \"\"); var v = document.getElementById(\"date\").value; var choose = new Date(v); var chooseYear = choose.getFullYear(); var chooseMonth = choose.getMonth() + 1; var chooseDay = choose.getDate(); var cha = currentYear - chooseYear; // var cha = (current.getTime() - choose.getTime()) / 1000 / 60 / 60 / 24 / 365; // var cha=parseInt(cha); // var lit = cha - intCha; // alert(cha) // if(intCha==3){ // } var realYear = (current.getTime() - choose.getTime()) / 1000 / 60 / 60 / 24 / 365; if (cha 3) {//真满3年 var startDate = currentYear + \"-01-01\"; var endDate = currentYear + \"-\" + chooseMonth + \"-\" + chooseDay; var chaDay = (new Date(endDate).getTime() - new Date(startDate).getTime()) / 1000 / 60 / 60 / 24; var allDay = 3 * chaDay / 365 + 5 * (365 - chaDay) / 365; alert(\"入职满\" + cha + \"年！\" + allDay) } else { alert(\"入职满\" + realYear + \"年！有3天年假\") } } else if (cha == 4 || cha == 5 || cha >= 6) { alert(\"入职满\" + cha + \"年！有5天年假\") } // alert(v + \"\\n\" + currentDate); } L2Dwidget.init({\"pluginRootPath\":\"live2dw/\",\"pluginJsPath\":\"lib/\",\"pluginModelPath\":\"assets/\",\"model\":{\"scale\":1,\"hHeadPos\":0.5,\"vHeadPos\":0.618,\"jsonPath\":\"/live2dw/assets/shizuku.model.json\"},\"display\":{\"superSample\":2,\"width\":150,\"height\":300,\"position\":\"left\",\"hOffset\":0,\"vOffset\":-20},\"mobile\":{\"show\":false,\"scale\":0.5},\"react\":{\"opacityDefault\":0.7,\"opacityOnHover\":0.2},\"log\":false,\"tagMode\":false});","categories":[],"tags":[],"author":"zhangyongfa"},{"title":"Android唯一识别码 获取","slug":"Android唯一识别码-获取","date":"2019-08-28T03:52:00.000Z","updated":"2019-09-03T00:21:58.737Z","comments":true,"path":"2019/08/28/Android唯一识别码-获取/","link":"","permalink":"http://zhangyongfa888.site/2019/08/28/Android唯一识别码-获取/","excerpt":"","text":"前言目前有个需求，需要获取设备的唯一识别码 标记用户的手机,在android低版本上很好实现，imei或者deviceID之间能够拿到，但是android10已经不给此项权限了……于是开始找资料。 不可重置的设备标识符 ：官（墙）方（外）推荐方法从 Android Q 开始，应用必须具有 READ_PRIVILEGED_PHONE_STATE 特许权限才能访问设备的不可重置标识符（包含 IMEI 和序列号）。许多用例不需要不可重置的设备标识符。如果您的应用没有该权限，但您仍尝试查询标识符的相关信息，则平台的响应会因目标 SDK 版本而异： 如果应用以 Android Q 为目标平台，则会发生 SecurityException。如果应用以 Android 9（API 级别 28）或更低版本为目标平台，则相应方法会返回 null 或占位符数据（如果应用具有 READ_PHONE_STATE 权限）。否则，会发生 SecurityException。注意：如果您的应用是设备所有者或配置文件所有者应用，那么即使您的应用以 Android Q 为目标平台，您也只需 READ_PHONE_STATE 权限即可访问不可重置的设备标识符。此外，如果您的应用具有特殊运营商权限，则无需任何权限即可访问这些标识符。如果您的应用将不可重置的设备标识符用于广告跟踪或用户分析目的，请为这些特定用例创建 Android 广告 ID。要了解详情，请参阅唯一标识符的最佳做法。https://developer.android.google.cn/training/articles/user-data-ids 另一篇文章有讲解如何获取广告id :Google Advertising Id 获取 但是还需要注册谷歌开发者 申请谷歌广告的id The Google Mobile Ads SDK was initialized incorrectly. AdMob publishers should follow the instructions here: https://googlemobileadssdk.page.link/admob-android-update-manifest to add a valid App ID inside the AndroidManifest. Google Ad Manager publishers should follow instructions here: https://googlemobileadssdk.page.link/ad-manager-android-update-manifest. 最后放弃了~ 国内 设备获取设备标识符全国信息安全标准化技术委员会 有《信息安全技术 移动互联网应用（App）收集个人信息基本规范（草案）》， 规定了地图导航、网络约车、即时通讯、博客论坛、网络支付、新闻资讯、网上 购物等 21 种常用服务类型可收集的最少信息。 App 收集个人信息基本要求管理要求App收集个人信息应满足以下管理要求： a） App 运营者应履行个人信息保护义务，采取必要安全措施，保障用户个人信息安全。 b） 当用户同意 App 收集某服务类型的最少信息时，App 不得因用户拒绝提供最少信息 之外的个人信息而拒绝提供该类型服务。 注：附录 A 列举了 App 常见的服务类型以及服务类型对应的最少信息。 c） App 不得收集与所提供的服务无关的个人信息。 d） 对外共享、转让个人信息前，App 应事先征得用户明示同意。当用户不同意, 则不 得对外共享、转让用户个人信息。 e） App 不得收集不可变更的设备唯一标识（如 IMEI 号、MAC 地址等） ，用于保障网络 安全或运营安全的除外。 f） 用户明确拒绝使用某服务类型后，App 不得频繁（如每 48 小时超过一次）征求用 户同意使用该类型服务，并保证其他服务类型正常使用。 g） App 应对其使用的第三方代码、插件的个人信息收集行为负责。第三方代码、插件 收集个人信息视同 App 收集，App 应防止第三方代码、插件收集无关的个人信息。 注：如第三方代码、插件自行向用户明示其收集、使用个人信息的目的、方式、范围，并征得用户同意，则第三方代码、插件独立对其个人信息收集行为承担责任。 技术要求App收集个人信息应满足以下技术要求： a） 当收集的个人信息超出服务类型的最少信息时，超出部分的个人信息，App 应逐项 征得用户明示同意。 b） 当同一 App 有 2 种或 2 种以上服务类型时，App 应允许用户逐项开启和退出服务类 型，开启或退出的方式应易于操作。 c） 当用户退出某服务类型后，App 应终止该服务类型收集个人信息的活动，并对仅用 于该服务的个人信息进行删除或匿名化处理。 d） 当申请个人信息相关权限或要求用户输入个人信息时，App 应向用户同步明示申请 权限或收集信息的目的。 e） App 应向用户提供实时查询已收集个人信息类型的功能；查询结果应以独立界面展 示，且查询方式应易于操作。 f） 存在对外共享、转让个人信息的，App 应向用户提供查询数据接收方身份的功能； 查询结果应以独立界面展示，且查询方式应易于操作。 g） 在技术可行且不影响终端和服务正常的情况下，App 应优先在用户终端中存储、使 用所收集的个人信息。 h） App 应以实现服务所必需的最低合理频率向后台服务器发送个人信息。 所以这么严格，相关部门肯定会有一个规范来统一下发或者管理手机的唯一识别码，来达到“监管”用户的操作 规范来了~移动智能终端补充设备标识体系移动安全联盟移动安全联盟(Mobile Security Alliance，简称MSA)于2017年12月4日成立，由中国信息通信研究院联合终端生产企业、安全企业、高等院校、研究机构、互联网企业以及芯片企业、方案企业等产业链中各个环节的重要机构共同发起。由各大手机厂商”共同维护”来进行统一、规范化唯一识别码，目前包括的手机厂商有 厂商 版本 小米 MIUI10.2 及以上 vivo FuntouchOS 9 及以上 华为 全版本 OPPO Color OS 7.0 及以上（9 月份正式支持） Lenovo ZUI 11.4 及以上（9 月中旬正式支持） 体系说明移动智能终端补充设备标识体系架构共涉及四类实体，包括开发者、开发者开发的应用软件、移动智能终端设备的操作系统、用户及用户使用的设备。为保护用户用户的隐私和标识设备的唯一性，根据不同使用对象和不同用途，基于移动智能终端设备，分别生成设备唯一标识符、匿名设备标识符、开发者匿名设备标识符和应用匿名设备标识符，将这四个设备标识符构成补充设备标识体系。 体系图 唯一标识符作为普通用户仍然是拿不到，但是能够替代的，我们可以用其他的id, OAID 可与用户数据、账号绑定 用于个性化推荐、广告业务。 VAID 多应用之间能够共享的唯一标识，同一个开发者多个应用可以使用，举个例子：司机端和货主端 ，货主端发货刷单，司机端抢单时候可以用vaid判断，是否是同一台设备；缺点是必须是该手机平台的线上应用才能统计到是否是同一个开发者账号下的app,部分厂商，若应用未在其开发者平台后台上架，则认定未非法应用，无 法生成 VAID，手机 LOG 中将会有相关异常值输出。 AAID 单个app用于用户统计等，没有VAID的需求情况下 可以使用。 目前移动安全联盟 仍在免费注册阶段，还没有收费制服。作为旁观者，还是尽早注册，毕竟中国的手机市场很大，而且如上的通过谷歌广告的形式获取唯一识别码走不通，利润可想而知。 相关连接移动安全联盟 全国信息安全标准化技术委员会 谷歌官方文档 小米设备标识体系的说明 Google Advertising Id 获取","categories":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"Awesome-android-tips","slug":"Awesome-android-tips","date":"2019-08-23T07:20:00.000Z","updated":"2020-03-04T07:52:54.762Z","comments":true,"path":"2019/08/23/Awesome-android-tips/","link":"","permalink":"http://zhangyongfa888.site/2019/08/23/Awesome-android-tips/","excerpt":"","text":"EnglishVersion -&gt;_-&gt;:https://github.com/jiang111/awesome-android-tips/blob/master/README-en.md 值得收藏的AS插件 -&gt;_-&gt;:https://github.com/jiang111/awesome-androidstudio-plugins 这里收集了大家常用的一些Android代码,持续更新中,内容来自自己的平时积累和网络上看到的文章，部分原文地址在最下方。如有错误欢迎指正,如有侵权,请联系我删除。里面可能会有重复内容,请忽略或者提醒我删除。 Table of Contents setBackgroundResource(0) 可以移除 View 的背景色 Resources.getSystem().getDisplayMetrics().density 可以不用 Context 也能获取屏幕密度哦 通过重载 ViewGroup 的 dispatchDraw 可以实现一个简单的蒙版效果。 例如下拉刷新时，可以在 contentView 上加一层遮罩。 canvas.drawRect(0, mContentView.getTranslationY(), getWidth(), getHeight(), mMaskPaint); new 出来的 View 可以用 View.generateViewId() （API 17 以上可用） 生成 id，系统保证唯一 使用 GridView时 android:padding 和 android:clipToPadding=”false” 配合使用效果更好哦。 在布局文件中，如果只是为了占位，可以用 Space 来取代 View。 最棒的一点是Space可以跳过 Draw 这个过程。 TypedValue.applyDimension(int unit, float value, DisplayMetrics metrics) 方便dp, px, sp 之间的转换。 Activity.startActivities() 这个方法最直接的理解就是使用intent开启多个Activity TextUtils.isEmpty() 如果传入的String 为NULL或者Length为0的话就返回 true。 Html.fromHtml() 如果你对Html熟悉的话，可以很迅速通过这个方法处理一些富文本操作。比如超链接和图文排版等处理。 TextView.setError() 设置文本框错误提醒 Build.VERSION_CODES 有些时候我们的app需要根据不同的SDK版本进行执行不同的操作 PhoneNumberUtils.convertKeypadLettersToDigits 这个方法简单粗暴，会将输入的字母根据键盘上的映射转换为数字。 ArgbEvaluator ArgbEvaluator.evaluate(float fraction, Object startValue, Object endValue);根据一个起始颜色值和一个结束颜色值以及一个偏移量生成一个新的颜色，分分钟实现类似于微信底部栏滑动颜色渐变。 ValueAnimator.reverse() 顺畅的取消动画效果 DateUtils.formatDateTime()) 这个方法可以输出相应格式化的时间或者日期 Pair 这个类 可以用来存储存储一”组”数据。但不是key和value的关系。 SparseArray 目前有很多地方从性能优化方说使用SparseArray来替换hashMap，来节省内存，提高性能。 Linkify.addLinks() 这个类可以更方便的为文本添加超链接。 android.media.ThumbnailUtils这个类主要是用来处理缩略图相关的工作,比如:用来获取媒体（图片、视频）的缩略图 12createVideoThumbnail(String filePath, int kind)extractThumbnail(Bitmap source, int width, int height) Bitmap.extractAlpha ();返回一个新的Bitmap，capture原始图片的alpha值。有的时候我们需要动态的修改一个元素的背景图片又不希望使用多张图片的时候，通过这个方法，结合Canvas和Paint可以动态的修改一个纯色Bitmap的颜色。 模块间有消息需要传递时，使用LocalBroadcastManager替代Listener进行模块解耦。除了解耦，这样发送消息和执行消息差一个线程循环，可以减小方法的调用链，我这就碰到一次方法调用链太长导致StackOverflow的问题。 静态变量不要直接或者间接引用Activity、Service等。这会使用Activity以及它所引用的所有对象无法释放，然后，用户操作时间一长，内存就会狂升。 Handler机制有一个特点是不会随着Activity、Service的生命周期结束而结束。也就是说，如果你Post了一个Delay的Runnable，然后在Runnable执行之前退出了Activity，Runnable到时间之后还是要执行的。如果Runnable里面包含更新View的操作，可能会造成内存泄露,所以可以在 onDestory() 的时候调用removeCallbacksAndMessages来移除这个Handler所对应等待执行的message。 不少人在子线程中更新View时喜欢使用Context.runOnUiThread，这个方法有个缺点，就是一但Context生命周期结束，比如Activity已经销毁时，一调用就会崩溃。 SharedPreferences.Editor.commit这个方法是同步的，一直到把数据同步到Flash上面之后才会返回，由IO操作的不可控，尽量使用apply方法代替。apply只在API Level&gt;=9才会支持，需要做兼容。不过，最新的 support v4 包已经为我们做好了处理，使用 SharedPreferencesCompat.EditorCompat.getInstance().apply(editor) 即可。 PackageManager.getInstalledPackages这个方法经常使用，你可能不知道，当获取的结果数量比较多的时候，在某些机型上面调用它花费的时间可能秒级的，所以尽量在子线程中使用。另外，如果结果太多，超过系统设置的Binder数据最大传输量的上限，则会发生TransactionException，如果你使用这个方法获取机器上的己安装应用列表，最好做一下预防。 如果使用Context.startActivity启动外部应用，最好做一下异常预防，因为寻找不到对应的应用时，会抛出异常。如果你要打开的是应用内的Activity，不防使用显式Intent，这样能提高系统搜索目标Activity的效率。 Application的生命周期就是进程的生命周期。只有进程被干掉时，Application才会销毁。哪怕是没有Activity、Service在运行，Application也会存在。所以，为了减少内存压力，尽量不要在Application里面引用大对象、Context等。 设置全屏方法有2种:1.通过代码设置，2通过manifest文件设置。用代码设置全屏时app在我们应用运行后，可能会看到短暂的状态栏，然后才全屏，而第二种方法是不会有这种情况的,所以推荐第二种。 12345678910//方法1: //无title requestWindowFeature(Window.FEATURE_NO_TITLE); getWindow().setFlags(WindowManager.LayoutParams. FLAG_FULLSCREEN,WindowManager.LayoutParams. FLAG_FULLSCREEN); //必须在setContentView()之前调用setContentView(R.layout.main); //方法2:&lt;activity android:name=&quot;.&quot; android:theme=&quot;@android:style/Theme.NoTitleBar.Fullscreen&quot; //全屏主题 android:label=&quot;@string/app_name&quot; /&gt; viewpager 的 setCurrentItem 一定要在 setAdapter 方法之后调用才会有效果. 判断手机是不是飞行模式 boolean isEnabled = Settings.System.getInt(context.getContentResolver(), Settings.System.AIRPLANE_MODE_ON, 0) == 1; TabLayout 修改字体的方法官方的 TabLayout 没有提供修改 TextView size 的方法，可以新建一个 style CustomTabLayoutTextAppearance 继承 TextAppearance.AppCompat.Widget.ActionBar.Title.Inverse ，然后增加 item ，设置 android:textAllCaps 为 true ，再设置 android:textSize 为你想设置的大小。 再在 TabLayout 的布局文件里设置 app:tabTextAppearance=”@style/CustomTabLayoutTextAppearance” 即可。 遍历HashMap的最佳方法 12345public static void printMap(Map mp) &#123; for (Map.Entry m : mp.entrySet()) &#123; System.out.println(m.getKey() + \":\" + m.getValue()); &#125;&#125; 使用Java在一个区间内产生随机整数数 12345public static int randInt(int min, int max) &#123; Random rand = new Random(); int randomNum = rand.nextInt((max - min) + 1) + min; return randomNum;&#125; 如果子类实现Serializable接口而父类未实现时，父类不会被序列化，但此时父类必须有个无参构造方法，否则会抛InvalidClassException异常。 transient关键字修饰变量可以限制序列化。 当使用JakeWharton的TabPageIndicator时，如果需要先做一些耗时的操作，然后再展示TabPageIndicator的话，需要先设置mIndirector.setVisibility(View.GONE);然后耗时任务结束以后再mIndirector.setVisibility(View.VISIBLE);否则会报错 类继承之间的调用顺序 父类static成员 -&gt; 子类static成员 -&gt; 父类普通成员初始化和初始化块 -&gt; 父类构造方法 -&gt; 子类普通成员初始化和初始化块 -&gt; 子类构造方法 华为手机无法显示log解决方案,.拨号界面输入(*#*#2846579#*#*) Service menu will appear.Go to “ProjectMenu” -&gt; “Background Setting” -&gt; “Log Setting”Open “Log switch” and set it to ON.Open “Log level setting” and set the log level you wish. 后台service经常因为重启之类的出现onStartCommand()中的Intent传递的参数为null， 通过在onStartCommand()中的返回值改成return super.onStartCommand(intent, Service.START_REDELIVER_INTENT, startId); 可以解决问题。下面介绍几个flag的意思 flag 解释 START_STICKY 如果service进程被kill掉，保留service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到service，那么参数Intent将为null。 START_NOT_STICKY “非粘性的”。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统不会自动重启该服务。 START_REDELIVER_INTENT 重传Intent。使用这个返回值时，如果在执行完onStartCommand后，服务被异常kill掉，系统会自动重启该服务，并将Intent的值传入。 START_STICKY_COMPATIBILITY START_STICKY的兼容版本，但不保证服务被kill后一定能重启。 不能在Activity没有完全显示时显示PopupWindow和Dialog 在多进程之间不要用SharedPreferences共享数据，虽然可以（MODE_MULTI_PROCESS），但极不稳定 有些时候不能使用Application的Context，不然会报错（比如启动Activity，显示Dialog等） *备注：大家注意看到有一些NO上添加了一些数字，其实这些从能力上来说是YES，但是为什么说是NO呢？下面一个一个解释： 数字1：启动Activity在这些类中是可以的，但是需要创建一个新的task，一般情况不推荐； 数字2：在这些类中去layout inflate是合法的，但是会使用系统默认的主题样式，如果你自定义了某些样式可能不会被使用； 数字3：在Receiver为null时允许，在4.2或以上的版本中，用于获取黏性广播的当前值。（可以无视）； ContentProvider、BroadcastReceiver之所以在上述表格中，是因为在其内部方法中都有一个context用于使用。 谨慎使用Android的透明主题，透明主题会导致很多问题，比如：如果新的Activity采用了透明主题，那么当前Activity的onStop方法不会被调用；在设置为透明主题的Activity界面按Home键时，可能会导致刷屏不干净的问题；进入主题为透明主题的界面会有明显的延时感 不要在非UI线程中初始化ViewStub，否则会返回null 尽量不要通过Application缓存数据，这不稳定 华为手机无法打开USB调试的问题， 插好数据线,拨号界面 输入 ##2846579## 进入工程模式 projectmenu→3后台设置→4USB端口配置→Balong调试模式,点确定 不要拔线,退出工程模式,直接重启手机,电脑中显示可移动磁盘(若仍未出现,重复步骤1、2) 这个是关闭USB调试的情况下电脑中使用手机的可移动磁盘的方法，使用后下拉菜单中usb选项也回来了。 android listview中的消息被软键盘遮挡了,在设置listview的时候加上android:transcriptMode=”normal”就好了 TextUtils 是一个非常好用的工具类，把 List 转成字符串，逗号分隔，逗号分隔的 String 字符串，切割成 List ，分别可以用 TextUtils 的 join 和 split 方法。如果要对 List 去重，则可以用 Collection 的 frequency 方法。 在activity中调用 moveTaskToBack (boolean nonRoot)方法即可将activity 退到后台，注意不是finish()退出。 activity中的runOnUiThrea(Runnable action)方法可以直接回到主线程 listview有个footerDividersEnabled和headerDividersEnabled方法可以设置listview的顶部和底部divide，但是必须保证你设置了headview和footview才会有效果 Throwable类中的getStackTrace()方法，根据这个方法可以得到函数的逐层调用地址，其返回值为StackTraceElement[]； StackTraceElement类，其中四个方法getClassName()，getFileName()，getLineNumber()，getMethodName()在调试程序打印Log时非常有用； UncaughtExceptionHandler接口，再好的代码异常难免，利用此接口可以对未捕获的异常善后 Resources类中的getIdentifier(name, defType, defPackage)方法，根据资源名称获取其ID，做UI时经常用到； view的isShown方法，只有当view本身以及它的所有祖先们都是visible时，isShown（）才返回TRUE。而平常我们调用if(view.getVisibility() == View.VISIBLE)只是对view本身而不对祖先的可见性进行判断。 Arrays类中的一系列关于数组操作的工具方法：binarySearch()，asList()，equals()，sort()，toString()，copyOfRange()等；Collections类中的一系列关于集合操作的工具方法：sort()，reverse()等； TextView类中的append(CharSequence)方法，添加文本。一些特殊文本直接用+连接会变成String； System类中的arraycopy(src, srcPos, dest, destPos, length)方法，用来copy数组； Fragment类中的onHiddenChanged(boolean)方法，使用FragmentTransaction中的hide()，show()时只会调用Fragment中的show和hidden状态,其他生命周期不会调用。 Activity类中的onWindowFocusChanged(boolean)，onNewIntent(intent)等回调方法； TextView类中的setTransformationMethod(TransformationMethod)方法，可用来实现“显示密码”功能 PageTransformer接口，用来自定义ViewPager页面切换动画，用setPageTransformer(boolean, PageTransformer)方法来进行设置； apache提供的一系列jar包：commons-lang.jar，commons-collections.jar，commons-beanutils.jar等，里面很多方法可能是你曾经用几十几百行代码实现过的，但是执行效率或许要差很多，比如：ArrayUtils，StringUtils……； ActivityLifecycleCallbacks接口，用于在Application类中监听各Activity的状态变化 阅读地址点我 ActionBar.hide()/.show() 顾名思义，隐藏和显示ActionBar，可以优雅地在全屏和带Actionbar之间转换。 SystemClock.sleep() 这个方法在保证一定时间的 sleep 时很方便，通常我用来进行 debug 和模拟网络延时。 UrlQuerySanitizer——使用这个工具可以方便对 URL 进行检查。 ActivityOptions ——方便的定义两个Activity切换的动画。 使用ActivityOptionsCompat 可以很好解决旧版本的兼容问题。 getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。 HandlerThread，代替不停new Thread开子线程的重复体力写法。 IntentService,一个可以干完活后自己去死且不需要我们去管理子线程的Service Executors. newSingleThreadExecutor();这个是java的，之前不知道它，自己花很大功夫去研究了单线程顺序执行的任务队列 android:animateLayoutChanges=”true”，LinearLayout中添加View的动画的办法，支持通过setLayoutTransition()自定义动画。 AsyncQueryHandler，如果做系统工具类的开发，比如联系人短信辅助工具等，肯定免不了和ContentProvider打交道，如果数据量不是很大的情况下，随便搞，如果数据量大的情况下，了解下这个类是很有必要的，需要注意的是，这玩意儿吃异常.. ViewFlipper，实现多个view的切换(循环)，可自定义动画效果，且可针对单个切换指定动画。 android util包中的Pair类，可以方便的用来存储一”组”数据。注意不是key value android:descendantFocusability，ListView的item中CheckBox等元素抢焦点导致item点击事件无法响应时，除了给对应的元素设置 focusable,更简单的是在item根布局加上android:descendantFocusability=”blocksDescendants” includeFontPadding=”false”，TextView默认上下是有一定的padding的，有时候我们可能不需要上下这部分留白，加上它即可。 Messenger，面试的时候通常都会被问到进程间通信，一般情况下大家都是开始背书，AIDL巴拉巴拉。。有一天在鸿神的博客看到这个，嗯，如他所说，又可以装一下了。 EditTxt.setImeOptions， 使用EditText弹出软键盘时，修改回车键的显示内容(一直很讨厌用回车键来交互，所以之前一直不知道这玩意儿) java8中新增的LocalDate和LocalTime接口，Date虽然是个万能接口，但是它真的不好用，有了这俩，终于可以愉快的处理日期时间了。 WeakHashMap，直接使用HashMap有时候会带来内存溢出的风险，使用WaekHashMap实例化Map。当使用者不再有对象引用的时候，WeakHashMap将自动被移除对应Key值的对象。 使用SnackBar的时候，不要使用view.getRootView()作为snackbar的view,华为荣耀7 会出问题。 设置TextView单行显示的时候不要用Lines=1,而要用singleLine=”true” ,因为魅族部分手机在设置Lines=1的时候，然后TextView的值全为数字的时候， 你就会懵逼了. TouchDelegate可用于更改View的触摸区域。场景：比如在RecyclerView的ItemView里包含了CheckBox组件, 然后想实现点击ItemView的时候，也可以触发CheckBox，就可以使用此类 ArgbEvaluator可用于计算不同颜色值之间的插值，配合ValueAnimator.ofObject或者ViewPager.PageTransformer使用，可以实现不同颜色之间的平滑过渡。 Palette可用于提取一张图片的颜色。 ViewDragHelper,做过自定义ViewGroup的童鞋都应该知道这个东西吧，用来处理触摸事件的神器，妈妈再也不用担心我自定义控件了。 PageTransformer用于定义ViewPager页面切换时的动画效果（淡入淡出，放大缩小神马的…）官方有例子，直接看吧。 Formatter.formatFileSize() 这个方法会格式化数据的大小，根据输入的字节大小，返回 B KB MB GB 等等（最大支持到 PB）。当然要注意的是输入的最大值是 Long.MAX_VALUE. Activity.recreate重新创建Activity。有什么用呢？可以在程序更换主题后，立马刷新当前Activity，而不会有明显的重启Activity的动画。 View.getContext顾名思义，就不用解释了吧…以前在写RecyclerView的Adapter的时候，为了使用LayoutInflater，经常傻乎乎地在构造函数中传入一个外部的context….是不是只有我不知道而已（笑cry脸） View.post方便在非UI线程对界面进行修改，与Handler的作用类似。并且由于post的Runnable会保证在该View绘制完成的前提下才调用，所以一般也可以用于获取View的宽高。 Activity.runOnUiThread与View.post类似，方便在非UI线程中对界面进行修改。 Fragment在配合PagerAdapter使用的时候可以重写setUserVisibleHintFragment()方法，然后根据参数的布尔值（true的话表示当前Fragment对用户可见),来执行一些逻辑。 android:animateLayoutChanges 这是一个非常酷炫的属性。在父布局加上 android:animateLayoutChanges=”true” 后，如果触发了layout方法（比如它的子View设置为GONE），系统就会自动帮你加上布局改变时的动画特效！！ android:clipToPadding 设置父view是否允许其子view在它的padding（这里指的是父View的padding）中绘制。是不是有点绕？举个实际场景吧：假如有个ListView，我们想要在初始位置时，第一项Item离顶部有10dp的距离，就可以在ListView的布局中加入android:clipToPadding=”false” android:paddingTop=”10dp”即可。是不是很方便呢？ rv 的 Layoutmanager 可以直接申明在 xml 中,具体代码可查看RecyclerView.createLayoutManager 方法. RecyclerView在23.2.+的版本中新增了自动测量的功能，由于新增了自动测量，那么它的item的根布局在需要测量的方向上就不能写match_parent了，需要改成wrap_content getParent().requestDisallowInterceptTouchEvent(true);剥夺父view对touch事件的处理权，谁用谁知道。 Canvas中clipRect、clipPath和clipRegion剪切区域的API。 GradientDrawable 有个阴影效果还不错，以为是切的图片，一看代码，什么鬼= =！ 有朋友提到了在自定义View时有些方法在开启硬件加速的时候没有效果的问题，在API16之后确实有很多方法不支持硬件加速，通常我们关闭硬件加速都是在清单文件中通过&lt;application android:hardwareAccelerated=”false” …&gt;，其实android也提供了针对特定View关闭硬件加速的方法,调用View.setLayerType(View.LAYER_TYPE_SOFTWARE, null);即可。 PointF，graphics包中的一个类，我们经常见到在处理Touch事件的时候分别定义一个downX，一个downY用来存储一个坐标，如果坐标少还好，如果要记录的坐标过多那代码就不好看了。用PointF(float x, float y);来描述一个坐标点会清楚很多。 StateListDrawable，定义Selector通常的办法都是xml文件，但是有的时候我们的图片资源可能是从服务器动态获取的，比如很多app所谓的皮肤，这种时候就只能通StateListDrawable来完成了，各种addState即可。 android:duplicateParentState=”true”，让子View跟随其Parent的状态，如pressed等。常见的使用场景是某些时候一个按钮很小，我们想要扩大其点击区域的时候通常会再给其包裹一层布局，将点击事件写到Parent上，这时候如果希望被包裹按钮的点击效果对应的Selector继续生效的话，这时候duplicateParentState就派上用场了。 ViewConfiguration.getScaledTouchSlop();触发移动事件的最小距离，自定义View处理touch事件的时候，有的时候需要判断用户是否真的存在movie，系统提供了这样的方法。 ViewStub，有的时候一块区域需要根据情况显示不同的布局，通常我们都会通过setVisibility的方法来显示和隐藏不同的布局，但是这样默认是全部加载的，用ViewStub可以更好的提升性能。 onTrimMemory，在Activity中重写此方法，会在内存紧张的时候回调（支持多个级别），便于我们主动的进行资源释放，避免OOM。 TextView.setCompoundDrawablePadding，代码设置TextView的drawable padding。 ImageSwitcher，可以用来做图片切换的一个类，类似于幻灯片。 在自定义控件的时候,能用drawable来绘制圆，或者其他样式的时候,尽量用drawable,因为drawable的效果要远胜于canvas.drawXXX(). 如果想要自定义View支持SwipeRefreshLayout，只需要声明并实现ScrollingView接口即可，RecyclerView和NestedScrollView已经实现此接口。 AtomicFile——通过使用备份文件进行文件的原子化操作。这个知识点之前我也写过，不过最好还是有出一个官方的版本比较好。 DatabaseUtils——一个包含各种数据库操作的使用工具。 Activity.isChangingConfigurations ()——如果在 Activity 中 configuration 会经常改变的话，使用这个方法就可以不用手动做保存状态的工作了。 SearchRecentSuggestionsProvider——可以创建最近提示效果的 provider，是一个简单快速的方法。 android:clipChildren (ViewGroup)——如果此属性设置为不可用，那么 ViewGroup 的子 View 在绘制的时候会超出它的范围，在做动画的时候需要用到。 android:fillViewport (ScrollView)——在这片文章中有详细介绍文章链接，可以解决在 ScrollView 中当内容不足的时候填不满屏幕的问题。 android:tileMode (BitmapDrawable)——可以指定图片使用重复填充的模式。 android:enterFadeDuration/android:exitFadeDuration (Drawables)——此属性在 Drawable 具有多种状态的时候，可以定义它展示前的淡入淡出效果。 Log.wtf()的意思是What a Terrible Failure,而不是What The Fuck! 使用RenderScript虚化图片效果。如果你的app的minSDK为16或者更低，你需要使用support模式，因为很多方法都是在API 17之后添加的。renderscriptTargetApi最高到23，但是你应该把它设置到能保持脚本中使用到的功能完整的最低API。如果你想在support模式下target API 21+你必须使用gradle-plugin 2.1.0 和 buildToolsVersion “23.0.3” 或者以上。需要在gradle中添加renderscriptTargetApi 18,renderscriptSupportModeEnabled true 这两句话 123456789101112131415161718public static Bitmap blurBitmap(Context context, Bitmap src, int radius) &#123; Bitmap dest = src.copy(src.getConfig(), true); RenderScript rs = RenderScript.create(context); Allocation allocation = Allocation.createFromBitmap(rs, src); Type t = allocation.getType(); Allocation blurredAllocation = Allocation.createTyped(rs, t); ScriptIntrinsicBlur blurScript = ScriptIntrinsicBlur.create(rs, Element.U8_4(rs)); blurScript.setRadius(radius); blurScript.setInput(allocation); blurScript.forEach(blurredAllocation); blurredAllocation.copyTo(dest); allocation.destroy(); blurredAllocation.destroy(); blurScript.destroy(); t.destroy(); rs.destroy(); return dest; &#125; 如果想把一个view保存为Bitmap，正常情况下用第一种方法就可以了，但是如果是ScrollView，则必须采用第二种方法。 当Activity LauncherMode 为singleTask singleInstance时,使用startActivityForResult会立马返回，不能正常调用。具体请看http://www.360doc.com/content/15/0123/14/12928831_443085580.shtml 当PopupWindow中有EditText控件时,因为Popupwindow 默认没有获取到焦点，需要手动设置焦点，这样子view才能获取到事件的监听。所以你需要在创建完popwindow后设置他的焦点，popupWindow.setFocusable(true);就可以让EditText获取焦点。 PopupWindow默认点击外部的时候不消失，需要对PopupWindow 设置一个背景图popWindow.setBackgroundDrawable(new BitmapDrawable());要创建一个空对象，设置为null是不行的，或者就创建一个全透明的背景图。 android中的序列化官方推荐Parceble,其实Parceble最好用于内存之间数据的交换,如果要把数据写入硬盘的话,推荐实现Serializable tools标签可以很好的帮助开发者实时预览xml的效果,通过tools:background可以预览控件所占的控件,tools:visibility可以把一个gone的控件在预览的时候展示出来,并且运行以后tools标签的内容不会展示出来.例如: 123456&lt;TextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" tools:background=\"#FF00FF\" tools:visibility=\"visible\" tools:text=\"这段话只在预览时能看到,运行以后就看不到了\" /&gt; android studio 2.1起已经支持jdk8了,使用的时候要在gradle中加上,需要把buildToolsVersion更新到24以上的版本 12345678910111213android &#123; defaultConfig &#123; ... jackOptions &#123; enabled true &#125; &#125; ... compileOptions &#123; targetCompatibility 1.8 sourceCompatibility 1.8 &#125;&#125; 6.0之后getResources().getColor()方法被废弃了，大家可以用ContextCompat.getColor(context, R.color.color_name)替换，ContextCompat 是 v4 包里的，请放心使用，另外还有getDrawable()等方法 图片的资源文件官方推荐只把launcher放在mipmap文件夹下面，而app用到的资源文件建议放在drawable下面。 SharedPreference.Editor的apply是异步操作，不会返回成功的状态，而commit是同步操作，因此，在多个并发的提交commit的时候，他们会等待正在处理的commit保存到磁盘后再操作下一个数据，从而降低了效率。 如果你在 manifest 中把一个 activity 设置成 android:windowSoftInputMode=”adjustResize”，那么 ScrollView（或者其它可伸缩的 ViewGroups）会缩小，从而为软键盘腾出空间。但是，如果你在 activity 的主题中设置了 android:windowFullscreen=”true”，那么 ScrollView 不会缩小。这是因为该属性强制 ScrollView 全屏显示。然而在主题中设置 android:fitsSystemWindows=”false” 也会导致 adjustResize 不起作用 在Android 4.0以后，在Manifest.xml中静态注册的广播，程序安装后必须启动一次才能接收到广播，比如你的应用监听开机启动的广播，必须要你的程序被运行过才能监听到 Activity的onDestory方法调用时机是不确定的（有时候离开界面很久之后才会调用onDestory方法），应该避免指望通过onDestory方法去释放与Activity相关的资源，否则会导致一些随机bug 2.X时代Bitmap对象虽然存储在堆内存中，但是用了一个byte数组存储其像素信息。通过计数器来记录该像素信息被引用的个数。有人认为这个byte数组在native堆中，但事实上它也在堆中。只有在使用者调用recycle()后，Bitmap对象才会释放像素信息，才会在失去引用后被垃圾回收机制销毁。再加上DVM的heap size有严格的阀值，所以在使用大量图片资源的时候，及其容易发生OOM。解决办法一般都是，用一个哈希表存储Bitmap对象的软引用，作为内存缓存，并在适当时机掉用其recycle()。3.0以上版本Bitmap对象可以通过垃圾回收机制完全销毁，理论上不用再调用recycle()。 .gitignore只能忽略那些原来没有被track的文件，如果某些文件已经被纳入了版本管理中，则修改.gitignore是无效的。那么解决方法就是先把本地缓存删除（改变成未track状态），然后再提交： 123git rm -r --cached .git add .git commit -m &apos;update .gitignore&apos; 时间戳请使用long或者String类型接收，遇到的坑,由于项目中的model好多都是通过GsonFormat生成的，服务器给的json中的时间戳都是10位的，导致了GsonFormat自动解析成了int, 当测试人员选择时间为2100年的时候时间戳是4开头的十位 用int类型接收越界了,导致报错 为你的app添加默认布局样式,比如:每一个控件都需要写width和height属性,然而很多的控件的宽高属性都是wrap_content,那么我们可以通过在style文件添加如下样式: 1234&lt;style name=&quot;Theme.YourApp&quot; parent=&quot;android:style/Theme.Light&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;wrap_content&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;wrap_content&lt;/item&gt;&lt;/style&gt; 这样,控件的宽高默认都是wrap_content样式啦。 在style中写的样式通过视同parent标签来扩展你的样式,这样更高效,这里官方的建议是，只有Android自带的style才用parent标签，如果是自定义的style，直接用.符号来连接就行。如Fill.Height。 1234567&lt;style name=&quot;Fill&quot;&gt; &lt;item name=&quot;android:layout_width&quot;&gt;fill_parent&lt;/item&gt; &lt;item name=&quot;android:layout_height&quot;&gt;fill_parent&lt;/item&gt;&lt;/style&gt;&lt;style name=&quot;Fill.Height&quot; &gt; &lt;item name=&quot;android:orientation&quot;&gt;vertical&lt;/item&gt;&lt;/style&gt; Android上的应用切换按钮列出的其实不是应用而是Task，所以你会看到有的应用在切换视图里有多个任务。如果你的应用中有逻辑上相互独立的部分，或者想在多窗口环境下并排显示应用的两个不同部分，这种情况就适合多任务了。使用manifest属性(静态)或者 intent flags(动态)可以实现这一点,详见视频: http://v.youku.com/v_show/id_XMTU2ODk4NDg2NA==.html?f=26587294 当app的theme用的是NoActionBar,但是在layout中仍然用到toolbar的时候,不要在style文件中加fitsSystemWindows属性,而是在用到toolbar的layout最外层加fitsSystemWindows,否则当你使用EditText,在小米手机上长按EditText调出系统粘贴功能的时候,粘贴的layout的布局会错位. 当WebView与ScrollView嵌套使用,并且WebView有字体放大缩小的功能时,当切换webview的字体后,webview的高度并不能很好的计算出来,这时候可以通过注入的方式,让js算出高度,经测试,这样是最可靠的,代码地址:http://blog.csdn.net/jys1115/article/details/43525979 Context类中的createPackageContext(packageName, flags)方法，可用来获取指定包名应用程序的Context对象。 TextView类的setKeyListener(KeyListener)方法；其中DigitsKeyListener类，使用getInstance(String accepted)方法即可指定EditText可输入字符集； View类中的getLocationInWindow(int[])方法和getLocationOnScreen(int[])方法，获取View在窗口/屏幕中的位置； Context.getCacheDir() - 可以获取到app默认的缓存路径。 StaticLayout 在自定义控件绘制文本的时候很有用。 Android中的四大组件千万不要通过new的方式创建出来。 测试app的时候,我们大都想要将debug和release版本同时安装到手机里,可以通过在gradle中修改applicationid来实现: 1234567891011android &#123; buildTypes &#123; debug &#123; applicationIdSuffix &apos;.debug&apos; versionNameSuffix &apos;-DEBUG&apos; &#125; release &#123; //... &#125; &#125;&#125; 在大多数的登陆界面中，都提供了用户是否让密码可见的选项，Support Library 24.2.0 提供了官方的实现，TextInputLayout 中添加了 passwordToggleEnabled 属性来开启此功能，并且可以通过 passwordToggleDrawable 设置图标。(摘自:Android笔记的微博) 同样,在Support Library 24.2.0中增加RecyclerView 在快速滚动时的回调接口,SnapHelper是官方的一个实现OnFlingListener 的 一个抽象类,LinearSnapHelper 则是一个完整的实现.LinearSnapHelper默认实现的功能是类似ViewPager,在滚动结束后,会选择列表某一条居中展示(这里有开始位置展示,或者结束位置显示点我).例如: 1234LinearLayoutManager linearLayoutManager = new LinearLayoutManager(getContext(), LinearLayoutManager.HORIZONTAL, false);recyclerView.setLayoutManager(linearLayoutManager);LinearSnapHelper snapHelper = new LinearSnapHelper();snapHelper.attachToRecyclerView(recyclerView); Android中推荐使用的数据结构 : 1234567ArrayMap&lt;K,V&gt; in place of HashMap&lt;K,V&gt; ArraySet&lt;K,V&gt; in place of HashSet&lt;K,V&gt; SparseArray&lt;V&gt; in place of HashMap&lt;Integer,V&gt; SparseBooleanArray in place of HashMap&lt;Integer,Boolean&gt; SparseIntArray in place of HashMap&lt;Integer,Integer&gt; SparseLongArray in place of HashMap&lt;Integer,Long&gt; LongSparseArray&lt;V&gt; in place of HashMap&lt;Long,V&gt; 生成GUID(由于java中只能生成UUID,所以这里要转换一下): 1return UUID.randomUUID().toString().toUpperCase().replaceAll(&quot;-&quot;, &quot;&quot;); 业务场景：需要定时后台扫描数据库，上传本地照片至云端，定时任务采用何种模式: 1.Handler或者Timer定时一般为秒级别的任务,Timer会启动额外线程，而Handler可以不用。2.无论是Handler还是Timer都需要依赖于进程存活3.利用Handler实现定时任务的类:HandlerTimer4.如果时间较长，则需要使用AlarmManager5.另外，我们对于这种业务应该优先考虑是否可以基于事件通知。6.如果是加入媒体库的文件，我们可以使用registerContentObserver监听媒体库文件变化。 把Activity作为参数传给一个静态方法,会影响这个Activity的正常销毁吗? 1.内存泄露与方法是否是静态与否无关，与内部的方法体实现有关系。2.内存泄露可以简单理解成：生命周期长的对象不正确持有了持有了生命周期短的对象，导致生命周期短的对象无法回收。3.比如Activity实例被Application对象持有，Activity实例被静态变量持有。 在assets文件夹下存放单个文件的大小不能超过1M，如果读取超过1M的文件会报 “Data exceeds UNCOMPRESS_DATA_MAX (1314625 vs 1048576)” 的IOException。如果一定要存储，可以分割文件，再去合并文件 在Android library中不能使用switch-case语句访问资源ID，因为case分支后面跟的参数必须是常数，而library中的每一个资源ID都没有被声明为final。 当前Activity的onPause方法执行结束后才会执行下一个Activity的onCreate方法，所以在onPause方法中不适合做耗时较长的工作，这会影响到页面之间的跳转效率； 不要通过Bundle传递大块的数据，否则会报TransactionTooLargeException异常 （AnimationDrawable在Android5.0及以上的版本已有明显的优化）尽量不要使用AnimationDrawable，它在初始化的时候就将所有图片加载到内存中，特别占内存，并且还不能释放，释放之后下次进入再次加载时会报错； .9图不能通过tinypng压缩，不然会有问题； genymotion模拟器快是因为它是基于x86架构的，如果你的应用中用到了so，但没有x86架构的so，只能放弃使用它；Android Studio的模拟器也一样； 使用Toast时，建议定义一个全局的Toast对象，这样可以避免连续显示Toast时不能取消上一次Toast消息的情况（如果你有连续弹出Toast的情况，避免使用Toast.makeText）； 尽量避免给window和Activity同时都设置了背景，这样会造成过渡绘制，可以通过在给Activity设置主题时，去掉windowBackground背景的方式减少一层过渡绘制，有时候为了避免进入Activity时会黑屏或者白屏（和主题有关），会在给Activity设置主题的时候给window设置背景，如果这种情况下给Activity也设置了背景，是会增加一倍内存的： 1&lt;item name=&quot;android:windowBackground&quot;&gt;@null&lt;/item&gt; 设置中更改字体为特大之类的会影响到app的字体样式，解决方法有: 1.将所有字体使用的单位换成dp，不再使用sp.这样不是很靠谱，并不是所有人都能做到。 2. 12345678Configuration configuration = getResources().getConfiguration(); configuration.fontScale = (float) 1; //0.85 小, 1 标准大小, 1.15 大，1.3 超大 ，1.45 特大 DisplayMetrics metrics = new DisplayMetrics(); getWindowManager().getDefaultDisplay().getMetrics(metrics); metrics.scaledDensity = configuration.fontScale * metrics.density; getBaseContext().getResources().updateConfiguration(configuration, metrics); //（ps:dialog popupwindow 除外,这两种需要在控件中重新设置fontScale) Android中新引入的替代枚举的注解有IntDef和StringDef,这里以IntDef做例子说明一下. 1234567891011121314151617public class Colors &#123; @IntDef(&#123;RED, GREEN, YELLOW&#125;) //声明必要的int常量,使用@IntDef修饰LightColors,参数设置为待枚举的集合 @Retention(RetentionPolicy.SOURCE) //使用@Retention(RetentionPolicy.SOURCE)指定注解仅存在与源码中,不加入到class文件中 public @interface LightColors&#123;&#125; //声明一个注解为LightColors public static final int RED = 0; public static final int GREEN = 1; public static final int YELLOW = 2;&#125;//用法private void setColor(@Colors.LightColors int color) &#123; Log.d(&quot;MainActivity&quot;, &quot;setColor color=&quot; + color);&#125;//调用的该方法的时候setColor(Colors.GREEN); PathInterpolatorCompat 很方便的使用它来创建各种插值曲线，举个非常简单的例子： 123456Path path = new Path();path.cubicTo(0.2f, 0f, 0.1f, 1f, 0.5f, 1f);path.lineTo(1f, 1f);ObjectAnimator animator = ObjectAnimator.ofFloat(view, View.TRANSLATION_X, 500);animator.setInterpolator(PathInterpolatorCompat.create(path));animator.start(); 检测当前网络能否访问远程服务器(国内通过ping百度来检测) 1234567891011public static boolean isNetWorkAvailable(final Context context) &#123; try &#123; Runtime runtime = Runtime.getRuntime(); Process pingProcess = runtime.exec(&quot;/system/bin/ping -c 1 www.baidu.com&quot;); int exitCode = pingProcess.waitFor(); //0 代表连通，2代表不通 return (exitCode == 0); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return false; &#125; 拦截系统返回键(onBackPressed())，使App不退出，而是进入后台运行 1234@Override public void onBackPressed() &#123; moveTaskToBack(false); &#125; view.performClick() 自动调用 View 点击事件。通常按钮等控件只有在用户点击时才能触发其点击事件，该方法可以由某些特殊条件触发模拟用户点击行为。类似的还有 performLongClick() 方法。 Linkify.addLinks() 通过 android:autoLink 属性可以为其添加诸如 web、phone 等固定模版的超链接点击事件。但毕竟系统模版有限，而利用 Linkify.addLinks() 方法可以添加一些应用内自定义模版，比如新浪微博中的 “@XXX” 格式的超链接跳转等，都可以通过自定义正则表达式来匹配处理。 getWindow().addFlags(WindowManager.LayoutParams.FLAG_SECURE) 设置安全窗口，禁用系统截屏。防止 App 中的一些界面被截屏，并显示在其他设备中造成信息泄漏。（常见手机设备系统截屏操作方式为：同时按下电源键和音量键。） activity生命周期(Ref Link) RecyclerView 调用notifyItem()的时候会有默认的动画,可以通过调用((SimpleItemAnimator)recyclerView.getItemAnimator()).setSupportsChangeAnimations(false);来去掉默认动画.以防止出现闪屏的问题 Toolbar 使用的主题如果 parent=”ThemeOverlay.AppCompat.Light”，只要改一下 @color/white 就可以使 OverflowButton 变为白色，同时点击它展开的菜单背景也可以是白的 Android View的生命周期示例图样。来自G+ +Arpit Mathur 当需要从资源文件中获取 html 并展示时，使用 Resource#getText() 而不是 Resource#getString()。当需要动态显示 HTML 时，使用 Html.fromHtml() 请看这里 JAVA中时间String转Timestamp 12345678910try &#123; DateFormat format = new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); format.setLenient(false); //要转换字符串 str_test 自定义的格式为 yyyy-mm-dd，可以改成你需要的格式 String str_test =&quot;2011-04-24&quot;; Timestamp ts = new Timestamp(format.parse(str_test).getTime()); System.out.println(ts.toString());&#125; catch (ParseException e) &#123;e.printStackTrace();&#125; 当Activity 继承 FragmentActivity的时候，调用startActivityForResult方法中传递的requestCode范围应该在0-65535范围内，否则会报”Can only use lower 16 bits for requestCode”异常。 Android有一个隐藏的类可以判断文本输入框内输入的是不是表情，这个类就是 android.text.Emoji类，它的isEmoji(int codePoint)方法可以直接判断出来是不是表情。这个类是隐藏的，如果要用到则需要将它拷贝出来。 布局中不得不使用ViewGroup 多重嵌套时，不要使用LinearLayout 嵌套，改用RelativeLayout，可以有效降低嵌套数。 不能使用ScrollView 包裹ListView/GridView/ExpandableListVIew;因为这样会把ListView 的所有Item 都加载到内存中，要消耗巨大的内存和cpu 去绘制图面。 不要通过Intent 在Android 基础组件之间传递大数据（binder transaction缓存为1MB），可能导致OOM。 在Application 的业务初始化代码加入进程判断，确保只在自己需要的进程初始化。特别是后台进程减少不必要的业务初始化。 将android:allowbackup 属性设置为false，防止adb backup 导出数据。 除非min API level &gt;=17，请注意addJavascriptInterface 的使用 12345说明：API level&gt;=17，允许js 被调用的函数必须以@JavascriptInterface 进行注解，因此不受影响； 对于API level &lt; 17，尽量不要使用addJavascriptInterface，如果一定要用，那么：1) 使用https 协议加载URL，使用证书校验，防止访问的页面被篡改挂马；2) 对加载URL 做白名单过滤、完整性校验等防止访问的页面被篡改；3) 如果加载本地html,应该会HTML 内置在APK 中，以及对HTML 页面进行完整性校验。 如何动态修改AlertDialog的Button样式, 1234567891011//监听Dialog的setOnShowListener方法dialog.setOnShowListener(new DialogInterface.OnShowListener() &#123; @Override public void onShow(final DialogInterface dialog) &#123; Button negativeButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_NEGATIVE); Button positiveButton = ((AlertDialog)dialog).getButton(DialogInterface.BUTTON_POSITIVE); negativeButton.invalidate(); positiveButton.invalidate(); &#125;&#125;);dialog.show(); 升级 RecycleView 版本到 25.1.0 及以上使用 Prefetch 功能，可参考 RecyclerView 数据预取。 如果 Item 高度是固定的话，可以使用 RecyclerView.setHasFixedSize(true); 来避免 requestLayout 浪费资源； 如果不要求动画，可以通过 ((SimpleItemAnimator) rv.getItemAnimator()).setSupportsChangeAnimations(false); 把默认动画关闭来提升效率。 通过 RecycleView.setItemViewCacheSize(size); 来加大 RecyclerView 的缓存，用空间换时间来提高滚动的流畅性。 如果多个 RecycledView 的 Adapter 是一样的，比如嵌套的 RecyclerView 中存在一样的 Adapter，可以通过设置 RecyclerView.setRecycledViewPool(pool); 来共用一个 RecycledViewPool。 对 ItemView 设置监听器，不要对每个 Item 都调用 addXxListener，应该大家公用一个 XxListener，根据 ID 来进行不同的操作，优化了对象的频繁创建带来的资源消耗。 通过 getExtraLayoutSpace 来增加 RecyclerView 预留的额外空间（显示范围之外，应该额外缓存的空间），如下所示 123456new LinearLayoutManager(this) &#123; @Override protected int getExtraLayoutSpace(RecyclerView.State state) &#123; return size; &#125;&#125;; WebView 在 API 21之后,写Cookie的时候默认禁止了跨域写cookie,需要通过代码,来设置开启跨域请求 123if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123; CookieManager.getInstance().setAcceptThirdPartyCookies(WebView, true); &#125; 使用IdleHandler,替代Handler.postDelay(),IdleHandler是在我们的onResume和measure, layout, draw这么message执行结束之后， 提供了他们执行完毕的回调. 看这里 1234567Looper.myQueue().addIdleHandler(new MessageQueue.IdleHandler() &#123; @Override public boolean queueIdle() &#123; //TODO... return false; &#125; &#125;); 在Multidex分包的时候,如果主dex过大, 5.0以下的机型可能会出现multidex installation failure错误,这时需要让主dex方法数小一点.,配置方法 123456789101112配置正常的multiDex库之后,在主模块的gradle文件添加如下代码:Android&#123; ...//其他代码 dexOptions &#123; javaMaxHeapSize &quot;4g&quot; preDexLibraries = false additionalParameters += &apos;--multi-dex&apos; additionalParameters += &apos;--set-max-idx-number=35000&apos;//(35000可根据自己的需求更改)来适配4.0-4.4一些低端机型，因为拆分的dex太大，这些低端机型加载不了dex additionalParameters += &apos;--minimal-main-dex&apos; &#125;&#125; 注意:在gradle版本3.1.0之后dex编译采用D8,可能会导致这种分包不成功。将gradle的版本降到3.0.0之后，分包成功。另外也可以采用gradle3.1.0或者以上的版本，然后将项目的gradle配置为android.enableD8=false //暂时关闭 即可 高版本android中，可以使用Application启动Activity并且不设置FLAG，但在低版本中必须要设置FLAG,所以建议大家使用application的context去startActivity的时候添加FLAG_ACTIVITY_NEW_TASK 不要滥用 1&lt;item name=&quot;android:windowIsTranslucent&quot;&gt;true&lt;/item&gt; 属性,切勿为app设置该属性,而仅针对具体的activity进行设置.公司有位开发为整个app设置了该属性,我们有个签名的横屏页面,其他是强制竖屏页面,有个需求是进入该竖屏页面后某些特殊原因需要自动跳转到签名页面,而跳转到横屏页面后导致整个app的所有页面生命周期全部重新走了一遍,该签名页面无限循环打开. 当你在多module中使用了多个三方库,而这些三方库使用了多个版本的Recyclerview,我们可以通过exclude group: ‘com.android.support’, module: ‘recyclerview-v7’ 来实现使用项目中的版本,但是这样造成的问题是每添加一个库就得写一下exclude,这样很不友好,而gradle为我们提供了依赖替换规则.如下代码实现了全局替换recyclerview的版本12345678910configurations.all &#123; resolutionStrategy.eachDependency &#123; DependencyResolveDetails details -&gt; def requested = details.requested if (requested.group == &apos;com.android.support&apos;) &#123; if (requested.name.startsWith(&quot;recyclerview-v7&quot;)) &#123; details.useVersion &quot;28.0.0&quot; &#125; &#125; &#125;&#125; 当然,依赖替换规则还允许我们在本地库和远程库之间进行切换. 1234567configurations.all &#123; resolutionStrategy.dependencySubstitution &#123; if (useLocal) &#123; //如果使用本地仓库,系统将会把org.utils:api依赖替换为本地api的project substitute module(&quot;org.utils:api&quot;) because &quot;we work with the unreleased development version&quot; with project(&quot;:api&quot;) &#125; &#125;&#125; 摘自如下地址","categories":[{"name":"github","slug":"github","permalink":"http://zhangyongfa888.site/categories/github/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"滴滴插件化实践","slug":"滴滴插件化实践","date":"2019-07-30T11:05:00.000Z","updated":"2020-03-04T07:52:54.765Z","comments":true,"path":"2019/07/30/滴滴插件化实践/","link":"","permalink":"http://zhangyongfa888.site/2019/07/30/滴滴插件化实践/","excerpt":"","text":"工程目录 paste image 宿主配置apply plugin: &apos;com.android.application&apos; apply plugin: &apos;com.didi.virtualapk.host&apos; //*** dependencies{ implementation &apos;***.huozhu:core:&apos; + rootProject.ext.versions.core implementation &apos;com.didi.virtualapk:core:0.9.8&apos; }公共库配置因为涉及到插件的下载加载以及之间的跳转 所以封装一个下载加载的公共类 dependencies{ implementation &apos;com.didi.virtualapk:core:0.9.8&apos; }插件配置apply plugin: &apos;com.didi.virtualapk.plugin&apos; virtualApk { packageId = 0x75 targetHost = &apos;../app&apos; applyHostMapping = true forceUseHostDependences = true }插件中的gradle.properties android.useDexArchive=false项目配置build.gradle中 buildscript { repositories { google() jcenter() } dependencies { classpath &apos;com.android.tools.build:gradle:3.1.0&apos; classpath &apos;com.didi.virtualapk:gradle:0.9.8.6&apos; } }插件加载并跳转 loadPlugin(&quot;plugin_mywallet&quot;, new LoadPlugin() { @Override public void plugin(LoadedPlugin plugin) { startActivity(plugin.getLaunchIntent()); } });插件之间的跳转和传参loadPlugin(&quot;plugin_orderlist&quot;, new LoadPlugin() { @Override public void plugin(LoadedPlugin loadedPlugin) { try { Intent intent = new Intent(context,Class.forName(&quot;***.plugin_orderlist.PluginOrderDetailsActivity&quot;)); intent.putExtra(&quot;extra_orderid&quot;, orderCode); startActivity(intent); } catch (Exception e) { e.printStackTrace(); } } });其他配置基地址 基地址封装在公共库 并能够在宿主中修改,插件中之间调用基地址即可区分正式和开发环境 public static String BaseUrl = &quot;https://tess.cisdom.com.cn/public/index.php/apient/&quot;; public static String BaseDownload = &quot;http://192.168.50.7/wx/&quot;; public static void setBaseUrl(String baseUrl) { BaseUrl = baseUrl; } public static void setBaseDownload(String baseDownload) { BaseDownload = baseDownload; }公共库打包aar见 https://blog.csdn.net/u013325929/article/details/50563571 遇到的问题插件包需要签名插件包生成插件找不到入口函数 -&gt;在清单文件加入application","categories":[{"name":"插件化","slug":"插件化","permalink":"http://zhangyongfa888.site/categories/插件化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"滴滴插件化","slug":"滴滴插件化","date":"2019-07-12T00:56:00.000Z","updated":"2019-09-03T00:25:09.957Z","comments":true,"path":"2019/07/12/滴滴插件化/","link":"","permalink":"http://zhangyongfa888.site/2019/07/12/滴滴插件化/","excerpt":"","text":"插件开发规范 V1.0.1由于VirtualAPK本身的特性，插件需要遵循以下规范： 1.宿主配置Project build.gradle classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos; `&lt;/pre&gt; Module build.gradle &lt;pre&gt;`apply plugin: &apos;com.didi.virtualapk.host&apos; compile &apos;com.didi.virtualapk:core:0.9.0&apos; `&lt;/pre&gt;2.插件配置插件 Project build.gradle 文件中，需要加入如下引用： classpath &apos;com.didi.virtualapk:gradle:0.9.0&apos;注：版本号应与宿主版本号相同 插件 Module build.gradle 文件中，需要加入如下引用： apply plugin: &apos;com.didi.virtualapk.plugin&apos; virtualApk { packageId = 0x6f // 插件资源id，避免资源id冲突 targetHost=&apos;../host/app&apos;// 宿主工程的路径 applyHostMapping = true // 插件编译时是否启用应用宿主的apply mapping 默认为true }3.构建环境 官方构建环境建议： 框架强依赖构建环境。如果更换构建环境，可能会出现问题 Gradle 2.14.1 com.android.tools.build 2.1.3 即：插件 Project build.gradle 文件中 classpath &apos;com.android.tools.build:gradle:2.1.3&apos; 插件gradle-wrapper.properties文件中： distributionUrl=https\\://services.gradle.org/distributions/gradle-2.14.1-all.zip4.打包 插件打包时，应当用命令 ./gradlew clen assemblePlugin 或者 gradle clean assemblePlugin 进行打包 输出位置为：app\\build\\outputs\\plugin\\release 由于插件 Module build.gradle 文件中设置了如下参数， targetHost=’../host/app’// 宿主工程的路径 故，打包时的文件结构应为： 即：HOST 应与插件在同一目录下编译 插件调用宿主 将宿主中需要被插件调用的 模块、类，下沉到公共组件库。 即：以aar包的形式。分别被插件，组件依赖即可。 aar 引入模板： compile(group:&apos;test&apos;, name: &apos;app-release&apos;, version:&apos;0.2&apos;, ext: &apos;aar&apos;)插件中包含 so 包需特别注意如果插件中包含如百度地图等 so 包，由于部分第三方库存在的包名校验机制，需要注册一份新的 secretKey 写到宿主中,这个不难理解，因为运行时包名是宿主的包名，不能通过校验。 资源链接我的踩坑记录 https://blog.csdn.net/a31081314/article/details/82661009 我的demo 地址 https://github.com/CD3108/VirtualAPK 源码地址 https://github.com/didi/VirtualAPK 详细框架接入 https://www.jianshu.com/p/013510c19391 四大组件加载过程 https://mp.weixin.qq.com/s?__biz=MzAxMTI4MTkwNQ==&amp;mid=2650823488&amp;idx=1&amp;sn=2976c8ddc0c206149b14c527260f7766&amp;chksm=80b78fdeb7c006c8a9585db794c51e799049ec50d23c4d738c78d77454f6b0291227a00e2def&amp;mpshare=1&amp;scene=1&amp;srcid=0712oTUswGWi172UK0Azpg4i&amp;key=8652b956ca1971a47b1e263b435230c7469d30646ddbe6ce2fb781033d6eba5215c9fd7e5eaf0bd73dd5da279b32dd901261d5e55bf32997bc333ad8a059e095e2193a5baa805447fc49cd315fca4404&amp;ascene=0&amp;uin=MTI0NjM4NTEyMA%3D%3D&amp;devicetype=iMac+MacBookPro11%2C4+OSX+OSX+10.11.1+build(15B42)&amp;version=12010110&amp;nettype=WIFI&amp;fontScale=100&amp;pass_ticket=mswE9bS3QeCxTOoepaUWh9VXHxeYMosdkHkAydyR09JHQkVe%2BAJHCCnPQrRpBfQN 资源加载过程 https://www.notion.so/VirtualAPK-1fce1a910c424937acde9528d2acd537 来自VirtualAPK开发群 点击链接加入群聊【VirtualAPK】：","categories":[{"name":"插件化","slug":"插件化","permalink":"http://zhangyongfa888.site/categories/插件化/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"Markdown基本语法","slug":"Markdown基本语法","date":"2019-07-10T06:33:00.000Z","updated":"2020-03-04T07:52:54.762Z","comments":true,"path":"2019/07/10/Markdown基本语法/","link":"","permalink":"http://zhangyongfa888.site/2019/07/10/Markdown基本语法/","excerpt":"","text":"Markdown基本语法简介Markdown 是一种_轻量级标记语言_，它允许人们使用易读易写的纯文本格式编写文档。Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。Markdown 编写的文档后缀为.md , .markdown。 Markdown 标题使用 # 号标记使用 # 号可表示 1-6 级标题，一级标题对应一个 # 号，二级标题对应两个 # 号，以此类推。如下： # 一级标题 ## 二级标题 ### 三级标题 #### 四级标题 ##### 五级标题 ###### 六级标题显示效果一级标题二级标题三级标题四级标题五级标题六级标题使用-/=标记我展示的是一级标题 ================= 我展示的是二级标题 -----------------显示效果我展示的是一级标题我展示的是二级标题Markdown 区块&gt; 最外层 &gt; &gt; 第一层嵌套 &gt; &gt; &gt; 第二层嵌套显示效果 最外层 第一层嵌套 第二层嵌套 Markdown 代码 printf() 函数 代码区块使用 4 个空格或者一个制表符（Tab 键）。printf() //tab键 Markdown 链接[链接名称](http://www.baidu.com) 或者 &lt;http://www.baidu.com&gt; 链接名称 或者 http://www.baidu.com Markdown 图片Markdown 图片语法格式如下： ![alt 属性文本](图片地址) {% image 图片地址 'alt 属性文本' '可选标题' %} example: ![RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png) [RUNOOB 图标](http://static.runoob.com/images/runoob-logo.png &quot;RUNOOB&quot;) RUNOOB Markdown 表格Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。 语法格式如下： | 表头 | 表头 | | ---- | ---- | | 单元格 | 单元格 | | 单元格 | 单元格 | 显示如下： 表头 表头 单元格 单元格 单元格 单元格 对齐方式 -: 设置内容和标题栏居右对齐 :- 设置内容和标题栏居左对齐 :-: 设置内容和标题栏居中对齐| 左对齐 | 右对齐 | 居中对齐 | | :-----| ----: | :----: | | 单元格 | 单元格 | 单元格 | | 单元格 | 单元格 | 单元格 | 左对齐 右对齐 居中对齐 单元格 单元格 单元格 单元格 单元格 单元格 参考 菜鸟教程 整理","categories":[{"name":"语法","slug":"语法","permalink":"http://zhangyongfa888.site/categories/语法/"}],"tags":[{"name":"MarkDown","slug":"MarkDown","permalink":"http://zhangyongfa888.site/tags/MarkDown/"}],"author":"zhangyognfa"},{"title":"Android Q 功能和 API","slug":"Android-Q-功能和-API","date":"2019-07-10T05:41:00.000Z","updated":"2020-03-04T07:52:54.761Z","comments":true,"path":"2019/07/10/Android-Q-功能和-API/","link":"","permalink":"http://zhangyongfa888.site/2019/07/10/Android-Q-功能和-API/","excerpt":"","text":"Android Q 功能和 APIAndroid Q 为用户和开发者引入了强大的新功能。本文重点介绍面向开发者的新功能。 要了解新版 API，请阅读 API 差异报告或访问 Android API 参考文档。为醒目起见，将突出显示新版 API。此外，请务必查阅 Android Q 行为变更（针对以 Android Q 为目标平台的应用和所有应用）以及隐私权变更，以了解平台变更可能给您的应用带来哪些方面的影响。 安全增强功能Android Q 引入了若干安全功能，详见以下各节摘要说明： 改进了生物识别身份验证对话框Android Q 对 Android 9 中增加的统一生物识别身份验证对话框进行了以下改进： 指定用户确认要求您现在可以提供一个提示，以告知系统在用户使用隐式生物识别模式完成身份验证后无需要求用户进行确认。例如，您可以告知系统，在用户使用面孔身份验证完成身份验证后无需进一步确认。 默认情况下，系统会要求用户进行确认。通常，用户希望确认敏感或高风险的操作（例如，购买商品）。但是，如果您的应用存在某些低风险操作，您可以将 false 传递到 setConfirmationRequired() 方法，以此来提供不要求用户确认的提示。由于此标记作为提示传递到系统，因此如果用户更改了针对生物识别身份验证的系统设置，则系统可能会忽略相应的值。 无需用户确认的面孔身份验证示例。 paste image 图 1. 无需用户确认的面孔身份验证 要求用户确认的面孔身份验证示例。 paste image 图 2. 需要用户确认的面孔身份验证 改进了对设备凭据的回退支持您现在可以告知系统，如果用户因某种原因而无法使用其生物识别输入设备进行身份验证，则可以使用设备 PIN 码、图案或密码来进行身份验证。要启用此回退支持，请使用 setDeviceCredentialAllowed() 方法。 如果您的应用目前使用 createConfirmDeviceCredentialIntent() 回退到设备凭据，请改为使用新方法。 检查设备的生物识别功能现在，您可以先通过使用 BiometricManager 类中的 canAuthenticate() 方法，检查设备是否支持生物识别身份验证，然后再调用 BiometricPrompt。 直接从 APK 运行嵌入式 DEX 代码您现在可以告知平台直接从应用的 APK 文件中运行嵌入式 DEX 代码。如果攻击者曾设法篡改了设备上本地编译的代码，则此选项有助于防止此类攻击。 注意：启用此功能可能会影响应用的性能，因为在应用启动时 ART 必须使用 JIT 编译器（而不是读取提前编译好的原生代码）。我们建议您先测试应用性能，然后再决定是否在已发布的应用中启用此功能。要启用此功能，请在应用清单文件的 元素中将 android:useEmbeddedDex 属性的值设为 true。您还必须编译一个 APK，其中要包含 ART 可以直接访问的未压缩 DEX 代码。将以下选项添加到 Gradle 或 Bazel 配置文件，以编译包含未压缩 DEX 代码的 APK： Gradle aaptOptions { noCompress ‘dex’ } Bazel android_binary( ..., nocompress_extensions = [“.dex”], )TLS 1.3 支持现在，平台的 TLS 实现支持 TLS 1.3。TLS 1.3 是 TLS 标准的主要修订版本，它提升了性能和安全性。我们的基准测试数据表明，与 TLS 1.2 相比，使用 TLS 1.3 可以将建立安全连接的速度提高 40%。 默认情况下，系统会为所有 TLS 连接启用 TLS 1.3。您可以通过调用 SSLContext.getInstance(“TLSv1.2”) 来获取已停用 TLS 1.3 的 SSLContext。您还可以对相关对象调用 setEnabledProtocols()，从而为每个连接启用或停用协议版本。 以下是有关 TLS 1.3 实现的一些重要的详细信息： TLS 1.3 加密套件不可自定义。在启用 TLS 1.3 后，受支持的 TLS 1.3 加密套件会始终保持启用状态，并且系统会忽略所有试图通过调用 setEnabledCipherSuites() 将其停用的行为。在协商 TLS 1.3 时，系统会在将会话添加到会话缓存之前调用 HandshakeCompletedListeners（这与 TLS 1.2 和之前的其他版本不同）。SSLEngine 实例会在之前原本会抛出 SSLHandshakeException 的部分情况下抛出 SSLProtocolException。不支持 0-RTT 模式。公共 Conscrypt API现在，Conscrypt 安全提供程序包含适用于 TLS 功能的公共 API。过去，用户可以通过反射来访问此功能。但是，由于在 Android P 中增加了关于调用非公共 API 的限制，因此这已在 Android Q 中加入了灰名单，并将在未来版本中进一步受限。 此更新在 android.net.ssl 下增加了一组类，这些类包含用于访问通用 javax.net.ssl API 不提供的功能的静态方法。这些类的名称为相关 javax.net.ssl 类的复数，用户可以由此推断是否为这些类。例如，在 javax.net.ssl.SSLSocket 实例中运行的代码可以使用新的 android.net.ssl.SSLSockets 类中的方法。 连接功能Android Q 包含一些与网络和连接相关的改进。 WLAN 网络连接 APIAndroid Q 增加了对点对点连接的支持。借助此功能，应用可以使用 WifiNetworkSpecifier 描述所请求网络的属性，以此来提示用户更改设备连接到的接入点。点对点连接用于“非网络提供”目的，例如 Chromecast 和 Google Home 硬件等辅助设备的引导配置。 使用此 API 时，您需要遵循以下流程： 使用 WifiNetworkSpecifier.Builder 创建 WLAN 网络说明符。 设置网络过滤器以匹配要连接到的网络以及所需凭据。 在每个请求中确定 SSID、SSID pattern、BSSID 和 BSSID pattern 的组合以设置网络过滤器，但要遵循以下要求： 每个请求都应该至少提供 SSID、SSID pattern、BSSID 或 BSSID pattern 中的一个每个请求都只能设置 SSID 或 SSID pattern 中的一个每个请求都只能设置 BSSID 或 BSSID pattern 中的一个将说明符以及一个 NetworkCallback 实例添加到该网络请求中，以跟踪该请求的状态。 如果用户接受该请求且成功连接到网络，则系统将对回调对象调用 NetworkCallback.onAvailable()。如果用户拒绝该请求或未成功连接到网络，则系统将对回调对象调用 NetworkCallback.onUnavailable()。 点对点连接不需要位置权限和 WLAN 权限。如果您发起连接到对等设备的请求，便会在同一设备上启动一个对话框，让相应设备的用户可以通过此对话框来接受连接请求。 绕过用户批准用户应某个特定应用的请求批准连接到某个网络后，设备便会存储用户针对相应接入点的批准响应。如果该应用再次发出连接到此接入点的特定请求，则设备会跳过用户批准阶段，并自动连接到此网络。在连接到 API 请求的网络后，如果用户选择取消保存该网络，则系统会移除该应用和网络组合对应的已存储批准响应，相应应用将来发出的任何请求都需要由用户再次批准。如果应用发出非特定（例如使用 SSID 或 BSSID pattern）请求，则用户需要批准相应请求。 代码示例以下代码示例显示了如何使用前缀为“test”的 SSID 和 OUI 为“10:03:23”的 BSSID 连接到开放网络。 KOTLINval specifier = WifiNetworkSpecifier.Builder() .setSsidPattern(PatternMatcher(&quot;test&quot;, PatternMatcher.PATTERN_PREFIX)) .setBssidPattern(MacAddress.fromString(&quot;10:03:23:00:00:00&quot;), MacAddress.fromString(&quot;ff:ff:ff:00:00:00&quot;)) .build() val request = NetworkRequest.Builder() .addTransportType(NetworkCapabilities.TRANSPORT_WIFI) .removeCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET) .setNetworkSpecifier(specifier) .build() val connectivityManager = context.getSystemService(Context.CONNECTIVITY_SERVICE) as ConnectivityManager val networkCallback = object : ConnectivityManager.NetworkCallback() { ... override fun onAvailable(network: Network?) { // do success processing here.. } override fun onUnavailable() { // do failure processing here.. } ... } connectivityManager.requestNetwork(request, networkCallback) ... // Release the request when done. connectivityManager.unregisterNetworkCallback(networkCallback)WLAN 网络建议 APIAndroid Q 扩大了支持范围，现在允许应用为设备添加网络凭据，以自动连接到 WLAN 接入点。您可以使用 WifiNetworkSuggestion 提供关于要连接到哪个网络的建议。平台最终会根据您的应用和其他应用的输入来选择要接受的接入点。 以下代码示例显示了如何为一个开放网络、一个 WPA2 网络和一个 WPA3 网络提供凭据： KOTLINval suggestion1 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test111111&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestion2 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test222222&quot;) .setWpa2Passphrase(&quot;test123456&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestion3 = WifiNetworkSuggestion.Builder() .setSsid(&quot;test333333&quot;) .setWpa3Passphrase(&quot;test6789&quot;) .setIsAppInteractionRequired() // Optional (Needs location permission) .build() val suggestionsList = listOf(suggestion1, suggestion2, suggestion3) val wifiManager = context.getSystemService(Context.WIFI_SERVICE) as WifiManager val status = wifiManager.addNetworkSuggestions(suggestionsList); if (status != WifiManager.STATUS_NETWORK_SUGGESTIONS_SUCCESS) { // do error handling here } // Optional (Wait for post connection broadcast to one of your suggestions) val intentFilter = IntentFilter(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION); val broadcastReceiver = object : BroadcastReceiver() { override fun onReceive(context: Context, intent: Intent) { if (!intent.action.equals(WifiManager.ACTION_WIFI_NETWORK_SUGGESTION_POST_CONNECTION)) { return; } // do post connect processing here } }; context.registerReceiver(broadcastReceiver, intentFilter);来自应用的建议必须先得到用户批准，然后平台才会发起到建议的网络的连接。当平台第一次在扫描结果中找到与应用提供的其中一个建议相匹配的网络时，将由用户响应通知进行批准。当平台连接到建议的其中某个网络时，设置会显示相关文本以将网络连接归因于提出建议的相应应用。 处理用户断开连接的行为如果用户在应用连接到建议的某个网络时使用 WLAN 选择器明确断开与该网络的连接，则该网络会被列入黑名单 24 小时。在该网络被列入黑名单期间，即使应用移除并重新添加与该网络对应的网络建议，系统也不会考虑自动连接该网络。 更改应用的审批状态用户拒绝接收网络建议通知时会从应用中移除 CHANGE_WIFI_STATE 权限。用户稍后可以通过转到 WLAN 控制菜单（依次转到设置 &gt; 应用和通知 &gt; 特殊应用权限 &gt; WLAN 控制 &gt; 应用名称）对此作出批准。 改进了 WLAN 高性能和低延迟模式借助 Android Q，您可以为底层调制解调器提供提示，以最大限度地缩短延迟。 Android Q 扩展了 WLAN Lock API，以有效地支持高性能和低延迟模式。系统会针对高性能和低延迟模式停用 WLAN 节能模式，并且您可以在低延迟模式下启用进一步的延迟优化（具体取决于调制解调器支持）。 仅当获取锁的应用在前台运行且屏幕处于开启状态时才能启用低延迟模式。低延迟模式对实时移动游戏应用尤其有用。 DNS 解析器中的专用查找Android Q 增加了对“通过传输层安全协议 (TLS) 执行 DNS”和进行专用 DNS 查找的支持。以前，平台 DNS 解析器支持 A 类解析，它可以根据域名来解析 IP 地址，而无需与通过此 IP 提供的服务有关的具体信息。经过此次更新，它现在还支持 SRV 和 NAPTR 查找。 Android Q 可以为开发者提供标准明文查找和“通过传输层安全协议 (TLS) 执行 DNS”模式。 WLAN Easy Connect借助 Android Q，您可以利用 Easy Connect 为对等设备配置 WLAN 凭据，以替代已弃用的 WPS。应用可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 将 Easy Connect 集成到其设置和配置流程中。此 intent 需要 URI。调用应用可以通过各种方法来检索 URI，包括扫描贴纸或显示屏中的二维码，或扫描蓝牙 LE 或 NFC 广告。 URI 一经可用，您就可以使用 ACTION_PROCESS_WIFI_EASY_CONNECT_URI intent 来配置对等设备的 WLAN 凭据。这样一来，用户就可以选择 WLAN 网络以共享并安全地传输相关凭据。 Easy Connect 不需要位置权限或 WLAN 权限。 注意：在使用此 intent 之前，应用必须先通过调用 WifiManager.isEasyConnectSupported() 验证设备是否支持 Easy Connect。Wi-Fi Direct connection APIWifiP2pConfig 和 WifiP2pManager API 类在 Android Q 中有更新，以支持利用预先确定的信息快速与 WLAN 直连建立连接的功能。此信息通过边信道进行共享，例如蓝牙或 NFC。 以下代码示例显示了如何使用预先确定的信息来创建群组： KOTLINval manager = getSystemService(Context.WIFI_P2P_SERVICE) as WifiP2pManager val channel = manager.initialize(this, mainLooper, null) // prefer 5G band for this group val config = WifiP2pConfig.Builder() .setNetworkName(&quot;networkName&quot;) .setPassphrase(&quot;passphrase&quot;) .enablePersistentMode(false) .setGroupOperatingBand(WifiP2pConfig.GROUP_OWNER_BAND_5GHZ) .build() // create a non-persistent group on 5GHz manager.createGroup(channel, config, null)要使用凭据加入群组，请将 manager.createGroup() 替换为以下内容： KOTLIN manager.connect(channel, config, null) 蓝牙 LE 连接导向型频道 (CoC)借助 Android Q，您的应用可以使用 BLE CoC 连接在两个 BLE 设备之间传输较大的数据流。此接口抽象化处理了蓝牙和连接机制，以简化实现。 电话功能Android Q 包含一些与电话相关的改进。 通话质量方面的改进Android Q 增加了在支持相关功能的设备上收集进行中的 IP 多媒体子系统 (IMS) 通话质量相关信息的功能，包括通过网络接听和拨打电话的质量。 选接电话和来电显示Android Q 让您的应用可以将用户通讯录中不存在号码的来电标识为潜在骚扰电话，以及代表用户拒接骚扰电话而不响铃。系统会在通话记录中将这些已屏蔽的来电的相关信息记录为已屏蔽的来电，以便用户更清楚地了解何时有过未接来电。使用此新版 API，不需要从用户那里获取 READ_CALL_LOG 权限就可以提供选接电话和来电显示功能。 Call Redirection Service APIAndroid Q 更改了来电 Intent 的处理方式。我们弃用了 NEW_OUTGOING_CALL 广播，并将其替换为 CallRedirectionService API。CallRedirectionService 提供了相关接口，以供您修改 Android 平台拨打的去电。例如，第三方应用可能会取消通话并通过 VoIP 对其进行重新路由。 在外部存储设备中创建文件的相关改进除了引入分区存储隐私权行为变更之外，Android Q 还在写入文件方面提供了更大的灵活性，添加了可以帮助您影响这些文件在外部存储设备上的保存位置的功能。 新媒体文件的待处理状态Android Q 引入了 IS_PENDING 标记，通过此标记，您的应用可以在媒体文件写入磁盘时进行独占访问。 以下代码段显示了在应用中创建新图片时如何使用 IS_PENDING 标记。 KOTLINval values = ContentValues().apply { put(MediaStore.Images.Media.DISPLAY_NAME, &quot;IMG1024.JPG&quot;) put(MediaStore.Images.Media.MIME_TYPE, &quot;image/jpeg&quot;) put(MediaStore.Images.Media.IS_PENDING, 1) } val resolver = context.getContentResolver() val collection = MediaStore.Images.Media .getContentUri(MediaStore.VOLUME_EXTERNAL_PRIMARY) val item = resolver.insert(collection, values) resolver.openFileDescriptor(item, &quot;w&quot;, null).use { pfd -&gt; // Write data into the pending image. } // Now that we&apos;re finished, release the &quot;pending&quot; status, and allow other apps // to view the image. values.clear() values.put(MediaStore.Images.Media.IS_PENDING, 0) resolver.update(item, values, null, null)对存储位置的影响Android Q 引入了多种功能，可以帮助您整理您的应用存储在外部存储设备上的文件。 目录提示当您的应用将媒体存储在搭载 Android Q 的设备上时，系统默认按照媒体的类型对其进行整理。例如，默认情况下，新图片文件会存储在“pictures”目录下。 如果您的应用知道应存储文件的具体位置（例如 Pictures/MyVacationPictures），您可以设置 MediaColumns.RELATIVE_PATH，以便提示系统在何处存储新写入的文件。同样，您可以在调用 update() 期间通过更改 MediaColumns.RELATIVE_PATH 或 MediaColumns.DISPLAY_NAME 来移动磁盘上的文件。 设备选择在 Android 9（API 级别 28）及更低版本中，保存到外部存储设备上的所有文件都显示在名为 external 的单个卷下。但是，Android Q 为每个外部存储设备都提供唯一的卷名称。这一新的命名系统可帮助您高效地整理内容并将内容编入索引，还可让您控制新内容的存储位置。 主要共享存储设备始终称为 VOLUME_EXTERNAL_PRIMARY。您可以通过调用 MediaStore.getExternalVolumeNames() 发现其他卷。 要查询、插入、更新或删除特定卷，请将卷名称传递到 MediaStore API 中的任何 getContentUri() 方法，如以下代码段中所示： // Publish an audio file onto a specific external storage device. val values = ContentValues().apply { put(MediaStore.Audio.Media.RELATIVE_PATH, &quot;Music/My Album/My Song&quot;) put(MediaStore.Audio.Media.DISPLAY_NAME, &quot;My Song.mp3&quot;) } // Assumes that the storage device of interest is the 2nd one // that your app recognizes. val volumeNames = MediaStore.getExternalVolumeNames(context) val selectedVolumeName = volumeNames[1] val collection = MediaStore.Audio.Media.getContentUri(selectedVolumeName) val item = resolver.insert(collection, values)注意：在 Android Q 中，StorageVolume 类中的 createAccessIntent() 方法已被弃用，因此您不应使用此方法浏览外部存储设备。如果您这么做，Android Q 设备的用户将无法在您的应用中查看保存在外部存储设备中的文件。媒体和图形Android Q 引入了以下媒体和图形方面的新功能和 API： 捕获播放的音频Android Q 可让应用捕获其他应用播放的音频。要了解所有详情，请参阅捕获播放的音频。 原生 MIDI API借助 Android Native MIDI API (AMidi)，应用开发者可以使用 C/C++ 代码发送和接收 MIDI 数据、与 C/C++ 音频/控制逻辑进行更紧密的集成以及最大限度地减少对 JNI 的需求。 有关详情，请参阅 Android Native MIDI API。 MediaCodecInfo 方面的改进MediaCodecInfo 中有一些新方法可以显示有关编解码器的更多信息： isSoftwareOnly()如果编解码器仅在软件中运行，则返回 true。软件编解码器并不能保证渲染性能。isHardwareAccelerated()如果编解码器由硬件加速，则返回 true。isVendor()如果编解码器由设备供应商提供，则返回 true；如果由 Android 平台提供，则返回 false。isAlias()MediaCodecList 可能针对使用备用编解码器名称（别名）的同一底层编解码器包含额外的条目。如果此条目中的编解码器是另一个编解码器的别名，则此方法会返回 true。此外，MediaCodec.getCanonicalName() 会针对通过别名创建的编解码器返回底层编解码器名称。 性能点“性能点”表示编解码器以特定高度、宽度和帧速率渲染视频的能力。例如，UHD_60 性能点表示以每秒 60 帧的速度渲染超高清视频（3840x2160 像素）。 方法 MediaCodecInfo.VideoCapabilities.getSupportedPerformancePoints() 会返回编解码器可以渲染或捕获的 PerformancePoint 条目列表。 您可以通过调用 PerformancePoint.covers(PerformancePoint) 检查给定的 PerformancePoint 是否会覆盖另一个性能点。例如，UHD_60.covers(UHD_50) 会返回 true。 我们为所有硬件加速的编解码器都提供了性能点列表。如果编解码器连标准性能点的最低值都不能满足，则此列表可能为空。 请注意，已升级到 Android Q 但未更新供应商映像的设备是没有性能点数据的，因为此数据来自供应商 HAL。在这种情况下，getSupportedPerformancePoints() 会返回 null。 ANGLE在 Android Q 发布后，Android 开发者和合作伙伴可以选择使用 ANGLE 运行应用；ANGLE 是 Chrome 组织中的一个项目，能够将 ES 置于 Vulkan 上层，而不必使用供应商提供的 ES 驱动程序。 有关详情，请参阅 ANGLE。 Thermal API当设备过热时，它们可能会限制 CPU 和/或 GPU，而这可能会以意想不到的方式影响应用和游戏。使用复杂图形、大量计算或持续网络活动的应用更有可能遇到问题，并且问题可能因芯片组和核心频率、集成级别以及设备封装和设备类型而异。 现在，在 Android Q 中，应用和游戏可以使用 Thermal API 监控设备变化情况，并在设备过热时采取措施维持低电耗状态，使设备恢复到正常温度。应用在 PowerManager 中注册监听器，系统通过该监听器报告持续的热状态，热状态的范围从轻度和中度到重度、危急、紧急和关机。 当设备报告热应力时，各应用和游戏可以减少正在进行的活动，以此来帮助减少各个方面的耗电量。例如，影音在线播放应用可以降低分辨率/比特率或减少网络流量；相机应用可以停用闪光灯或密集型图像增强；游戏可以降低帧速率或减少多边形曲面细分；媒体应用可以降低扬声器音量；地图应用可以关闭 GPS。 Thermal API 需要新的设备 HAL 层，目前在搭载 Android Q 的 Pixel 设备上受支持。我们正在与设备制造商合作伙伴合作，以期尽快为生态系统提供广泛支持。 摄像头和图片Android Q 引入了摄像头和图片方面的以下新功能： 单色摄像头支持Android 9（API 等级 28）首次引入了单色摄像头功能。Android Q 为单色摄像头支持增加了几项增强功能： 新增了对 Y8 流格式的支持，以提高内存效率。支持单色原始 DNG 捕获。引入了 MONO 和 NIR CFA 枚举，以区分常规单色摄像头和近红外摄像头。您可以使用此功能来捕捉原生单色图片。逻辑多摄像头设备可以使用单色摄像头作为物理子摄像头，以获取更出色的低光图片质量。 动态深度格式从 Android Q 开始，摄像头可以使用名为“动态深度格式”(DDF) 的新架构将图片的深度数据存储在单独的文件中。应用可以请求 JPG 图片及其深度元数据，以便在后期处理中利用这些信息来应用所需的模糊处理，而无需修改原始图片数据。 要了解新格式的规范，请参阅动态深度格式。 高效率图片文件格式高效率图片文件 (HEIF) 格式是一种标准的图片和视频格式，与其他文件格式相比，这种格式的编码质量更高，文件更小。 如需详细了解此文件格式，请参阅 HEIC。 多摄像头方面的改进Android 9（API 级别 28）中引入了将多摄像头融合成单个逻辑摄像头的功能，Android Q 对此功能进行了改进。Camera2 API 中添加了以下内容： isSessionConfigurationSupported(SessionConfiguration sessionConfig) - 使您能够查询传递的会话配置能否用于创建摄像头拍摄会话。 LOGICAL_MULTI_CAMERA_ACTIVE_PHYSICAL_ID - 使您能够确定支持逻辑摄像头设备的有效物理摄像头的 ID。您可以使用返回的 ID 来请求逻辑信息流和物理子摄像头信息流，以提高用电效率。 无障碍服务 APIAndroid Q 引入了以下新的无障碍服务功能和 API： AccessibilityNodeInfo 输入键标记在 Android Q 中，AccessibilityNodeInfo 得到了增强，现在增加了一个新标记，用于指示其是否代表文本输入键的。您可以使用 AccessibilityNodeInfo.isTextEntryKey() 方法来访问此标记。 无障碍对话框语音反馈当无障碍服务要求用户重复按无障碍快捷方式以启动服务时，此对话框现在可以在服务请求时附带文字转语音提示。 物理键盘的无障碍快捷方式在 Android Q 中，用户现在可以通过物理键盘来触发无障碍快捷方式，只需按 Control+Alt+Z 即可。 软键盘控制器增强功能在 Android Q 中，无障碍服务现在可以请求显示软键盘，即使设备检测到连接了硬键盘也不例外。用户可以替换此行为。 用户定义的无障碍服务超时Android Q 引入了 API 方法 AccessibilityManager.getRecommendedTimeoutMillis()，用于为用户针对互动式和非互动式的无障碍界面元素定义的超时提供支持。返回值受用户偏好设置和无障碍服务 API 的影响。 自动填充方面的改进Android Q 包含对自动填充服务的以下改进。 与兼容性相关的自动填充请求您现在可以使用 FillRequest.FLAG_COMPATIBILITY_MODE_REQUEST 标记确定是否通过兼容性模式生成了自动填充请求。 同时保存用户名和密码借助 SaveInfo.FLAG_DELAY_SAVE 标记，应用现在可以使用多个 Activity 显示用户名、密码和其他字段。 用户与保存界面的互动您现在可以在保存对话框中显示和隐藏密码字段，只需在此对话框中设置操作监听器，并更改相应密码远程视图的可见性即可。 支持更新数据集现在，自动填充功能可以更新现有密码。例如，如果用户已经存储了一个密码，然后又保存了一个新密码，则自动填充功能现在会提示用户更新现有密码，而不是保存新密码。 字段分类方面的改进Android Q 包含对 Field Classification API 的以下改进。 UserData.Builder 构造函数我们更改了 UserData.Builder 构造函数，现在可以更好地契合 Builder 模式。 允许将一个值映射到多种类别 ID在使用 Android Q 中的 UserData.Builder 时，您现在可以将一个值映射到多种类别 ID。在以前的版本中，如果一个值被添加多次，系统就会抛出异常。 改进了对信用卡号码的支持现在，字段分类可以检测四位数字作为信用卡号码的最后四位数字。 支持特定于应用的字段分类Android Q 增加了 FillResponse.setUserData()，让您能够在会话期间设置特定于应用的用户数据。这有助于自动填充服务检测包含特定于应用的内容的字段的类型。 界面和系统控件Android Q 提供以下界面方面的改进： 支持 JVMTI PopFrame 功能Android Q 增加了对 Android JVMTI 实现中的 can_pop_frames 功能的支持。在调试时，此功能让您能够在断点暂停并调整函数的局部变量、全局变量或实现，然后重新运行函数。有关详情，请参阅 Oracle 的 Pop Frame 参考页面。 Surface Control APIAndroid Q 提供了一个 SurfaceControl API，用于对系统合成器 (SurfaceFlinger) 进行底层访问。对于大多数用户而言，SurfaceView 是使用此合成器的正确方法。SurfaceControl API 在某些情况下很有用，例如： 同步多个表面跨进程的表面嵌入底层生命周期管理SurfaceControl API 在 SDK 和 NDK 绑定中都可用。NDK 实现包含用于与合成器手动交换缓冲区的 API。这为遇到 BufferQueue 限制的用户提供了一种替代方案。 WebView 挂起渲染程序检测Android Q 引入了一个新的 WebViewRenderProcessClient 抽象类，应用可以使用该抽象类检测 WebView 是否无响应。要使用此类，请执行以下操作： 定义您自己的子类，并实现其 onRenderProcessResponsive() 和 onRenderProcessUnresponsive() 方法。将 WebViewRenderProcessClient 的实例附加到一个或多个 WebView 对象上。如果 WebView 无响应，系统将调用客户端的 onRenderProcessUnresponsive() 方法，在调用时会传递 WebView 和 WebViewRenderProcess（如果 WebView 是单进程，WebViewRenderProcess 参数将为 null）。您的应用可以执行适当的操作，例如向用户显示一个对话框，以询问其是否要暂停渲染流程。如果 WebView 仍然无响应，则系统会定期调用 onRenderProcessUnresponsive()（频率不高于每 5 秒一次），但不会执行其他任何操作。如果 WebView 再次无响应，系统只调用 onRenderProcessResponsive() 一次。 设置面板Android Q 引入了“设置面板”，这是一种 API，让应用能够在自身环境中向用户显示设置。这可以避免用户转到设置更改 NFC 或移动数据等设置，以便使用此应用。 图 1. 用户尝试在设备未连接到网络时打开网页。Chrome 弹出互联网连接设置面板… 图 2. 用户可以开启 WLAN 并选择网络，而无需离开 Chrome 应用。例如，假设用户打开了网络浏览器，而其设备已开启飞行模式。在 Android Q 之前的版本中，此应用只能显示一条通用消息，要求用户打开设置以恢复连接。而借助 Android Q，浏览器应用便可以显示一个内嵌面板，其中会显示各种主要连接设置，例如飞行模式、WLAN（包括附近的网络）和移动数据。借助此面板，用户无需离开应用即可恢复连接。 要显示设置面板，请发出具有某个新 Settings.Panel 操作的 intent： KOTLINval panelIntent = Intent(Settings.Panel.settings_panel_type) startActivityForResult(panelIntent)settings_panel_type 可以是下列项之一： ACTION_INTERNET_CONNECTIVITY显示与互联网连接相关的设置，例如飞行模式、WLAN 和移动数据。ACTION_WIFI：显示 WLAN 设置，但不显示其他连接设置。这对于需要 WLAN 连接以执行大容量上传或下载的应用非常有用。ACTION_NFC显示与近距离无线通信 (NFC) 相关的所有设置。ACTION_VOLUME显示所有音频流的音量设置。我们计划针对此功能引入一个 AndroidX 封装容器。在搭载 Android 9（API 级别 28）或更低级别的设备上调用时，此封装容器会在设置应用中打开最合适的页面。 共享功能方面的改进Android Q 为共享功能提供了多项改进。要了解所有详情，请参阅 Android Q 中共享功能方面的改进。 深色主题背景Android Q 提供全新的深色主题背景，既会应用于 Android 系统界面，也会应用于设备上运行的应用。要了解所有详情，请参阅深色主题背景。 前台服务类型Android Q 引入了一个新的 XML 清单属性 foregroundServiceType，您可以将其包含在多项特定服务的定义中。虽然很少适用，但您可以为一项特定服务分配多个前台服务类型。 下表显示了不同的前台服务类型，以及适合在其中声明特定类型的服务： 前台服务类型 应声明相应类型的服务的示例使用情形connectedDevice 监控穿戴式设备健身跟踪器dataSync 从网络下载文件location 延续用户发起的操作mediaPlayback 播放有声读物、播客或音乐mediaProjection 简短地录屏phoneCall 处理正在进行的通话KotlinAndroid Q 对 Kotlin 开发进行了以下更新。 libcore API 的可空性注释Android Q 改进了 SDK 中针对 libcore API 的可空性注释的覆盖范围。借助这些注释，在 Android Studio 中使用 Kotlin 或 Java 可空性分析的应用开发者可以在与这些 API 互动时获取非 Null 信息。 通常，Kotlin 中的为空性合同违规行为会导致编译错误。为确保与现有代码兼容，所有新注释都仅限于 @RecentlyNullable 和 @RecentlyNonNull。这意味着为空性违规行为会引发警告，而不是错误。 此外，Android 9 中添加的所有 @RecentlyNullable 或 @RecentlyNonNull 注释都会分别更改为 @Nullable 和 @NonNull。这意味着为空性违规行为现在会引发错误，而不是警告。 要详细了解注释方面的变更，请参阅 Android 开发者博客中的 Android Pie SDK 现已更适用于 Kotlin一文。 NDKAndroid Q 包含以下 NDK 方面的变更。 改进了文件描述符所有权的调试Android Q 增加了 fdsan，它可以帮助您更轻松地查找和修复文件描述符所有权方面的问题。 与错误处理文件描述符所有权相关的错误（通常表现为“use-after-close”和“double-close”）类似于内存分配“use-after-free”和“double-free”错误，但通常更难以诊断和修复。“fdsan”会尝试通过强制执行文件描述符所有权来检测和/或防止文件描述符误管理。 要详细了解与这些问题相关的崩溃，请参阅 fdsan 检测到的错误。要详细了解 fdsan，请参阅关于 fdsan 的 Googlesource 页面。 ELF TLS使用 API 级别 29 及更高版本的 NDK 编译的应用无需再使用 emutls，但可以改为使用 ELF TLS。我们增加了对动态和静态链接器的支持，以支持处理线程局部变量的新方法。 对于针对 API 级别 28 及更低版本编译的应用，我们实现了针对 libgcc/compiler-rt 的改进，以便解决一些 emutls 问题。 有关详情，请参阅面向 NDK 开发者的 Android 变更。 运行时Android Q 包含以下运行时方面的变更。 触发基于 Mallinfo 的垃圾回收当小型平台 Java 对象引用 C++ 堆中的大型对象时，通常只有在系统已回收并（举例而言）最终确定 Java 对象后，才能回收 C++ 对象。在之前的版本中，平台会估算与 Java 对象相关联的许多 C++ 对象的大小。这种估算并不总是准确，并且偶尔会导致内存使用量大大增加，因为平台无法在应该进行垃圾回收时完成回收。 在 Android Q 中，垃圾回收器 (GC) 会跟踪系统 malloc() 分配的堆的总大小，以确保 malloc() 分配的大型堆始终包含在可触发 GC 的计算中。因此，与 Java 执行交错大量 C++ 分配的应用可能会出现垃圾回收频率提高的现象。其他应用的频率则可能会略有下降。 测试和调试Android Q 包含以下测试和调试方面的改进。 改进了设备上系统跟踪功能现在，您在执行设备上系统跟踪时可以指定跟踪的记录大小和持续时间限制。在您指定任一值后，系统便会执行长期跟踪，并在记录跟踪时定期将跟踪缓冲区复制到目标文件。在达到您指定的记录大小或持续时间限制后，跟踪便会完成。 请使用这些附加参数来测试除了您使用标准跟踪进行测试的用例之外的其他用例。例如，您可能正在诊断某个性能错误，而此错误仅在您的应用长时间运行后才会发生。在这种情况下，您可以记录为期一整天的长期跟踪，然后分析 CPU 调度程序、磁盘活动、应用线程以及报告中的其他数据，以帮助您确定造成此错误的原因。 TextClassifier 改进Android Q 在 TextClassifier 接口中提供了其他文本分类功能。 语言检测TextClassifier 现在具有 detectLanguage() 方法。此方法的工作方式与现有分类方法类似，即接收 TextLanguage.Request 对象并返回 TextLanguage 对象。 新的 TextLanguage 对象包含一系列有序对。每个有序对都包含所请求文本示例的语言区域和相应的置信度得分。 建议采取的对话操作TextClassifier 现在具有 suggestConversationActions() 方法。此方法的工作方式与现有分类方法类似，即接收 ConversationActions.Request 对象并返回 ConversationActions 对象。 新的 ConversationActions 对象包含一系列 ConversationAction 对象。每个 ConversationAction 对象都包含建议采取的可行操作及其置信度得分。 通知中的智能回复/操作Android 9 引入了在通知中显示建议回复的功能。从 Android Q 开始，通知中还可以包含基于 intent 的建议操作。此外，现在系统可以自动生成这些建议。应用仍然可以提供它们自己的建议，或选择停用系统生成的建议。 用于生成这些回复的 API 是 TextClassifier 的一部分，且已在 Android Q 中直接提供给开发者。如需了解详情，请参阅关于 TextClassifier 改进的部分。 如果您的应用提供自己的建议，则平台不会生成任何自动建议。如果您不希望应用的通知显示任何建议回复或操作，可以通过使用 setAllowGeneratedReplies() 和 setAllowSystemGeneratedContextualActions() 选择停用系统生成的回复和操作。","categories":[{"name":"Api","slug":"Api","permalink":"http://zhangyongfa888.site/categories/Api/"}],"tags":[{"name":"Android","slug":"Android","permalink":"http://zhangyongfa888.site/tags/Android/"}],"author":"zhangyognfa"},{"title":"滴滴调整北京市网约车价格 将16区按计价标准划分为5大类","slug":"HEXO-Admin","date":"2019-07-10T02:57:00.000Z","updated":"2019-09-03T00:23:11.641Z","comments":true,"path":"2019/07/10/HEXO-Admin/","link":"","permalink":"http://zhangyongfa888.site/2019/07/10/HEXO-Admin/","excerpt":"","text":"滴滴调整北京市网约车价格 将16区按计价标准划分为5大类本报讯（记者 陈雪柠）针对不同时间的需求状况，滴滴将对本市网约车价格进行调整。昨天，滴滴出行发布本市滴滴网约车价格调整说明，宣布自7月11日起，滴滴网约车将根据区域进行价格调整。 滴滴将全市16区按计价标准划分为5大类。其中，东城区、西城区、海淀区、朝阳区、丰台区、石景山区、昌平区、门头沟区为一类，顺义区、通州区、大兴区、房山区为一类，密云区、怀柔区为一类，延庆区及平谷区则各自单独计价。 以东城区、西城区等区域计价标准看，调整后，工作日早6点至10点的早高峰时段，起步价由13元涨至14元，里程费由1.6元/公里涨至1.8元/公里，时长费不变；早10点至晚5点的平峰时段，里程费由1.6元/公里降至1.45元/公里，时长费由0.5元/公里降至0.4元/公里，起步价不变；晚5点至晚9点的晚高峰时段，起步价由13元涨至14元，里程费由1.6元/公里降至1.5元/公里，时长费不变；晚9点至早6点的夜间时段，起步价由13元涨至14元，里程费由1.6元/公里涨至2.15元/公里，时长费由1元降至0.8元/公里。 总体看，高峰时段价格普遍上涨，平峰时段价格有所降低。远郊区起步价降低，其中延庆区、平谷区起步价均为8元，密云区、怀柔区起步价也降低为11.5元。 对于价格调整的原因，滴滴出行表示是调节供需平衡，撮合司乘需求。“我们会基于不同城市不同时间的供需状况，并参考当地的消费水平、收入水平和能源价格等因素，合理地调整网约车价格。价格机制要满足乘客需求，还要让司机能获得合理的收入。” 滴滴建议市民合理安排行程尽量错峰出行；在高峰期用车可选择“同时呼叫”或拼车，提高出行效率；不好叫车时，可选择APP内单车或“公交”路线査询功能，选择其他出行方式。","categories":[{"name":"NEWS","slug":"NEWS","permalink":"http://zhangyongfa888.site/categories/NEWS/"}],"tags":[{"name":"互联网","slug":"互联网","permalink":"http://zhangyongfa888.site/tags/互联网/"}],"author":"zhangyognfa"},{"title":"Hello World","slug":"hello-world","date":"2019-07-09T07:09:38.366Z","updated":"2019-07-09T07:09:38.366Z","comments":true,"path":"2019/07/09/hello-world/","link":"","permalink":"http://zhangyongfa888.site/2019/07/09/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}